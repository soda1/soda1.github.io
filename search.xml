<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>UML对象关系</title>
    <url>/2023/01/08/design%20pattern/UML/</url>
    <content><![CDATA[<ol>
<li><p>泛化关系(generalization) </p>
<p> 继承（is-a）</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108001753.png" alt="image-20230108001753062" loading="lazy"></p>
</li>
<li><p>实现关系(realize)</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108001934.png" alt="image-20230108001934839" loading="lazy"></p>
</li>
<li><p>聚合关系(aggregation)</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108002139.png" alt="image-20230108002139588" loading="lazy"></p>
<p>表示A组成B，不是强依赖关系，比如部门撤销了，但人还存在</p>
</li>
<li><p>组合关系(composition)</p>
<p><img src="C:\Users\f\AppData\Roaming\Typora\typora-user-images\image-20230108002049034.png" alt="image-20230108002049034" loading="lazy"></p>
<p>表示A组成B，强依赖关系，比如公司不存在了，部门也会不存在</p>
</li>
<li><p>关联关系(association)</p>
<p>用直线表示，如果强调方向则在一端加上箭头</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108002502.png" alt="image-20230108002502073" loading="lazy"></p>
<p>表示A知道B</p>
<p>关联对象通常是以成员变量的形式实现的；</p>
</li>
<li><p>依赖关系(dependency)</p>
<p>这种关系具有临时性，在代码上的表现一般为函数参数，局部变量，对静态方法的调用。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108003156.png" alt="image-20230108003156835" loading="lazy"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
  </entry>
  <entry>
    <title>behavioral patterns</title>
    <url>/2023/01/08/design%20pattern/behavioral%20patterns/</url>
    <content><![CDATA[<h4 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h4><p>一对多依赖关系，被依赖对象叫做被观察者，依赖对象叫做观察者。也被称为<strong>发布订阅模式</strong></p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108144537.png" alt="image-20230108144537852" loading="lazy"></p>
<h4 id="模板模式"><a href="#模板模式" class="headerlink" title="模板模式"></a>模板模式</h4><p>定义一个骨架算法（业务步骤），然后具体的算法由子类去实现。</p>
<p>假如有一批不同格式的数据需要处理，处理的步骤基本一致，差异在于数据提取细节不同。这时候就可以使用模板模式来定义业务步骤，将数据提取这一步骤由子类去实现。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108152126.png" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108152407.png" loading="lazy"></p>
<h4 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h4><p>定义一族算法类，将每个算法分别封装起来，让它们可以互相替换。策略模式可以使算法的变化独立于使用它们的客户端（这里的客户端代指使用算法的代码）</p>
<p>一般策略模式会配合工厂模式一起使用，根据条件来选用不同的策略。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108155021.png" loading="lazy"></p>
<h4 id="责任链模式"><a href="#责任链模式" class="headerlink" title="责任链模式"></a>责任链模式</h4><p>将请求的发送和接收解耦，让多个接收对象都有机会处理同一个请求。将这些接收对象串成一条链，并沿着这条链传递这个请求，直到链上的某个接收对象能够处理它为止。链上的每个处理器都有自己的职责。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108155846.png" loading="lazy"></p>
<h4 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h4><p>一般用于状态机，将状态转换逻辑拆分到不同的状态类中，从而消除if-else（switch-case）条件</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108171118.png" loading="lazy"></p>
<h4 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h4><p>对于集合，可能会有不同的方式来遍历元素，数组和链表比较简单，直接遍历即可，但对于tree这种结构有多种遍历方式（前序，后序，中序），这时候就需要使用迭代器模式。具体来说就是在<strong>集合类组合一个迭代类</strong>。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108223336.png" loading="lazy"></p>
<h4 id="访问者模式（TODO）"><a href="#访问者模式（TODO）" class="headerlink" title="访问者模式（TODO）"></a>访问者模式（TODO）</h4><h4 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h4><p>在不违背封装原则的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，以便之后恢复对象为先前的状态。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108225709.png" loading="lazy"></p>
<h4 id="命令模式（不太明白）"><a href="#命令模式（不太明白）" class="headerlink" title="命令模式（不太明白）"></a>命令模式（不太明白）</h4><p>将请求转换为一个包含与请求相关的所有信息的独立对象。 该转换让你能根据不同的请求将方法参数化、 延迟请求执行或将其放入队列中， 且能实现可撤销操作。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108235041.png" loading="lazy"></p>
<ol>
<li><p>The <strong>Sender</strong> class (aka <em>invoker</em>) is responsible for initiating requests. This class must have a field for storing a reference to a command object. The sender triggers that command instead of sending the request directly to the receiver. Note that the sender isn’t responsible for creating the command object. Usually, it gets a pre-created command from the client via the constructor.</p>
</li>
<li><p>The <strong>Command</strong> interface usually declares just a single method for executing the command.</p>
</li>
<li><p><strong>Concrete Commands</strong> implement various kinds of requests. A concrete command isn’t supposed to perform the work on its own, but rather to pass the call to one of the business logic objects. However, for the sake of simplifying the code, these classes can be merged.</p>
<p>Parameters required to execute a method on a receiving object can be declared as fields in the concrete command. You can make command objects immutable by only allowing the initialization of these fields via the constructor.</p>
</li>
<li><p>The <strong>Receiver</strong> class contains some business logic. Almost any object may act as a receiver. Most commands only handle the details of how a request is passed to the receiver, while the receiver itself does the actual work.</p>
</li>
<li><p>The <strong>Client</strong> creates and configures concrete command objects. The client must pass all of the request parameters, including a receiver instance, into the command’s constructor. After that, the resulting command may be associated with one or multiple senders.</p>
</li>
</ol>
<h4 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h4><p>解释器模式为某个语言定义它的语法（或者叫文法）表示，并定义一个解释器用来处理这个语法。</p>
<pre><code class="java">public interface Expression &#123;
  long interpret();
&#125;
public class NumberExpression implements Expression &#123;
  private long number;
  public NumberExpression(long number) &#123;
    this.number = number;
  &#125;
  public NumberExpression(String number) &#123;
    this.number = Long.parseLong(number);
  &#125;
  @Override
  public long interpret() &#123;
    return this.number;
  &#125;
&#125;
public class AdditionExpression implements Expression &#123;
  private Expression exp1;
  private Expression exp2;
  public AdditionExpression(Expression exp1, Expression exp2) &#123;
    this.exp1 = exp1;
    this.exp2 = exp2;
  &#125;
  @Override
  public long interpret() &#123;
    return exp1.interpret() + exp2.interpret();
  &#125;
&#125;
// SubstractionExpression/MultiplicationExpression/DivisionExpression与AdditionExpression代码结构类似，这里就省略了
public class ExpressionInterpreter &#123;
  private Deque&lt;Expression&gt; numbers = new LinkedList&lt;&gt;();
  public long interpret(String expression) &#123;
    String[] elements = expression.split(&quot; &quot;);
    int length = elements.length;
    for (int i = 0; i &lt; (length+1)/2; ++i) &#123;
      numbers.addLast(new NumberExpression(elements[i]));
    &#125;
    for (int i = (length+1)/2; i &lt; length; ++i) &#123;
      String operator = elements[i];
      boolean isValid = &quot;+&quot;.equals(operator) || &quot;-&quot;.equals(operator)
              || &quot;*&quot;.equals(operator) || &quot;/&quot;.equals(operator);
      if (!isValid) &#123;
        throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);
      &#125;
      Expression exp1 = numbers.pollFirst();
      Expression exp2 = numbers.pollFirst();
      Expression combinedExp = null;
      if (operator.equals(&quot;+&quot;)) &#123;
        combinedExp = new AdditionExpression(exp1, exp2);
      &#125; else if (operator.equals(&quot;-&quot;)) &#123;
        combinedExp = new AdditionExpression(exp1, exp2);
      &#125; else if (operator.equals(&quot;*&quot;)) &#123;
        combinedExp = new AdditionExpression(exp1, exp2);
      &#125; else if (operator.equals(&quot;/&quot;)) &#123;
        combinedExp = new AdditionExpression(exp1, exp2);
      &#125;
      long result = combinedExp.interpret();
      numbers.addFirst(new NumberExpression(result));
    &#125;
    if (numbers.size() != 1) &#123;
      throw new RuntimeException(&quot;Expression is invalid: &quot; + expression);
    &#125;
    return numbers.pop().interpret();
  &#125;
&#125;</code></pre>
<h4 id="中介模式"><a href="#中介模式" class="headerlink" title="中介模式"></a>中介模式</h4><p>定义了一个单独的（中介）对象，来封装一组对象之间的交互。将这组对象之间的交互委派给与中介对象交互，来避免对象之间的直接交互。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230109001300.png" loading="lazy"></p>
<ol>
<li><p><strong>Components</strong> are various classes that contain some business logic. Each component has a reference to a mediator, declared with the type of the mediator interface. The component isn’t aware of the actual class of the mediator, so you can reuse the component in other programs by linking it to a different mediator.</p>
</li>
<li><p>The <strong>Mediator</strong> interface declares methods of communication with components, which usually include just a single notification method. Components may pass any context as arguments of this method, including their own objects, but only in such a way that no coupling occurs between a receiving component and the sender’s class.</p>
</li>
<li><p><strong>Concrete Mediators</strong> encapsulate relations between various components. Concrete mediators often keep references to all components they manage and sometimes even manage their lifecycle.</p>
</li>
<li><p>Components must not be aware of other components. If something important happens within or to a component, it must only notify the mediator. When the mediator receives the notification, it can easily identify the sender, which might be just enough to decide what component should be triggered in return.</p>
<p>From a component’s perspective, it all looks like a total black box. The sender doesn’t know who’ll end up handling its request, and the receiver doesn’t know who sent the request in the first place.</p>
</li>
</ol>
]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
  </entry>
  <entry>
    <title>code quality checkList</title>
    <url>/2022/12/12/design%20pattern/checkList/</url>
    <content><![CDATA[<h5 id="常规checkList"><a href="#常规checkList" class="headerlink" title="常规checkList"></a>常规checkList</h5><ul>
<li>目录设置是否合理、模块划分是否清晰、代码结构是否满足“高内聚、松耦合”？</li>
<li>是否遵循经典的设计原则和设计思想（SOLID、DRY、KISS、YAGNI、LOD 等）？</li>
<li>设计模式是否应用得当？是否有过度设计？</li>
<li>代码是否容易扩展？如果要添加新功能，是否容易实现？</li>
<li>代码是否可以复用？是否可以复用已有的项目代码或类库？是否有重复造轮子？</li>
<li>代码是否容易测试？单元测试是否全面覆盖了各种正常和异常的情况？</li>
<li>代码是否易读？是否符合编码规范（比如命名和注释是否恰当、代码风格是否一致等）？</li>
</ul>
<h5 id="业务需求checkList"><a href="#业务需求checkList" class="headerlink" title="业务需求checkList"></a>业务需求checkList</h5><ul>
<li>代码是否实现了预期的业务需求？</li>
<li>逻辑是否正确？是否处理了各种异常情况？</li>
<li>日志打印是否得当？是否方便 debug 排查问题？</li>
<li>接口是否易用？是否支持幂等、事务等？</li>
<li>代码是否存在并发问题？是否线程安全？</li>
<li>性能是否有优化空间，比如，SQL、算法是否可以优化？</li>
<li>是否有安全漏洞？比如输入输出校验是否全面？</li>
</ul>
]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
  </entry>
  <entry>
    <title>creator patterns</title>
    <url>/2022/12/12/design%20pattern/creator%20patterns/</url>
    <content><![CDATA[<h4 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h4><p>只允许类创建一个实例</p>
<h5 id="创建方式"><a href="#创建方式" class="headerlink" title="创建方式"></a>创建方式</h5><ul>
<li><p>饿汉式</p>
<pre><code class="java">public class IdGenerator &#123; 
  private AtomicLong id = new AtomicLong(0);
  private static final IdGenerator instance = new IdGenerator();
  private IdGenerator() &#123;&#125;
  public static IdGenerator getInstance() &#123;
    return instance;
  &#125;
  public long getId() &#123; 
    return id.incrementAndGet();
  &#125;
&#125;</code></pre>
</li>
<li><p>懒汉式</p>
<p>双重检测</p>
<pre><code class="java">public class IdGenerator &#123; 
  private AtomicLong id = new AtomicLong(0);
  private static IdGenerator instance;
  private IdGenerator() &#123;&#125;
  public static IdGenerator getInstance() &#123;
    if (instance == null) &#123;
      synchronized(IdGenerator.class) &#123; // 此处为类级别的锁
        if (instance == null) &#123;
          instance = new IdGenerator();
        &#125;
      &#125;
    &#125;
    return instance;
  &#125;
  public long getId() &#123; 
    return id.incrementAndGet();
  &#125;
&#125;</code></pre>
<p>静态内部类</p>
<pre><code class="java">public class IdGenerator &#123; 
  private AtomicLong id = new AtomicLong(0);
  private IdGenerator() &#123;&#125;
  private static class SingletonHolder&#123;
    private static final IdGenerator instance = new IdGenerator();
  &#125;

  public static IdGenerator getInstance() &#123;
    return SingletonHolder.instance;
  &#125;

  public long getId() &#123; 
    return id.incrementAndGet();
  &#125;
&#125;</code></pre>
</li>
</ul>
<h5 id="存在问题"><a href="#存在问题" class="headerlink" title="存在问题"></a>存在问题</h5><ol>
<li>单例对OOP特性的支持不友好，通过类的直接使用违反了基于接口而非实现的原则，比如ID生成器，如果未来每个业务需要不同的ID生成器算法，就需要进行重构来支持这个需求变化，所有用到之前静态类的地方都需要更改</li>
<li>单例会隐藏类之间的依赖关系，需要通过阅读代码才能发现</li>
<li>对代码扩展性不友好</li>
<li>对代码可测性不友好 无法mock</li>
</ol>
<p>如果单例并没有后续扩展需求，并且不依赖外部系统，那么设计成单例类是没有问题的，否则尽量不要使用单例类</p>
<h4 id="工厂模式"><a href="#工厂模式" class="headerlink" title="工厂模式"></a>工厂模式</h4><h5 id="简单工厂"><a href="#简单工厂" class="headerlink" title="简单工厂"></a>简单工厂</h5><pre><code class="java">public class RuleConfigParserFactory &#123;
  public static IRuleConfigParser createParser(String configFormat) &#123;
    IRuleConfigParser parser = null;
    if (&quot;json&quot;.equalsIgnoreCase(configFormat)) &#123;
      parser = new JsonRuleConfigParser();
    &#125; else if (&quot;xml&quot;.equalsIgnoreCase(configFormat)) &#123;
      parser = new XmlRuleConfigParser();
    &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(configFormat)) &#123;
      parser = new YamlRuleConfigParser();
    &#125; else if (&quot;properties&quot;.equalsIgnoreCase(configFormat)) &#123;
      parser = new PropertiesRuleConfigParser();
    &#125;
    return parser;
  &#125;
&#125;</code></pre>
<p>通过传入简单参数来返回对象，如果对象是可以复用的，还可以事先使用map缓存起来</p>
<h5 id="工厂方法"><a href="#工厂方法" class="headerlink" title="工厂方法"></a>工厂方法</h5><pre><code class="java">public interface IRuleConfigParserFactory &#123;
  IRuleConfigParser createParser();
&#125;
public class JsonRuleConfigParserFactory implements IRuleConfigParserFactory &#123;
  @Override
  public IRuleConfigParser createParser() &#123;
    return new JsonRuleConfigParser();
  &#125;
&#125;
public class XmlRuleConfigParserFactory implements IRuleConfigParserFactory &#123;
  @Override
  public IRuleConfigParser createParser() &#123;
    return new XmlRuleConfigParser();
  &#125;
&#125;</code></pre>
<pre><code class="java">public class RuleConfigSource &#123;
  public RuleConfig load(String ruleConfigFilePath) &#123;
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    IRuleConfigParserFactory parserFactory = null;
    if (&quot;json&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;
      parserFactory = new JsonRuleConfigParserFactory();
    &#125; else if (&quot;xml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;
      parserFactory = new XmlRuleConfigParserFactory();
    &#125; else if (&quot;yaml&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;
      parserFactory = new YamlRuleConfigParserFactory();
    &#125; else if (&quot;properties&quot;.equalsIgnoreCase(ruleConfigFileExtension)) &#123;
      parserFactory = new PropertiesRuleConfigParserFactory();
    &#125; else &#123;
      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);
    &#125;
    IRuleConfigParser parser = parserFactory.createParser();
    String configText = &quot;&quot;;
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  &#125;</code></pre>
<p>通过使用多态的方式来实现工厂方法，但是工厂对象的创建逻辑又耦合进load函数中了，需要再创建一个简单工厂</p>
<pre><code class="java">public class RuleConfigParserFactoryMap &#123; //工厂的工厂
  private static final Map&lt;String, IRuleConfigParserFactory&gt; cachedFactories = new HashMap&lt;&gt;();
  static &#123;
    cachedFactories.put(&quot;json&quot;, new JsonRuleConfigParserFactory());
    cachedFactories.put(&quot;xml&quot;, new XmlRuleConfigParserFactory());
    cachedFactories.put(&quot;yaml&quot;, new YamlRuleConfigParserFactory());
    cachedFactories.put(&quot;properties&quot;, new PropertiesRuleConfigParserFactory());
  &#125;
  public static IRuleConfigParserFactory getParserFactory(String type) &#123;
    if (type == null || type.isEmpty()) &#123;
      return null;
    &#125;
    IRuleConfigParserFactory parserFactory = cachedFactories.get(type.toLowerCase());
    return parserFactory;
  &#125;
&#125;</code></pre>
<pre><code class="java">public class RuleConfigSource &#123;
  public RuleConfig load(String ruleConfigFilePath) &#123;
    String ruleConfigFileExtension = getFileExtension(ruleConfigFilePath);
    IRuleConfigParserFactory parserFactory = RuleConfigParserFactoryMap.getParserFactory(ruleConfigFileExtension);
    if (parserFactory == null) &#123;
      throw new InvalidRuleConfigException(&quot;Rule config file format is not supported: &quot; + ruleConfigFilePath);
    &#125;
    IRuleConfigParser parser = parserFactory.createParser();
    String configText = &quot;&quot;;
    //从ruleConfigFilePath文件中读取配置文本到configText中
    RuleConfig ruleConfig = parser.parse(configText);
    return ruleConfig;
  &#125;
  private String getFileExtension(String filePath) &#123;
    //...解析文件名获取扩展名，比如rule.json，返回json
    return &quot;json&quot;;
  &#125;
&#125;</code></pre>
<p>当创建逻辑比较复杂的时候才推荐使用工厂方法。</p>
<h5 id="抽象工厂方法"><a href="#抽象工厂方法" class="headerlink" title="抽象工厂方法"></a>抽象工厂方法</h5><p>当类有多个类别时就需要使用到，比如配置类分为基于Rule配置和系统配置。场景比较特殊，不常用</p>
<pre><code class="java">针对规则配置的解析器：基于接口IRuleConfigParser
JsonRuleConfigParser
XmlRuleConfigParser
YamlRuleConfigParser
PropertiesRuleConfigParser
针对系统配置的解析器：基于接口ISystemConfigParser
JsonSystemConfigParser
XmlSystemConfigParser
YamlSystemConfigParser
PropertiesSystemConfigParser</code></pre>
<p>工厂类接口</p>
<pre><code class="java">public interface IConfigParserFactory &#123;
  IRuleConfigParser createRuleParser();
  ISystemConfigParser createSystemParser();
  //此处可以扩展新的parser类型，比如IBizConfigParser
&#125;
</code></pre>
<h4 id="建造者"><a href="#建造者" class="headerlink" title="建造者"></a>建造者</h4><p>当创建一个对象需要配置比较多的属性时，且这些属性可能会存在着一定的关系。</p>
<pre><code class="java">public class ResourcePoolConfig &#123;
  private String name;
  private int maxTotal;
  private int maxIdle;
  private int minIdle;
  private ResourcePoolConfig(Builder builder) &#123;
    this.name = builder.name;
    this.maxTotal = builder.maxTotal;
    this.maxIdle = builder.maxIdle;
    this.minIdle = builder.minIdle;
  &#125;
  //...省略getter方法...
  //我们将Builder类设计成了ResourcePoolConfig的内部类。
  //我们也可以将Builder类设计成独立的非内部类ResourcePoolConfigBuilder。
  public static class Builder &#123;
    private static final int DEFAULT_MAX_TOTAL = 8;
    private static final int DEFAULT_MAX_IDLE = 8;
    private static final int DEFAULT_MIN_IDLE = 0;
    private String name;
    private int maxTotal = DEFAULT_MAX_TOTAL;
    private int maxIdle = DEFAULT_MAX_IDLE;
    private int minIdle = DEFAULT_MIN_IDLE;
    public ResourcePoolConfig build() &#123;
      // 校验逻辑放到这里来做，包括必填项校验、依赖关系校验、约束条件校验等
      if (StringUtils.isBlank(name)) &#123;
        throw new IllegalArgumentException(&quot;...&quot;);
      &#125;
      if (maxIdle &gt; maxTotal) &#123;
        throw new IllegalArgumentException(&quot;...&quot;);
      &#125;
      if (minIdle &gt; maxTotal || minIdle &gt; maxIdle) &#123;
        throw new IllegalArgumentException(&quot;...&quot;);
      &#125;
      return new ResourcePoolConfig(this);
    &#125;
    public Builder setName(String name) &#123;
      if (StringUtils.isBlank(name)) &#123;
        throw new IllegalArgumentException(&quot;...&quot;);
      &#125;
      this.name = name;
      return this;
    &#125;
    public Builder setMaxTotal(int maxTotal) &#123;
      if (maxTotal &lt;= 0) &#123;
        throw new IllegalArgumentException(&quot;...&quot;);
      &#125;
      this.maxTotal = maxTotal;
      return this;
    &#125;
    public Builder setMaxIdle(int maxIdle) &#123;
      if (maxIdle &lt; 0) &#123;
        throw new IllegalArgumentException(&quot;...&quot;);
      &#125;
      this.maxIdle = maxIdle;
      return this;
    &#125;
    public Builder setMinIdle(int minIdle) &#123;
      if (minIdle &lt; 0) &#123;
        throw new IllegalArgumentException(&quot;...&quot;);
      &#125;
      this.minIdle = minIdle;
      return this;
    &#125;
  &#125;
&#125;
// 这段代码会抛出IllegalArgumentException，因为minIdle&gt;maxIdle
ResourcePoolConfig config = new ResourcePoolConfig.Builder()
        .setName(&quot;dbconnectionpool&quot;)
        .setMaxTotal(16)
        .setMaxIdle(10)
        .setMinIdle(12)
        .build();</code></pre>
<h4 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h4><p>如果对象的创建成本比较大，而同一个类的不同对象之间差别不大（大部分字段都相同），在这种情况下，我们可以利用对已有对象（原型）进行复制（或者叫拷贝）的方式，来创建新对象，以达到节省创建时间的目的。这种基于原型来创建对象的方式就叫作原型设计模式，简称原型模式。</p>
<p>原型模式有两种实现方法，深拷贝和浅拷贝。浅拷贝只会复制对象中基本数据类型数据和引用对象的内存地址，不会递归地复制引用对象，以及引用对象的引用对象……而深拷贝得到的是一份完完全全独立的对象。</p>
]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
  </entry>
  <entry>
    <title>design principal</title>
    <url>/2022/11/26/design%20pattern/design%20principal/</url>
    <content><![CDATA[<h4 id="SOLID原则"><a href="#SOLID原则" class="headerlink" title="SOLID原则"></a>SOLID原则</h4><p>SOLID原则是由5个原则的首字母组成的原则，由Robert C.Martin提出来的五大原则。 <strong>SOLID</strong> is a <a href="https://en.wikipedia.org/wiki/Mnemonic">mnemonic</a> <a href="https://en.wikipedia.org/wiki/Acronym">acronym</a> for five design principles intended to make <a href="https://en.wikipedia.org/wiki/Object-oriented">object-oriented</a> designs more understandable, flexible, and <a href="https://en.wikipedia.org/wiki/Software_maintenance">maintainable</a>. </p>
<ol>
<li><p>The <strong>S</strong>ingle Responsibility Principle  SRP单一职责原则</p>
<blockquote>
<p>A module should be responsible to one, and only one, actor</p>
</blockquote>
<p>一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的 类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护 性。</p>
<p>一个类是否单一要看具体的业务需求，随着业务的发展当类变得臃肿的就要考虑进行拆分，设计更小粒度的类。</p>
<p>下列情况可能会说明类职责不够单一</p>
<ul>
<li>类中的代码行数、函数或者属性过多；</li>
<li> 类依赖的其他类过多，或者依赖类的其他类过多；</li>
<li> 私有方法过多； 比较难给类起一个合适的名字； </li>
<li>类中大量的方法都是集中操作类中的某几个属性。</li>
</ul>
</li>
<li><p>The <strong>O</strong>pen-Closed Principle  OCP开闭原则</p>
<blockquote>
<p>Software entities … should be open for extension, but closed for modification</p>
</blockquote>
<blockquote>
<p>A module will be said to be open if it is still available for extension. For example, it should be possible to add fields to the data structures it contains, or new elements to the set of functions it performs.</p>
<p>A module will be said to be closed if [it] is available for use by other modules. This assumes that the module has been given a well-defined, stable description (the interface in the sense of information hiding).</p>
</blockquote>
<p>只要新增的功能涉及修改的地方没有破坏原有的代码的功能运行、功能测试，那它就是符合OCP的</p>
<blockquote>
<p>对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是 为了让系统更有弹性！</p>
</blockquote>
</li>
<li><p>The <strong>L</strong>iskov Substitution Principle LSP里氏替换原则</p>
<blockquote>
<p>Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.</p>
</blockquote>
<p>LSP和多态有点像，但侧重点不一样。多态着重的是父类引用可以使用子类对象，LSP也是通过多态这一特性来使用子对象。但它强调的是功能上的一致，比如父类的function中没有定义要抛出的异常，子类实现此function时如果抛出了未定义的异常，那就是违背LSP</p>
<p>违背LSP的一些例子</p>
<ul>
<li>子类违背父类声明要实现的功能</li>
<li>子类违背父类对输入、输出、异常的约定</li>
<li>子类违背父类注释中所罗列的任何特殊说明</li>
</ul>
</li>
<li><p>The <strong>I</strong>nterface Segregation Principle ISP接口隔离原则</p>
<blockquote>
<p>Clients should not be forced to depend upon interfaces that they do not use.</p>
</blockquote>
<blockquote>
<p>ISP can be seen as similar to SRP for interfaces; but it is more than that. ISP generalizes into: “Don’t depend on more than you need.” SRP generalizes to “Gather together things that change for the same reasons and at the same times.”</p>
<p>Imagine a stack class with both push and pop. Imagine a client that only pushes. If that client depends upon the stack interface, it depends upon pop, which it does not need. SRP would not separate push from pop; ISP would.</p>
</blockquote>
<p>ISP和RSP有点像，SRP侧重于module，职责是否保持单一化。ISP侧重调用者是否需要接口所有功能。SRP可以说是ISP的冗余。</p>
</li>
<li><p>The <strong>D</strong>ependency Inversion Principle  DIP依赖倒置原则</p>
<blockquote>
<ol>
<li>High-level modules should not import anything from low-level modules. Both should depend on abstractions (e.g., interfaces).</li>
<li>Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.</li>
</ol>
</blockquote>
<p>上层服务应该依赖于底层接口，且底层接口不应该依赖于具体的实现（即通过构造器之类的方式注入到上层服务中）</p>
</li>
</ol>
<h4 id="KISS"><a href="#KISS" class="headerlink" title="KISS"></a>KISS</h4><blockquote>
<p>keep it simple and stupid</p>
</blockquote>
<p>写的功能代码尽可能的简单，不要用一些增加理解困难度的trick</p>
<ul>
<li>不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。</li>
<li>不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。</li>
<li>不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。</li>
</ul>
<h4 id="YAGNI"><a href="#YAGNI" class="headerlink" title="YAGNI"></a>YAGNI</h4><blockquote>
<p>You aren’t gonna need it</p>
</blockquote>
<p>不要过度设计，当然接口扩展这些是可以做的</p>
<h4 id="DRY"><a href="#DRY" class="headerlink" title="DRY"></a>DRY</h4><blockquote>
<p>Don’t repeat yourself</p>
</blockquote>
<p>不要写重复代码</p>
<p>有三种典型情况</p>
<ul>
<li><p>逻辑重复</p>
<p>若语义不重复不违反DRY</p>
</li>
<li><p>功能语义重复</p>
<p>违反DRY</p>
</li>
<li><p>代码执行重复</p>
<p>在执行中多次执行相同代码（函数）违反DRY</p>
</li>
</ul>
<p>是否违法DRY，主要看语义</p>
<h4 id="LOD"><a href="#LOD" class="headerlink" title="LOD"></a>LOD</h4><blockquote>
<p><strong>Law of Demeter</strong> or <strong>principle of least knowledge</strong></p>
<ul>
<li>Each unit should have only limited knowledge about other units: only units “closely” related to the current unit.</li>
<li>Each unit should only talk to its friends; don’t talk to strangers.</li>
<li>Only talk to your immediate friends.</li>
</ul>
</blockquote>
<p>不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。</p>
]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
  </entry>
  <entry>
    <title>refactoring</title>
    <url>/2022/12/11/design%20pattern/refactoring/</url>
    <content><![CDATA[<h4 id="重构规模"><a href="#重构规模" class="headerlink" title="重构规模"></a>重构规模</h4><h5 id="大规模重构"><a href="#大规模重构" class="headerlink" title="大规模重构"></a>大规模重构</h5><ul>
<li>重构手段有：分层、模块化、解耦、抽象可复用组件</li>
<li>改动大，易引入bug，重构时需要有完善的计划</li>
</ul>
<h5 id="小规模重构"><a href="#小规模重构" class="headerlink" title="小规模重构"></a>小规模重构</h5><ul>
<li>主要指代码细节的重构，针对类，函数，变量的代码级别重构。一般根据编程规范作为指导即可</li>
<li>改动小且比较集中，风险小。如果觉得需要重构就可以直接着手</li>
</ul>
<h4 id="单元测试"><a href="#单元测试" class="headerlink" title="单元测试"></a>单元测试</h4><ol>
<li>它是保证代码重构时不出错的有效保证</li>
<li>编写单元测试能帮你发现设计上的问题，如果一段代码很难去编写单元测试，往往会意味着代码的设计不够合理，比如说使用了静态方法、没有依赖注入等等，进而促使你去重构代码</li>
<li>单元测试可以帮助你快速熟悉代码</li>
<li>单元测试是TDD可落地执行的改进方案</li>
</ol>
<h5 id="常见的anti-patterns"><a href="#常见的anti-patterns" class="headerlink" title="常见的anti-patterns"></a>常见的anti-patterns</h5><ol>
<li>未决行为（代码输出具有随机性）</li>
<li>全局变量（滥用全局变量会使测试变得困难，每个测试用例可能都要重置全局变量）</li>
<li>静态方法（静态方法比较难mock，比如依赖外部资源的静态函数）</li>
<li>复杂继承（如果一个父类需要mock某个依赖对象才能进行单元测试，那么所有子类在编写单元测试的时候都要去mock这个对象）</li>
<li>高耦合代码（一个类依赖很多外部对象，可能也需要mock这些外部对象，这本身设计不合理）</li>
</ol>
<h4 id="解耦技巧"><a href="#解耦技巧" class="headerlink" title="解耦技巧"></a>解耦技巧</h4><ol>
<li><p>封装与抽象</p>
<p>当功能改动时，上层依赖不需要改动</p>
</li>
<li><p>引用中间层</p>
<p>通过中间层来简化依赖关系</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20221211234625.png" alt="image-20221211234618738" loading="lazy"></p>
</li>
<li><p>模块化</p>
<p>构建复杂系统的主要手段，相关人员只要专注于自己负责的模块即可</p>
</li>
<li><p>利用设计思想和原则</p>
<ul>
<li>单一职责原则</li>
<li>基于接口而非实现编程</li>
<li>依赖注入</li>
<li>多用组合少用继承</li>
<li>迪米特法则</li>
</ul>
</li>
</ol>
<h4 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h4><ol>
<li><p>命名</p>
<ul>
<li>命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。作用域小的变量（比如临时变量），可以适当地选择短一些的命名方式。除此之外，命名中也可以使用一些耳熟能详的缩写。</li>
<li>我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。</li>
<li>命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，不要用些反直觉的命名。</li>
<li>接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。</li>
</ul>
</li>
<li><p>注释</p>
<ul>
<li>注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。</li>
<li>注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。</li>
</ul>
</li>
<li><p>函数的代码不要超过一屏幕大小，类比较难确定</p>
</li>
<li><p>一行代码不要超过IDE显示宽度</p>
</li>
<li><p>善用空行分割单元块</p>
</li>
<li><p>把代码分割成更小的单元块</p>
</li>
<li><p>函数参数不要过多，大于五个就有点多</p>
<ul>
<li>考虑函数职责是否单一，能否拆成多个函数的方式来减少参数</li>
<li>封装成对象</li>
</ul>
</li>
<li><p>勿用函数参数来控制逻辑，尽量拆成多个函数</p>
</li>
<li><p>函数设计要职责单一</p>
</li>
<li><p>移除过深嵌套层次</p>
<ul>
<li>去掉多余if/else语句</li>
<li>使用关键字continue，break，return提前退出嵌套</li>
<li>调整执行顺序，判断逻辑（如判空）放在前面</li>
<li>将部分嵌套逻辑封装成函数</li>
</ul>
</li>
<li><p>学会使用解释性变量</p>
<ul>
<li><p>常量代替魔法数字</p>
</li>
<li><p>使用解释性变量来解释负责表达式</p>
<pre><code class="java">boolean isSummer = date.after(SUMMER_START)&amp;&amp;date.before(SUMMER_END);</code></pre>
</li>
</ul>
</li>
</ol>
]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
  </entry>
  <entry>
    <title>structural patterns</title>
    <url>/2023/01/03/design%20pattern/structural%20patterns/</url>
    <content><![CDATA[<h4 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h4><p>在不改变原始类功能代码下，<strong>通过代理类来增加附加功能</strong>，具体可以通过实现相同的接口/继承原始类来实现。</p>
<p>出现的意义就是为了避免功能耦合，比如业务代码和非业务（日志等）代码应剥离。</p>
<pre><code class="java">public interface IUserController &#123;
  UserVo login(String telephone, String password);
  UserVo register(String telephone, String password);
&#125;
//业务接口
public class UserController implements IUserController &#123;
  //...省略其他属性和方法...
  @Override
  public UserVo login(String telephone, String password) &#123;
    //...省略login逻辑...
    //...返回UserVo数据...
  &#125;
&#125;
//业务代理接口
public class UserControllerProxy implements IUserController &#123;
    //接口统计
  private MetricsCollector metricsCollector;
  private UserController userController;
  public UserControllerProxy(UserController userController) &#123;
    this.userController = userController;
    this.metricsCollector = new MetricsCollector();
  &#125;
  @Override
  public UserVo login(String telephone, String password) &#123;
    long startTimestamp = System.currentTimeMillis();
    // 委托
    UserVo userVo = userController.login(telephone, password);
    long endTimeStamp = System.currentTimeMillis();
    long responseTime = endTimeStamp - startTimestamp;
    RequestInfo requestInfo = new RequestInfo(&quot;login&quot;, responseTime, startTimestamp);
    metricsCollector.recordRequest(requestInfo);
    return userVo;
  &#125;</code></pre>
<p>对于非业务代码，比如接口调用记录这些功能，由于接口比较多，更多的是使用<strong>动态代理</strong></p>
<h4 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h4><p><strong>让两个/多个维度的独立变化</strong>，避免类指数式增加。</p>
<p>比如下图，如果颜色和形状增加就会造成类的快速增加</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230103234923.png" alt="image-20230103234916879" loading="lazy"></p>
<p>桥接模式结构如下图</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230103235251.png" alt="image-20230103235251475" loading="lazy"></p>
<p>总的就是让一个维度变化通过接口的方式注入到主体类中，所有的行为都依赖具体的桥接类</p>
<pre><code class="java">public interface MsgSender &#123;
  void send(String message);
&#125;
public class TelephoneMsgSender implements MsgSender &#123;
  private List&lt;String&gt; telephones;
  public TelephoneMsgSender(List&lt;String&gt; telephones) &#123;
    this.telephones = telephones;
  &#125;
  @Override
  public void send(String message) &#123;
    //...
  &#125;
&#125;
public class EmailMsgSender implements MsgSender &#123;
  // 与TelephoneMsgSender代码结构类似，所以省略...
&#125;
public class WechatMsgSender implements MsgSender &#123;
  // 与TelephoneMsgSender代码结构类似，所以省略...
&#125;
public abstract class Notification &#123;
  protected MsgSender msgSender;
  public Notification(MsgSender msgSender) &#123;
    this.msgSender = msgSender;
  &#125;
  public abstract void notify(String message);
&#125;

public class SevereNotification extends Notification &#123;
  public SevereNotification(MsgSender msgSender) &#123;
    super(msgSender);
  &#125;
  @Override
  public void notify(String message) &#123;
    msgSender.send(message);
  &#125;
&#125;
public class UrgencyNotification extends Notification &#123;
  // 与SevereNotification代码结构类似，所以省略...
&#125;
public class NormalNotification extends Notification &#123;
  // 与SevereNotification代码结构类似，所以省略...
&#125;
public class TrivialNotification extends Notification &#123;
  // 与SevereNotification代码结构类似，所以省略...
&#125;
//这样就可以进行任意组合</code></pre>
<h4 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h4><p><strong>使用组合关系替代继承关系来对功能进行增强</strong>，java 的IO流就是使用了装饰器模式</p>
<pre><code class="java">InputStream in = new FileInputStream(&quot;/user/wangzheng/test.txt&quot;);
InputStream bin = new BufferedInputStream(in);
DataInputStream din = new DataInputStream(bin);</code></pre>
<p>上述代码din是一个带有缓存的基本数据读取流，将增强的功能拆分开来进行任意组合从而避免类爆炸式增长。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230107175908.png" alt="image-20230107175900955" loading="lazy"></p>
<h4 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h4><p>将不兼容的接口转为可兼容，通过定义一个新的接口，然后实现接口并继承或组合不兼容的类来实现兼容</p>
<ul>
<li><p>类适配器（继承）</p>
<pre><code class="java">// 类适配器: 基于继承
public interface ITarget &#123;
  void f1();
  void f2();
  void fc();
&#125;
public class Adaptee &#123;
  public void fa() &#123; //... &#125;
  public void fb() &#123; //... &#125;
  public void fc() &#123; //... &#125;
&#125;
public class Adaptor extends Adaptee implements ITarget &#123;
  public void f1() &#123;
    super.fa();
  &#125;

  public void f2() &#123;
    //...重新实现f2()...
  &#125;

  // 这里fc()不需要实现，直接继承自Adaptee，这是跟对象适配器最大的不同点
&#125;</code></pre>
</li>
</ul>
<ul>
<li><p>对象适配器（组合）</p>
<pre><code class="java">public class Adaptor implements ITarget &#123;
  private Adaptee adaptee;

  public Adaptor(Adaptee adaptee) &#123;
    this.adaptee = adaptee;
  &#125;

  public void f1() &#123;
    adaptee.fa(); //委托给Adaptee
  &#125;

  public void f2() &#123;
    //...重新实现f2()...
  &#125;

  public void fc() &#123;
    adaptee.fc();
  &#125;
&#125;</code></pre>
<ul>
<li><p>如果 Adaptee 接口并不多，那两种实现方式都可以。</p>
</li>
<li><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都相同，那我们推荐使用类适配器，因为 Adaptor 复用父类 Adaptee 的接口，比起对象适配器的实现方式，Adaptor 的代码量要少一些。</p>
</li>
<li><p>如果 Adaptee 接口很多，而且 Adaptee 和 ITarget 接口定义大部分都不相同，那我们推荐使用对象适配器，因为组合结构相对于继承更加灵活。</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230107232252.png" alt="image-20230107232252473" loading="lazy"></p>
<h4 id="门面模式"><a href="#门面模式" class="headerlink" title="门面模式"></a>门面模式</h4><p>将多个接口重新包裹成一个接口，让调用方更方便使用。</p>
<h4 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h4><p>当一组对象需要组成树形结构时，使用此模式。比如部门，文件系统就是一个树形结构。</p>
<pre><code class="java">public abstract class FileSystemNode &#123;
  protected String path;
  public FileSystemNode(String path) &#123;
    this.path = path;
  &#125;
  public abstract int countNumOfFiles();
  public abstract long countSizeOfFiles();
  public String getPath() &#123;
    return path;
  &#125;
&#125;
public class File extends FileSystemNode &#123;
  public File(String path) &#123;
    super(path);
  &#125;
  @Override
  public int countNumOfFiles() &#123;
    return 1;
  &#125;
  @Override
  public long countSizeOfFiles() &#123;
    java.io.File file = new java.io.File(path);
    if (!file.exists()) return 0;
    return file.length();
  &#125;
&#125;
public class Directory extends FileSystemNode &#123;
  private List&lt;FileSystemNode&gt; subNodes = new ArrayList&lt;&gt;();
  public Directory(String path) &#123;
    super(path);
  &#125;
  @Override
  public int countNumOfFiles() &#123;
    int numOfFiles = 0;
    for (FileSystemNode fileOrDir : subNodes) &#123;
      numOfFiles += fileOrDir.countNumOfFiles();
    &#125;
    return numOfFiles;
  &#125;
  @Override
  public long countSizeOfFiles() &#123;
    long sizeofFiles = 0;
    for (FileSystemNode fileOrDir : subNodes) &#123;
      sizeofFiles += fileOrDir.countSizeOfFiles();
    &#125;
    return sizeofFiles;
  &#125;
  public void addSubNode(FileSystemNode fileOrDir) &#123;
    subNodes.add(fileOrDir);
  &#125;
  public void removeSubNode(FileSystemNode fileOrDir) &#123;
    int size = subNodes.size();
    int i = 0;
    for (; i &lt; size; ++i) &#123;
      if (subNodes.get(i).getPath().equalsIgnoreCase(fileOrDir.getPath())) &#123;
        break;
      &#125;
    &#125;
    if (i &lt; size) &#123;
      subNodes.remove(i);
    &#125;
  &#125;
&#125;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230107235138.png" alt="image-20230107235138772" loading="lazy"></p>
<h4 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h4><p>复用对象，从而节约内存。复用的对象都是不可变对象，比如游戏中的象棋，一个棋盘中变化的只是棋子的位置，其他信息是不变，将这些不变信息定义为一个元对象来被所有棋盘引用，从而达到节约内存的目的。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230108003621.png" alt="image-20230108003621007" loading="lazy"></p>
]]></content>
      <categories>
        <category>design_pattern</category>
      </categories>
  </entry>
  <entry>
    <title>git基本知识</title>
    <url>/2020/11/23/git/git%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<h2 id="git使用"><a href="#git使用" class="headerlink" title="git使用"></a>git使用</h2><h3 id="什么是版本控制"><a href="#什么是版本控制" class="headerlink" title="什么是版本控制"></a>什么是版本控制</h3><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。</p>
<ul>
<li>实现跨区域多人协同开发</li>
<li>追踪和记载一个或者多个文件的历史记录</li>
<li>组织和保护你的源代码和文档</li>
<li>统计工作量</li>
<li>并行开发、提高开发效率</li>
<li>跟踪记录整个软件的开发过程</li>
<li>减轻开发人员的负担，节省时间，同时降低人为错误</li>
</ul>
<p>简单说就是用于管理多人协同开发项目的技术。</p>
<p>没有进行版本控制或者版本控制本身缺乏正确的流程管理，在软件开发过程中将会引入很多问题，如软件代码的一致性、软件内容的冗余、软件过程的事物性、软件开发过程中的并发性、软件源代码的安全性，以及软件的整合等问题。</p>
<p>无论是工作还是学习，或者是自己做笔记，都经历过这样一个阶段！我们就迫切需要一个版本控制工具！</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170421.jpg" loading="lazy"></p>
<p>多人开发就必须要使用版本控制！</p>
<h3 id="常见的版本控制工具"><a href="#常见的版本控制工具" class="headerlink" title="常见的版本控制工具"></a>常见的版本控制工具</h3><p>我们学习的东西，一定是当下最流行的！</p>
<p>主流的版本控制器有如下这些：</p>
<ul>
<li><strong>Git</strong></li>
<li><strong>SVN</strong>（Subversion）</li>
<li><strong>CVS</strong>（Concurrent Versions System）</li>
<li><strong>VSS</strong>（Micorosoft Visual SourceSafe）</li>
<li><strong>TFS</strong>（Team Foundation Server）</li>
<li>Visual Studio Online</li>
</ul>
<p>版本控制产品非常的多（Perforce、Rational ClearCase、RCS（GNU Revision Control System）、Serena Dimention、SVK、BitKeeper、Monotone、Bazaar、Mercurial、SourceGear Vault），现在影响力最大且使用最广泛的是Git与SVN</p>
<h3 id="版本控制分类"><a href="#版本控制分类" class="headerlink" title="版本控制分类"></a>版本控制分类</h3><p><strong>1、本地版本控制</strong></p>
<p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件，适合个人用，如RCS。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170501" loading="lazy"></p>
<p><strong>2、集中版本控制  SVN</strong></p>
<p>所有的版本数据都保存在服务器上，协同开发者从服务器上同步更新或上传自己的修改</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170523" loading="lazy"></p>
<p>所有的版本数据都存在服务器上，用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。而且，所有数据都保存在单一的服务器上，有很大的风险这个服务器会损坏，这样就会丢失所有的数据，当然可以定期备份。代表产品：SVN、CVS、VSS</p>
<p><strong>3、分布式版本控制     Git</strong></p>
<p>每个人都拥有全部的代码！安全隐患！</p>
<p>所有版本信息仓库全部同步到本地的每个用户，这样就可以在本地查看所有版本历史，可以离线在本地提交，只需在连网时push到相应的服务器或其他用户那里。由于每个用户那里保存的都是所有的版本数据，只要有一个用户的设备没有问题就可以恢复所有的数据，但这增加了本地存储空间的占用。</p>
<p>不会因为服务器损坏或者网络问题，造成不能工作的情况！</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170528" loading="lazy"></p>
<h3 id="Git与SVN的主要区别"><a href="#Git与SVN的主要区别" class="headerlink" title="Git与SVN的主要区别"></a>Git与SVN的主要区别</h3><p>SVN是集中式版本控制系统，版本库是集中放在中央服务器的，而工作的时候，用的都是自己的电脑，所以首先要从中央服务器得到最新的版本，然后工作，完成工作后，需要把自己做完的活推送到中央服务器。集中式版本控制系统是必须联网才能工作，对网络带宽要求较高。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170532" loading="lazy"></p>
<p>Git是分布式版本控制系统，没有中央服务器，每个人的电脑就是一个完整的版本库，工作的时候不需要联网了，因为版本都在自己电脑上。协同的方法是这样的：比如说自己在电脑上改了文件A，其他人也在电脑上改了文件A，这时，你们两之间只需把各自的修改推送给对方，就可以互相看到对方的修改了。Git可以直接看到更新了哪些代码和文件！</p>
<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>
<h3 id="聊聊Git的历史"><a href="#聊聊Git的历史" class="headerlink" title="聊聊Git的历史"></a>聊聊Git的历史</h3><p>同生活中的许多伟大事物一样，Git 诞生于一个极富纷争大举创新的年代。</p>
<p>Linux 内核开源项目有着为数众广的参与者。绝大多数的 Linux 内核维护工作都花在了提交补丁和保存归档的繁琐事务上(1991－2002年间)。到 2002 年，整个项目组开始启用一个专有的分布式版本控制系统 BitKeeper 来管理和维护代码。</p>
<p>Linux社区中存在很多的大佬！破解研究 BitKeeper ！</p>
<p>到了 2005 年，开发 BitKeeper 的商业公司同 Linux 内核开源社区的合作关系结束，他们收回了 Linux 内核社区免费使用 BitKeeper 的权力。这就迫使 Linux 开源社区(特别是 Linux 的缔造者 Linus Torvalds)基于使用 BitKeeper 时的经验教训，开发出自己的版本系统。（2周左右！） 也就是后来的 Git！</p>
<p><strong>Git是目前世界上最先进的分布式版本控制系统。</strong></p>
<p>Git是免费、开源的，最初Git是为辅助 Linux 内核开发的，来替代 BitKeeper！</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170541" loading="lazy"></p>
<p>Linux和Git之父李纳斯·托沃兹（Linus Benedic Torvalds）1969、芬兰</p>
<p>Git环境配置</p>
<h3 id="软件下载"><a href="#软件下载" class="headerlink" title="软件下载"></a>软件下载</h3><p>打开 [git官网] <a href="https://git-scm.com/%EF%BC%8C%E4%B8%8B%E8%BD%BDgit%E5%AF%B9%E5%BA%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%88%E6%9C%AC%E3%80%82">https://git-scm.com/，下载git对应操作系统的版本。</a></p>
<p>所有东西下载慢的话就可以去找镜像！</p>
<p>官网下载太慢，我们可以使用淘宝镜像下载：<a href="http://npm.taobao.org/mirrors/git-for-windows/">http://npm.taobao.org/mirrors/git-for-windows/</a></p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170547" loading="lazy"></p>
<p>下载对应的版本即可安装！</p>
<p>安装：无脑下一步即可！安装完毕就可以使用了！</p>
<h3 id="启动Git"><a href="#启动Git" class="headerlink" title="启动Git"></a>启动Git</h3><p>安装成功后在开始菜单中会有Git项，菜单下有3个程序：任意文件夹下右键也可以看到对应的程序！</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170551" loading="lazy"></p>
<p><strong>Git Bash：</strong>Unix与Linux风格的命令行，使用最多，推荐最多</p>
<p><strong>Git CMD：</strong>Windows风格的命令行</p>
<p><strong>Git GUI</strong>：图形界面的Git，不建议初学者使用，尽量先熟悉常用命令</p>
<h3 id="常用的Linux命令"><a href="#常用的Linux命令" class="headerlink" title="常用的Linux命令"></a>常用的Linux命令</h3><p>平时一定要多使用这些基础的命令！</p>
<p>1）、cd : 改变目录。</p>
<p>2）、cd . . 回退到上一个目录，直接cd进入默认目录</p>
<p>3）、pwd : 显示当前所在的目录路径。</p>
<p>4）、ls(ll):  都是列出当前目录中的所有文件，只不过ll(两个ll)列出的内容更为详细。</p>
<p>5）、touch : 新建一个文件 如 touch index.js 就会在当前目录下新建一个index.js文件。</p>
<p>6）、rm:  删除一个文件, rm index.js 就会把index.js文件删除。</p>
<p>7）、mkdir:  新建一个目录,就是新建一个文件夹。</p>
<p>8）、rm -r :  删除一个文件夹, rm -r src 删除src目录</p>
<pre><code>rm -rf / 切勿在Linux中尝试！删除电脑中全部文件！</code></pre>
<p>9）、mv 移动文件, mv index.html src index.html 是我们要移动的文件, src 是目标文件夹,当然, 这样写,必须保证文件和目标文件夹在同一目录下。</p>
<p>10）、reset 重新初始化终端/清屏。</p>
<p>11）、clear 清屏。</p>
<p>12）、history 查看命令历史。</p>
<p>13）、help 帮助。</p>
<p>14）、exit 退出。</p>
<p>15）、#表示注释</p>
<h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p>所有的配置文件，其实都保存在本地！</p>
<p>查看配置 git config -l</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170557" loading="lazy"></p>
<p>查看不同级别的配置文件：</p>
<pre><code>#查看系统  
config git config --system --list　
#查看当前用户（global）配置 
git config --global  --list</code></pre>
<p><strong>Git相关的配置文件：</strong></p>
<p>1）、Git\etc\gitconfig  ：Git 安装目录下的 gitconfig   –system 系统级</p>
<p>2）、C:\Users\Administrator\ .gitconfig   只适用于当前登录用户的配置  –global 全局</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170601" loading="lazy"></p>
<p>这里可以直接编辑配置文件，通过命令设置后会响应到这里。</p>
<h3 id="设置用户名与邮箱（用户标识，必要）"><a href="#设置用户名与邮箱（用户标识，必要）" class="headerlink" title="设置用户名与邮箱（用户标识，必要）"></a>设置用户名与邮箱（用户标识，必要）</h3><p>当你安装Git后首先要做的事情是设置你的用户名称和e-mail地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p>
<pre><code>#名称
git config --global user.name &quot;kuangshen&quot;  
#邮箱
git config --global user.email 24736743@qq.com   </code></pre>
<p>只需要做一次这个设置，如果你传递了–global 选项，因为Git将总是会使用该信息来处理你在系统中所做的一切操作。如果你希望在一个特定的项目中使用不同的名称或e-mail地址，你可以在该项目中运行该命令而不要–global选项。总之–global为全局配置，不加为某个项目的特定配置。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170605" loading="lazy"></p>
<p>Git基本理论（重要）</p>
<h3 id="三个区域"><a href="#三个区域" class="headerlink" title="三个区域"></a>三个区域</h3><p>Git本地有三个工作区域：工作目录（Working Directory）、暂存区(Stage/Index)、资源库(Repository或Git Directory)。如果在加上远程的git仓库(Remote Directory)就可以分为四个工作区域。文件在这四个区域之间的转换关系如下：</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170609" loading="lazy"></p>
<ul>
<li>Workspace：工作区，就是你平时存放项目代码的地方</li>
<li>Index / Stage：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息</li>
<li>Repository：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据。其中HEAD指向最新放入仓库的版本</li>
<li>Remote：远程仓库，托管代码的服务器，可以简单的认为是你项目组中的一台电脑用于远程数据交换</li>
</ul>
<p>本地的三个区域确切的说应该是git仓库中HEAD指向的版本：</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170613" loading="lazy"></p>
<ul>
<li>Directory：使用Git管理的一个目录，也就是一个仓库，包含我们的工作空间和Git的管理空间。</li>
<li>WorkSpace：需要通过Git进行版本控制的目录和文件，这些目录和文件组成了工作空间。</li>
<li>.git：存放Git管理信息的目录，初始化仓库的时候自动创建。</li>
<li>Index/Stage：暂存区，或者叫待提交更新区，在提交进入repo之前，我们可以把所有的更新放在暂存区。</li>
<li>Local Repo：本地仓库，一个存放在本地的版本库；HEAD会只是当前的开发分支（branch）。</li>
<li>Stash：隐藏，是一个工作状态保存栈，用于保存/恢复WorkSpace中的临时状态。</li>
</ul>
<h3 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h3><p>git的工作流程一般是这样的：</p>
<p>１、在工作目录中添加、修改文件；</p>
<p>２、将需要进行版本管理的文件放入暂存区域；</p>
<p>３、将暂存区域的文件提交到git仓库。</p>
<p>因此，git管理的文件有三种状态：已修改（modified）,已暂存（staged）,已提交(committed)</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170617" loading="lazy"></p>
<h3 id="创建工作目录与常用指令"><a href="#创建工作目录与常用指令" class="headerlink" title="创建工作目录与常用指令"></a>创建工作目录与常用指令</h3><p>工作目录（WorkSpace)一般就是你希望Git帮助你管理的文件夹，可以是你项目的目录，也可以是一个空目录，建议不要有中文。</p>
<p>日常使用只要记住下图6个命令：</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123170620" loading="lazy"></p>
<h4 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h4><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>
<ul>
<li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为Staged.</li>
<li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用<code>git rm</code>移出版本库, 则成为Untracked文件</li>
<li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个<code>git checkout</code>即从库中取出文件, 覆盖当前修改 !</li>
<li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li>
</ul>
<h3 id="git本地仓库实操"><a href="#git本地仓库实操" class="headerlink" title="git本地仓库实操"></a>git本地仓库实操</h3><p>创建本地仓库的方法有两种：一种是创建全新的仓库，另一种是克隆远程仓库。</p>
<ol>
<li><p>创建全新的仓库，需要用GIT管理的项目的根目录执行：</p>
<pre><code># 在当前目录新建一个Git代码库
$ git init</code></pre>
</li>
<li><p>执行后可以看到，仅仅在项目目录多出了一个.git目录，关于版本等的所有信息都在这个目录里面。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123172656.png" alt="image-20201123172656301" loading="lazy"></p>
</li>
<li><p>添加hello.txt并同步到库中</p>
<pre><code>#查看指定文件状态
git status [filename]
#查看所有文件状态
git status
# 添加所有文件到暂存区
git add .
# 提交暂存区中的内容到本地仓库 -m 提交信息
git commit -m &quot;消息内容&quot;   </code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123173654.png" alt="image-20201123173654116" loading="lazy"></p>
</li>
</ol>
<h3 id="克隆远程仓库"><a href="#克隆远程仓库" class="headerlink" title="克隆远程仓库"></a>克隆远程仓库</h3><p>1、另一种方式是克隆远程目录，由于是将远程服务器上的仓库完全镜像一份至本地！</p>
<pre><code># 克隆一个项目和它的整个代码历史(版本信息)
$ git clone [url]  # https://gitee.com/kuangstudy/openclass.git</code></pre>
<h3 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h3><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p>
<p>在主目录下建立”.gitignore”文件，此文件有如下规则：</p>
<ol>
<li>忽略文件中的空行或以井号（#）开始的行将会被忽略。</li>
<li>/代表.gitignore的当前目录</li>
<li>可以使用Linux通配符。例如：星号（*）代表任意多个字符，问号（？）代表一个字符，方括号（[abc]）代表可选字符范围，大括号（{string1,string2,…}）代表可选的字符串等。</li>
<li>如果名称的最前面有一个感叹号（!），表示例外规则，将不被忽略。</li>
<li>如果文件已经提交过了，那么规则不会起作用</li>
</ol>
<pre><code class="ii">#为注释
*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！
!lib.txt     #lib.txt除外
#两个都是忽略文件及子目录
/temp
temp/
#忽略项目中多个模块的target文件夹
/*/target</code></pre>
<ul>
<li><p>svn忽略文件设置</p>
<p>通过tortoiseSVN的properties来配置忽略文件，简便的可以在选中单个文件/文件夹后然后右键添加忽略文件</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210511234948.png" alt="image-20210511234452677" loading="lazy"></p>
<p>忽略文件的规则：<strong>根目录为当前文件夹</strong></p>
<p>比如想忽略temp文件夹及其子文件夹下的东西，那么就在temp当前目录右键添加忽略</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210511235050.png" alt="image-20210511235044767" loading="lazy"></p>
</li>
</ul>
<p>  在当前文件下点开tortoiseSVN的properties可以看到设置的忽略属性，因此也可以自己手动设置</p>
<p>  <img src="https://raw.githubusercontent.com/soda1/img/main/20210511235347.png" alt="image-20210511235326460" loading="lazy"></p>
<h3 id="配置远程仓库"><a href="#配置远程仓库" class="headerlink" title="配置远程仓库"></a>配置远程仓库</h3><ol>
<li>设置本机绑定SSH公钥，实现免密码登录！（免密码登录，这一步挺重要的，码云是远程仓库，我们是平时工作在本地仓库！)</li>
</ol>
<pre><code># 进入 C:\Users\Administrator\.ssh 目录
# 生成公钥ssh-keygen</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123171211.png" alt="image-20201123171211665" loading="lazy"></p>
<ol start="2">
<li>将公钥信息public key 添加到码云账户中即可！</li>
</ol>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123171410.png" alt="image-20201123171410714" loading="lazy"></p>
<ol start="3">
<li>创建一个自己的仓库,然后使用git clone克隆到本地就可以使用命令上传到远程仓库了</li>
</ol>
<h3 id="IDEA中集成Git"><a href="#IDEA中集成Git" class="headerlink" title="IDEA中集成Git"></a>IDEA中集成Git</h3><ol>
<li>新建项目，绑定git。</li>
</ol>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0D8LPGu2SNKXD01IMqDaSkBeP8ibtvnasBYiaReyuZWAl0EjEib8IYf7cQ/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" loading="lazy"></p>
<p>注意观察idea中的变化</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Cs93BiaOia1Sdk8icdH7vQzPfzIjuoTNYquKzYtrEe5mklhg2b7KOYsow/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" loading="lazy"></p>
<p>2、修改文件，使用IDEA操作git。</p>
<ul>
<li>添加到暂存区</li>
<li>commit 提交</li>
<li>push到远程仓库</li>
</ul>
<p>3、提交测试</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0tERIszdgLVlUWamyRapfN74aR8XeGFV2OYWiaeR9CkYlfoBefRh2AIA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" loading="lazy"></p>
<p>这些都是单个人的操作！</p>
<p>学习的方式最重要！学会学习！我上课的更多时候都是在教大家去学习一种理念和思想（学习方式）</p>
<p>有道无术、术尚可求。有术无道、止于术！</p>
<p>真正的教学，授人以渔！</p>
<h3 id="说明：GIT分支"><a href="#说明：GIT分支" class="headerlink" title="说明：GIT分支"></a>说明：GIT分支</h3><p>分支在GIT中相对较难，分支就是科幻电影里面的平行宇宙，如果两个平行宇宙互不干扰，那对现在的你也没啥影响。不过，在某个时间点，两个平行宇宙合并了，我们就需要处理一些问题了！</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0BOGzaG4QTc4JXO0hSlwcNtujNzAvxeibSrajLYLCT6otNnHDV9xYWwA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" loading="lazy"></p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0Ayn87woxfepOhSlUj4FQTFUsia4ic0j6aQy4Tz32PRuJ0HSVeGeUzURA/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" loading="lazy"></p>
<p>git分支中常用指令：</p>
<pre><code># 列出所有本地分支
git branch
# 列出所有远程分支
git branch -r
# 新建一个分支，但依然停留在当前分支
git branch [branch-name]
# 新建一个分支，并切换到该分支
git checkout -b [branch]
# 合并指定分支到当前分支
$ git merge [branch]
# 删除分支$ git branch -d [branch-name]
# 删除远程分支$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre>
<p>IDEA中操作</p>
<p><img src="https://mmbiz.qpic.cn/mmbiz_png/uJDAUKrGC7Ksu8UlITwMlbX3kMGtZ9p0wHNIYeTHC8aHGASoDyZO64QicslqiaMb1OJ1Z1LPoic3LBGyDIYBa7XXw/640?wx_fmt=png&tp=webp&wxfrom=5&wx_lazy=1&wx_co=1" alt="img" loading="lazy"></p>
<p>如果同一个文件在合并分支时都被修改了则会引起冲突：解决的办法是我们可以修改冲突文件后重新提交！选择要保留他的代码还是你的代码！</p>
<p>master主分支应该非常稳定，用来发布新版本，一般情况下不允许在上面工作，工作一般情况下在新建的dev分支上工作，工作完后，比如上要发布，或者说dev分支代码稳定后可以合并到主分支master上来。</p>
<p>作业练习：找一个小伙伴，一起搭建一个远程仓库，来练习Git！</p>
<p>1、不要把Git想的很难，工作中多练习使用就自然而然的会了！</p>
<p>2、Git的学习也十分多，看完我的Git教程之后，可以多去思考，总结到自己博客！</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>git常用命令</title>
    <url>/2022/05/28/git/git%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h5 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h5><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态，不然可能会提交了现在还不想提交的文件，或者要提交的文件没提交上。</p>
<ul>
<li>Untracked: 未跟踪, 此文件在文件夹中, 但并没有加入到git库, 不参与版本控制. 通过<code>git add</code> 状态变为Staged.</li>
<li>Unmodify: 文件已经入库, 未修改, 即版本库中的文件快照内容与文件夹中完全一致. 这种类型的文件有两种去处, 如果它被修改, 而变为Modified. 如果使用<code>git rm</code>移出版本库, 则成为Untracked文件</li>
<li>Modified: 文件已修改, 仅仅是修改, 并没有进行其他的操作. 这个文件也有两个去处, 通过git add可进入暂存staged状态, 使用git checkout 则丢弃修改过, 返回到unmodify状态, 这个<code>git checkout -- file  </code>即从库中取出文件, 覆盖当前修改 !</li>
<li>Staged: 暂存状态. 执行git commit则将修改同步到库中, 这时库中的文件和本地文件又变为一致, 文件为Unmodify状态. 执行git reset HEAD filename取消暂存, 文件状态为Modified</li>
</ul>
<h5 id="查看帮助文档"><a href="#查看帮助文档" class="headerlink" title="查看帮助文档"></a>查看帮助文档</h5><pre><code>git [command] --help</code></pre>
<h5 id="初始化本地仓库"><a href="#初始化本地仓库" class="headerlink" title="初始化本地仓库"></a>初始化本地仓库</h5><pre><code>git init</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123190404.png" alt="image-20201123190404628" loading="lazy"></p>
<h5 id="git克隆远程仓库"><a href="#git克隆远程仓库" class="headerlink" title="git克隆远程仓库"></a>git克隆远程仓库</h5><pre><code>git clone https/ssh</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201124000121.png" alt="image-20201124000121255" loading="lazy"></p>
<h5 id="git绑定远程仓库"><a href="#git绑定远程仓库" class="headerlink" title="git绑定远程仓库"></a>git绑定远程仓库</h5><pre><code class="sh">git remote add origin ssl/hhtp
#设置上传分支并上传
git push --set-upstream origin master </code></pre>
<h5 id="提交三板斧"><a href="#提交三板斧" class="headerlink" title="提交三板斧"></a>提交三板斧</h5><pre><code>#查看指定文件状态
git status [file-name]
#查看所有文件状态
git status
# 添加所有文件到暂存区
git add .
# 提交暂存区中的内容到本地仓库 -m 提交信息
git commit -m &quot;消息内容&quot;   
#先拉取远程仓库的最新内容,防止发生冲突
git pull
#同步到远程仓库
git push</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123190646.png" alt="image-20201123190646921" loading="lazy"></p>
<h5 id="查看历史版本"><a href="#查看历史版本" class="headerlink" title="查看历史版本"></a>查看历史版本</h5><pre><code>#查看单个文件的历史版本
git log &lt;file-name&gt;
#查看提交的历史版本
git log</code></pre>
<h5 id="checkout使用"><a href="#checkout使用" class="headerlink" title="checkout使用"></a>checkout使用</h5><pre><code>#从库中取出文件覆盖修改
git checkout -- file-name  
#将文件回退到某个版本
git checkout commit_id -- file-name</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123233303.png" alt="image-20201123233303532" loading="lazy"></p>
<h5 id="取消暂存"><a href="#取消暂存" class="headerlink" title="取消暂存"></a>取消暂存</h5><pre><code>git reset HEAD file-name
#取消所有暂存
git restore --staged .</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123232716.png" alt="image-20201123232716609" loading="lazy"></p>
<h5 id="取消更改"><a href="#取消更改" class="headerlink" title="取消更改"></a>取消更改</h5><pre><code>#丢弃工作区更改内容
git restore file</code></pre>
<h5 id="diff差异比较"><a href="#diff差异比较" class="headerlink" title="diff差异比较"></a>diff差异比较</h5><pre><code>#不加参数即默认比较工作区与暂存区
git diff
#比较暂存区与最新本地版本库（本地库中最近一次commit的内容）
git diff --cached [&lt;path&gt;...]
#比较工作区与最新本地版本库。如果HEAD指向的是master分支，那么HEAD还可以换成master
git diff HEAD [&lt;path&gt;...]
#比较工作区与指定commit-id的差异　　　　　　
git diff commit-id [&lt;path&gt;...]
#比较暂存区与指定commit-id的差异
git diff --cached [&lt;commit-id&gt;] [&lt;path&gt;...]
#比较两个commit-id之间的差异
git diff [&lt;commit-id&gt;] [&lt;commit-id&gt;]</code></pre>
<h5 id="发生错误了想回退某一版本"><a href="#发生错误了想回退某一版本" class="headerlink" title="发生错误了想回退某一版本"></a>发生错误了想回退某一版本</h5><ul>
<li><p>reset </p>
<pre><code># 先查看提交历史，确认需要回退的版本
git log
# 进行版本回退，回到指定版本的状态
# --hard:
# Resets the index and working tree. Any changes to tracked files in the working tree since &lt;commit&gt; are discarded
git reset --hard commit_id
# 强推送至远程分支
git push  --force</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123191052.png" alt="image-20201123191052324" loading="lazy"></p>
<p>回到指定某一个版本，但是此版本之后的提交都会消失，好像没有发生过一样。幸运的是 git reflog 会记录下所有的commit_id，因此还是可以在任意版本中穿梭</p>
<pre><code># 查看操作的所有记录
git reflog
# 回退到指定版本
git reset commit_id
#重新提交三板斧
git add.
git commit -m &#39; &#39;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201123191357.png" alt="image-20201123191357052" loading="lazy"></p>
</li>
<li><p>revert</p>
<p>对已经commit的代码再commit一次，对已提交的代码没有影响</p>
<pre><code>#先查看提交历史，确认需要回退的版本
git log
#进行版本回退，回到指定版本的状态
git revert commit_id
#如果有争议想丢掉这次revert，可以使用
git revert --abort</code></pre>
<p>revert可能会产生争议参考<a href="https://stackoverflow.com/questions/13008170/im-not-able-to-revert-a-file-while-its-conflicting-git">https://stackoverflow.com/questions/13008170/im-not-able-to-revert-a-file-while-its-conflicting-git</a></p>
</li>
</ul>
<h5 id="修改最后一次本地提交的消息"><a href="#修改最后一次本地提交的消息" class="headerlink" title="修改最后一次本地提交的消息"></a>修改最后一次本地提交的消息</h5><p>如果最后一次commit已经push了那么就应当不要再做修改了（修改后再次push会报错的）。</p>
<pre><code>git commit -amend</code></pre>
<h5 id="git-分支常用命令"><a href="#git-分支常用命令" class="headerlink" title="git 分支常用命令"></a>git 分支常用命令</h5><pre><code># 列出所有本地分支
git branch
# 列出所有远程分支
git branch -r
# 新建一个分支，但依然停留在当前分支
git branch [branch-name]
# 新建一个分支，并切换到该分支
git checkout -b [branch]
#切换分支
git checkout branch-name
# 合并指定分支到当前分支
$ git merge [branch]
# 删除分支
$ git branch -d [branch-name]
# 删除远程分支
$ git push origin --delete [branch-name]$ git branch -dr [remote/branch]</code></pre>
<h5 id="git-revert和git-reset"><a href="#git-revert和git-reset" class="headerlink" title="git revert和git reset"></a>git revert和git reset</h5><p><code>git reset</code> 会将当前分支的 HEAD 指针指向指定的提交，永久性地删除指定提交之后的所有提交，因此谨慎使用。</p>
<p><code>git revert</code> 则是撤销指定提交的操作，它会创建一个新的提交来撤销指定提交的更改。这样做可以保留指定提交之后的提交历史，因此更加安全。</p>
<p>使用 <code>git revert</code> 可以撤销某个提交，同时保留该提交之后的所有更改，这对于团队协作和版本控制非常有用。而使用 <code>git reset</code> 则会将提交历史永久性地修改，不适合在公共分支上使用。</p>
<pre><code class="bash">#commit b5a121096ac1e90957379b707ff1d9c5ce3f3657(head -&gt; master)
#commit 352d08eb8afdbf349d26c161e6719b1e2aeddc1b
#当前有两个提交
git reset 352d08eb8afdbf349d26c161e6719b1e2aeddc1b #log记录将只有352d08eb8afdbf349d26c161e6719b1e2aeddc1b这一条记录，当前提交之后的修改转为Unstaged状态
git revet 352d08eb8afdbf349d26c161e6719b1e2aeddc1b #会撤销指定提交</code></pre>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>rebase使用</title>
    <url>/2022/05/28/git/rebase%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<blockquote>
<p>The <code>git rebase</code> command allows you to easily change a series of commits, modifying the history of your repository. You can reorder, edit, or squash commits together.</p>
</blockquote>
<a id="more"></a>

<h5 id="合并多个commit"><a href="#合并多个commit" class="headerlink" title="合并多个commit"></a>合并多个commit</h5><p><strong>在分支只有自己使用的情况下使用！！！</strong></p>
<pre><code class="bash">git rebase -i [startpoint] [endpoint]</code></pre>
<p>startpoint、endpoint表示的是起止版本号，是一个开闭区间(startpoint, endpoint]，合并时不会包含开始版本号。</p>
<pre><code class="bash"> git rebase -i c416511b53ab7ab984c212628c6b3d7cb86ec3ef</code></pre>
<p>一般操作都是只写起始版本号，endpoint默认是HEAD。</p>
<p>出现如下编辑页面</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230227203857.png" alt="image-20230227203857462" loading="lazy"></p>
<p>下面是命令行用来操作每一个commit</p>
<p>编辑完后:wq退出即可。</p>
<p><strong>注意：</strong>首尾的commit都要留下，否则会出现**<code>head detached</code>**等情况</p>
<h5 id="将主分支最新commit作为分支的base-commit"><a href="#将主分支最新commit作为分支的base-commit" class="headerlink" title="将主分支最新commit作为分支的base commit"></a>将主分支最新commit作为分支的base commit</h5><p><img src="https://raw.githubusercontent.com/soda1/img/main/20230227204634.png" alt="image-20230227204634622" loading="lazy"></p>
<p>如图所示，如果想要将G作为topic分支的base commit</p>
<p>在当前分支为branch下执行如下命令</p>
<pre><code class="bash">git rebase master</code></pre>
<p>结果如下</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230227205417.png" alt="image-20230227205417592" loading="lazy"></p>
<p>参考：</p>
]]></content>
      <categories>
        <category>git</category>
      </categories>
  </entry>
  <entry>
    <title>自定义注解</title>
    <url>/2021/03/05/java/2021_03_05-%E8%87%AA%E5%AE%9A%E4%B9%89%E6%B3%A8%E8%A7%A3/</url>
    <content><![CDATA[<h4 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h4><p>负责注解自定义的注解</p>
<ul>
<li><p><strong>@Document</strong></p>
<p>标识注解是否被写入javadoc</p>
</li>
<li><p><strong>@Target</strong></p>
<p>标识注解的使用范围（方法、类、变量。。。），赋值为<code>ElementType</code>枚举类型</p>
</li>
<li><p><strong>@Retention</strong></p>
<p>标识注解的有效范围，赋值为<code>RetentionPolicy</code>枚举类型</p>
<p>runtime &gt; class &gt; source</p>
<pre><code class="java">   /**
     * Annotations are to be discarded by the compiler.
     */
    SOURCE,

    /**
     * Annotations are to be recorded in the class file by the compiler
     * but need not be retained by the VM at run time.  This is the default
     * behavior.
     */
    CLASS,

    /**
     * Annotations are to be recorded in the class file by the compiler and
     * retained by the VM at run time, so they may be read reflectively.
     *
     * @see java.lang.reflect.AnnotatedElement
     */
    RUNTIME</code></pre>
</li>
<li><p><strong>@Inherited</strong></p>
<p>子类可以继承父类中包含有该元注解的注解，注解只有定义在类上才能被继承。</p>
<blockquote>
<p>Note that this meta-annotation type has no effect if the annotated

<p>type is used to annotate anything other than a class.  Note also</p>
<p>that this meta-annotation only causes annotations to be inherited</p>
<p>from superclasses; annotations on implemented interfaces have no</p>
<p>effect.</p>
</blockquote>
</li>
</ul>
<h4 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h4><pre><code class="java">package com.soda.annotation;


import java.lang.annotation.*;
//可以在方法及类上使用
@Target(value = &#123;ElementType.METHOD, ElementType.TYPE&#125;)
//运行时有效
@Retention(value = RetentionPolicy.RUNTIME)
@Documented()
@Inherited()
public @interface MyAnnotation &#123;

    //定义参数
    String value();
&#125;</code></pre>
<ul>
<li><p>tips</p>
<p>获取注解参数值可以通过反射获取</p>
<pre><code class="java">    public static void main(String[] args) throws NoSuchMethodException &#123;
        Class&lt;Use02&gt; use02Class = Use02.class;
        //获取类上注解
        MyAnnotation annotation = use02Class.getAnnotation(MyAnnotation.class);
        System.out.println(annotation.value());

    &#125;</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>内部类</title>
    <url>/2021/03/11/java/2021_03_11-%E5%86%85%E9%83%A8%E7%B1%BB/</url>
    <content><![CDATA[<h4 id="为何使用内部类"><a href="#为何使用内部类" class="headerlink" title="为何使用内部类"></a>为何使用内部类</h4><blockquote>
<ul>
<li><strong>It is a way of logically grouping classes that are only used in one place</strong>: If a class is useful to only one other class, then it is logical to embed it in that class and keep the two together. Nesting such “helper classes” makes their package more streamlined.</li>
<li><strong>It increases encapsulation</strong>: Consider two top-level classes, A and B, where B needs access to members of A that would otherwise be declared <code>private</code>. By hiding class B within class A, A’s members can be declared private and B can access them. In addition, B itself can be hidden from the outside world.</li>
<li><strong>It can lead to more readable and maintainable code</strong>: Nesting small classes within top-level classes places the code closer to where it is used.</li>
</ul>
</blockquote>
<h4 id="非静态内部类"><a href="#非静态内部类" class="headerlink" title="非静态内部类"></a>非静态内部类</h4><h5 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h5><ol>
<li>可以直接访问外部类的所有作用域，使用private修饰符的变量、方法也可以访问。</li>
<li>可以使用<code>private</code>, <code>public</code>, <code>protected</code>修饰非静态内部类</li>
<li>不能声明静态变量及静态方法，可以声明常量（final）</li>
<li>非静态内部类只能存活在外部类实例之内（没有外部类实例就没有非静态内部类实例）</li>
</ol>
<h5 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h5><pre><code class="java">public class InnerClassTest &#123;

    private int i = 5;
    private final String string = &quot;hello&quot;;

    public class MyInnerClass&#123;

        final static int Constant = 8;


        public void getOutClassVar() &#123;
            System.out.println(i);
            System.out.println(string);

        &#125;

        public void getOuterClassPrivateMethod() &#123;
            priMethod();
        &#125;
    &#125;

    //私有方法
    private void priMethod() &#123;
        System.out.println(&quot;i am private&quot;);
    &#125;


    public static void main(String[] args) &#123;
        //创建方式
        InnerClassTest innerClassTest = new InnerClassTest();
        MyInnerClass myInnerClass = innerClassTest.new MyInnerClass();
        //调用
        myInnerClass.getOutClassVar();
        myInnerClass.getOuterClassPrivateMethod();
    &#125;


&#125;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210311191819.png" alt="image-20210311191819422" loading="lazy"></p>
<h5 id="作用域问题"><a href="#作用域问题" class="headerlink" title="作用域问题"></a>作用域问题</h5><p>不同作用域存在相同变量名，访问顺序为：方法参数&gt;内部类&gt;外部类</p>
<pre><code class="java">public class InnerClassTest &#123;

    private int x = 0;

    public class MyInnerClass&#123;

        private int x = 1;

        /**
         * scope test
         * @return
         */
        public void  ScopeTest(int x) &#123;
            System.out.println(x);
            System.out.println(this.x);
            System.out.println(InnerClassTest.this.x);
        &#125;

    &#125;


    public static void main(String[] args) &#123;
        InnerClassTest innerClassTest = new InnerClassTest();
        MyInnerClass myInnerClass = innerClassTest.new MyInnerClass();

        myInnerClass.ScopeTest(23);

    &#125;
&#125;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210311192133.png" loading="lazy"></p>
<h5 id="两个特性非静态内部类"><a href="#两个特性非静态内部类" class="headerlink" title="两个特性非静态内部类"></a>两个特性非静态内部类</h5><ul>
<li><p>局部内部类</p>
<p>可以定义在任何代码块中，外部类实例无法调用局部内部类进行实例化。</p>
<p>可以直接访问外部类</p>
<p>可以访问方法参数、final / <em>effectively</em> final的局部变量</p>
<pre><code class="java">public class NonStaticInnerClassTest &#123;

    private int x = 0;
    public  void localInnerClass(Integer i) &#123;

        int d = 3;
        class LocalClass&#123;

            public void getLocalvar() &#123;
                System.out.println(i);
                System.out.println(d);
                System.out.println(x);
            &#125;
        &#125;
        LocalClass localClass = new LocalClass();
        localClass.getLocalvar();
    &#125;

    public static void main(String[] args) &#123;

        NonStaticInnerClassTest nonStaticInnerClassTest = new NonStaticInnerClassTest();
        //局部内部类
        nonStaticInnerClassTest.localInnerClass(5);

    &#125;

</code></pre>
</li>
</ul>
<p>  }</p>
<pre><code>
&gt; ## Local Classes Are Similar To Inner Classes
&gt;
&gt; Local classes are similar to inner classes because they cannot define or declare any static members. Local classes in static methods, such as the class `PhoneNumber`, which is defined in the static method `validatePhoneNumber`, can only refer to static members of the enclosing class. For example, if you do not define the member variable `regularExpression` as static, then the Java compiler generates an error similar to &quot;non-static variable `regularExpression` cannot be referenced from a static context.&quot;
&gt;
&gt; Local classes are non-static because they have access to instance members of the enclosing block. Consequently, they cannot contain most kinds of static declarations.

- 匿名内部类

1. 通过new操作直接实现**接口**/**类扩展**(对类方法进行重写）
2. 初始化只能使用默认构造器（空参数构造器）
3. 可以使用`final` or `effectively final`局部变量
4. 可以访问外部类
5. 不能声明静态成员、方法，可以声明常量

&gt; The anonymous class expression consists of the following:
&gt;
&gt; - The `new` operator
&gt; - The name of an interface to implement or a class to extend. In this example, the anonymous class is implementing the interface `HelloWorld`.
&gt; - Parentheses that contain the arguments to a constructor, just like a normal class instance creation expression. **Note**: When you implement an interface, there is no constructor, so you use an empty pair of parentheses, as in this example.
&gt; - A body, which is a class declaration body. More specifically, in the body, method declarations are allowed but statements are not.
&gt;
&gt; Because an anonymous class definition is an expression, it must be part of a statement. In this example, the anonymous class expression is part of the statement that instantiates the `frenchGreeting` object. (This explains why there is a semicolon after the closing brace.)
&gt;
&gt; ## Accessing Local Variables of the Enclosing Scope, and Declaring and Accessing Members of the Anonymous Class
&gt;
&gt; Like local classes, anonymous classes can [capture variables](https://docs.oracle.com/javase/tutorial/java/javaOO/localclasses.html#accessing-members-of-an-enclosing-class); they have the same access to local variables of the enclosing scope:
&gt;
&gt; - An anonymous class has access to the members of its enclosing class.
&gt; - An anonymous class cannot access local variables in its enclosing scope that are not declared as `final` or effectively final.
&gt; - Like a nested class, a declaration of a type (such as a variable) in an anonymous class shadows any other declarations in the enclosing scope that have the same name. See [Shadowing](https://docs.oracle.com/javase/tutorial/java/javaOO/nested.html#shadowing) for more information.
&gt;
&gt; Anonymous classes also have the same restrictions as local classes with respect to their members:
&gt;
&gt; - You cannot declare static initializers or member interfaces in an anonymous class.
&gt; - An anonymous class can have static members provided that they are constant variables.
&gt;
&gt; Note that you can declare the following in anonymous classes:
&gt;
&gt; - Fields
&gt; - Extra methods (even if they do not implement any methods of the supertype)
&gt; - Instance initializers
&gt; - Local classes
&gt;
&gt; However, you cannot declare constructors in an anonymous class.

#### 静态内部类

##### 特点

1. 不能直接访问外部类，只能通过对象引用来访问
2. 可以使用`private`, `public`, `protected`修饰类
3. 和正常类基本一致
</code></pre>
]]></content>
  </entry>
  <entry>
    <title>java encode</title>
    <url>/2021/07/05/java/2021_07_05-java-encode/</url>
    <content><![CDATA[<h3 id="Java编码格式"><a href="#Java编码格式" class="headerlink" title="Java编码格式"></a>Java编码格式</h3><ol>
<li><p><strong>java char使用的编码格式</strong>    </p>
<p>char类型一开始定义为2个字节的来表示所有的字符，采用UCS2的编码形式，后面由于<a href="https://home.unicode.org/">Unicode</a>（码表）收录的字符越来越大，两个字节无法表示所有的字符，便采用了UTF-16的编码形式来保存字符。对于超过BMP表示的字符，用一对char来表示。因此程序中的char字符实际上代表的是一个**码元（code point)**，并不能严格的说它占了两个字节。</p>
<p><strong>utf8及utf16都是对Unicode的编码实现方式。</strong></p>
<blockquote>
<p>The set of characters from U+0000 to U+FFFF is sometimes  referred to as the <em>Basic Multilingual Plane (BMP)</em>. Characters whose code points are greater than U+FFFF are  called <em>supplementary character</em>s. The Java platform uses the UTF-16  representation in <code>char</code> arrays and in the <code>String</code> and  <code>StringBuffer</code> classes. In this representation, supplementary  characters are represented as a pair of <code>char</code> values, the first from  the <em>high-surrogates</em> range, (\uD800-\uDBFF), the second from the  <em>low-surrogates</em> range (\uDC00-\uDFFF). </p>
</blockquote>
</li>
<li><p><strong>java输出时使用的默认编码格式</strong></p>
<p>java输出的默认编码格式是由平台来决定的，在idea中默认是UTF8，Windows控制台是GBK, Linux是UTF8。<strong>这里不要和JVM内部的编码格式搞混</strong>，</p>
<p>JVM内部的字符使用的是UTF16，然后输出时会转成默认编码（或指定的编码）。</p>
</li>
<li><p><strong>读取文件时使用的编码格式</strong></p>
<p>使用的是文件指定的编码格式</p>
</li>
<li><p><strong>String.length</strong></p>
<p>表示的是码元的长度</p>
</li>
<li><p><strong>String.getBytes（）</strong></p>
<p>对字符串使用平台默认编码转成字节序列然后存进新的byte数组</p>
</li>
<li><p><strong>获取默认编码格式</strong></p>
<pre><code>Charset.defaultCharset() </code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka入门</title>
    <url>/2023/02/28/kafka/01.kafka%E5%85%A5%E9%97%A8/</url>
    <content><![CDATA[<h4 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h4><p>Kafka是以消息引擎起家，在设计之初旨在实现以下三大特性：</p>
<ul>
<li>提供一套 API 实现生产者和消费者；</li>
<li>降低网络传输和磁盘存储开销；</li>
<li>实现高伸缩性架构</li>
</ul>
<p>到现如今发展成一个分布式流处理平台</p>
<h4 id="消息模型"><a href="#消息模型" class="headerlink" title="消息模型"></a>消息模型</h4><ul>
<li><p>Producer/Consumer Model（队列模型）:</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230301145154.png" loading="lazy"></p>
<p>生产者产生消息放在队列一端，消费者从队列的另一端进行消费，如果没有消费者，那么消息就会保存在队列中直到队列满或者有消费者上线</p>
</li>
<li><p>Publisher/Subscriber Model（发布/订阅模型）</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230301145213.png" loading="lazy"></p>
</li>
</ul>
<p>Kafka同时支持以上两种模型</p>
<h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p><img src="https://raw.githubusercontent.com/soda1/img/main/20230228191503.png" loading="lazy"></p>
<p>图片展示了Kafka作为消息引擎的大致结构，术语解释如下：</p>
<ul>
<li>Broker：表示的是一个Kafka实例</li>
<li>Record：Kafka处理的主要对象，由Producer产生，&lt;key, value&gt;形式，key可以为空</li>
<li>Topic：作为Record的容器，多用来区分不同的业务</li>
<li>Partition：每一个Partition下的消息都是有序的，Topic下可以有多个Partition</li>
<li>Offset：表示的是消息的位置信息</li>
<li>Replica：副本，每个分区都可以保存多个副本，从而实现高可用</li>
<li>Producer：可以向主题<strong>发布</strong>消息的客户端</li>
<li>Consumer：向主题<strong>订阅</strong>消息的客户端，同一时间内一个Partition只能被一个Consumer消费  </li>
<li>Consumer Offset：表示的是消费者的消费进度</li>
<li>Consumer Group：由多个Consumer组成,同时消费多个分区</li>
<li>Leader副本：对位提供数据读写服务的分区副本称为Leader，其余的称为Follower</li>
</ul>
<h4 id="参数描述"><a href="#参数描述" class="headerlink" title="参数描述"></a>参数描述</h4><p>Kafka有着很多的配置参数，下面是一些比较重要的参数</p>
<h5 id="Broke-config"><a href="#Broke-config" class="headerlink" title="Broke config"></a>Broke config</h5><ul>
<li><p>broker.id：broker id，用于集群标识实例，不可重复，默认值为0</p>
</li>
<li><p>log.dirs：日志数据路径，这个是没有默认值的，需要自己去指定，可以指定多个路径，用逗号隔开。/home/kafka1/,/home/kafak2/</p>
</li>
<li><p>log.dir：这个用于指定单个路径，如果log.dirs没有设置的话就会使用这个</p>
</li>
<li><p>zookeeper.connect：zookeeper连接配置，以hostname:port的格式配置，配置多个是以逗号隔开</p>
</li>
<li><p>listeners：监听器,多个以逗号隔开，格式为<code>协议://hostname:port</code>，比如 <code>PLAINTEXT://myhost:9092</code>。协议如果不写，那么就必须要配置listener.security.protocol.map</p>
</li>
<li><p>advertised.listeners：这个是用于客户端的，客户端在做初始连接时获取的元信息会包含这些配置，这样客户端才会知道它需要请求的broker地址。当客户端和Kafka在不同的网络中就需要配置</p>
<p>listeners和advertised.listeners的区别参考<a href="https://rmoff.net/2018/08/02/kafka-listeners-explained/" title="Kafka Listeners - Explained">这篇文章</a></p>
</li>
<li><p>allow.auto.create.topics：是否允许自动创建Topic，default：true，建议false，避免创建一些奇怪的Topic</p>
</li>
<li><p>unclean.leader.election.enable：是否允许Unclean Leader选举，default：false。该选项决定同步落后太多的副本是否可以参与选举</p>
</li>
<li><p>auto.leader.rebalance.enable：允许Kafka定期对一些Topic分区进行Leader重选， default：true，建议生产环境中设为false</p>
</li>
<li><p>log.retention.{hour|minutes|ms}：数据留存时间，优先级上来说 ms 设置最高、minutes 次之、hour 最低。Kafka数据默认保存7天</p>
</li>
<li><p>log.retention.bytes：限制Broker保存数据的总容量大小，default：-1（无限制）</p>
</li>
<li><p>message.max.bytes：消息能正常接收的最大值</p>
</li>
<li><pre><code>num.network.threads：接收和响应请求线程数
num.io.threads：处理请求的线程数
这两个参数理解需要看Broker内部结构，num.network.threads对应Network Layer层Processor Thread线程数，num.io.threads是API Layer层的API Thread数</code></pre>
</li>
</ul>
<h5 id="Topic-config"><a href="#Topic-config" class="headerlink" title="Topic config"></a>Topic config</h5><ul>
<li>retention.ms：设置该Topic消息保存时长，该值会覆盖Broker端的全局参数配置</li>
<li>retention.bytes：设置为该Topic预留多少磁盘空间</li>
<li>max.message.bytes：该Topic可以正常接收到消息的最大值，会覆盖全局参数</li>
</ul>
<h5 id="JVM-config"><a href="#JVM-config" class="headerlink" title="JVM config"></a>JVM config</h5><p>Kafka是运行在JVM上的，因此配置JVM参数的重要性就不言而喻了</p>
<ul>
<li>KAFKA_HEAP_OPTS：指定堆大小，业界推荐6GB</li>
<li>KAFKA_JVM_PERFORMANCE_OPTS：指定GC参数，一般配置收集器为G1</li>
</ul>
<p>配置示例</p>
<pre><code class="bash">export KAFKA_HEAP_OPTS=--Xms6g  --Xmx6g
export  KAFKA_JVM_PERFORMANCE_OPTS= -server -XX:+UseG1GC -XX:MaxGCPauseMillis=20 -XX:InitiatingHeapOccupancyPercent=35 -XX:+ExplicitGCInvokesConcurrent -Djava.awt.headless=true
#启动
bin/kafka-server-start.sh config/server.properties</code></pre>
<p>更多参数参考<a href="https://kafka.apache.org/28/documentation.html#brokerconfigs">Kafka Doc</a>，这个文档写的很好，结构很清晰</p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
  </entry>
  <entry>
    <title>Kafka进阶</title>
    <url>/2023/03/01/kafka/02.%E8%BF%9B%E9%98%B6/</url>
    <content><![CDATA[<h4 id="分区机制"><a href="#分区机制" class="headerlink" title="分区机制"></a>分区机制</h4><p>分区的作用主要是为了提高负载均衡的能力，数据的读写都是在分区这个粒度上进行的，从而实现了系统的可伸缩性</p>
<h5 id="分区策略"><a href="#分区策略" class="headerlink" title="分区策略"></a>分区策略</h5><p>分区策略决定者生产者将消息发送至哪个区，如果生产者要定义一个分区策略，要在客户端实现<code>org.apache.kafka.clients.producer.Partitioner</code>接口，常见分区策略如下：</p>
<ul>
<li><p>轮询策略（ Round-robin）</p>
<p>Kafka默认策略，顺序分配，就是取余操作，$ partition_index = n % partition_num $，n表示第n条消息。轮询策略有着很好的负载均衡表现。</p>
</li>
<li><p>随机策略（Randomness）</p>
<p>随机返回一个partition</p>
</li>
<li><p>按消息键保序策略</p>
<p>Kafka允许为每条消息都定义一个消息键，可以通过对键进行hash从而保存到特定的partition中。这也是Kafka的默认策略之一，假设客户端没有自定义策略，如果是消息中带着Key，那么就会执行这个策略，否则就使用轮询策略</p>
</li>
</ul>
<p>spring boot实现例子</p>
<pre><code class="java">public class MyPartitioner implements Partitioner &#123;
    @Override
    public int partition(String s, Object o, byte[] bytes, Object o1, byte[] bytes1, Cluster cluster) &#123;
        List&lt;PartitionInfo&gt; partitionInfos = cluster.availablePartitionsForTopic(s);
        int num = ThreadLocalRandom.current().nextInt(partitionInfos.size());
        System.out.println(num);
        return num;
    &#125;
    .........
&#125;</code></pre>
<p>配置partitioner路径，这个在yml中没有找到属性，用代码来配置</p>
<pre><code class="java">    @Bean
    public Map&lt;String, Object&gt; producerConfigs() &#123;
        Map&lt;String, Object&gt; props = new HashMap&lt;&gt;();
        props.put(ProducerConfig.BOOTSTRAP_SERVERS_CONFIG, &quot;192.168.3.100:9092&quot;);
        props.put(ProducerConfig.KEY_SERIALIZER_CLASS_CONFIG, IntegerSerializer.class);
        props.put(ProducerConfig.VALUE_SERIALIZER_CLASS_CONFIG, StringSerializer.class);
        props.put(ProducerConfig.PARTITIONER_CLASS_CONFIG, MyPartitioner.class);
        // See https://kafka.apache.org/documentation/#producerconfigs for more properties
        return props;
    &#125;
    @Bean
    public ProducerFactory&lt;Integer, String&gt; producerFactory() &#123;
        return new DefaultKafkaProducerFactory&lt;&gt;(producerConfigs());
    &#125;
    @Bean
    public KafkaTemplate&lt;Integer, String&gt; kafkaTemplate() &#123;
        return new KafkaTemplate&lt;Integer, String&gt;(producerFactory());
    &#125;</code></pre>
<h4 id="消息解压缩"><a href="#消息解压缩" class="headerlink" title="消息解压缩"></a>消息解压缩</h4><ul>
<li><p>Producer端压缩</p>
<p>Producer客户端开启压缩算法只要在<code>compression.type</code>配置指定的类型算法即可，在Producer端配置好处在于有利于网络传输</p>
</li>
<li><p>Broker端压缩</p>
<p>Broker也有可能会对消息进行压缩，有如下情况</p>
<p>情况1：Broker端和Producer端压缩算法不一致产生</p>
<p>情况2：因消息版本不同原因发生的兼容格式转换产生</p>
</li>
<li><p>Broker端解压</p>
<p>Broker端需要对接收到的消息进行验证，比如CRC校验，因此会解压消息</p>
</li>
<li><p>Consumer端解压</p>
<p>Consumer消费消息需要先解压还原消息</p>
</li>
</ul>
<p>消息解压缩整个流程可以概况为一句话：Producer 端压缩、Broker 端保持、Consumer 端解压。</p>
<p>压缩算法比较</p>
<p>吞吐量：LZ4 &gt; Snappy &gt; zstd 和 GZIP</p>
<p>压缩比：zstd &gt; LZ4 &gt; GZIP &gt; Snappy</p>
<h4 id="无消息丢失配置"><a href="#无消息丢失配置" class="headerlink" title="无消息丢失配置"></a>无消息丢失配置</h4><p>Producer</p>
<ul>
<li>Producer发送消息要使用带回调的send(msg, callback)</li>
<li>Producer设置acks=all，表示所有in-sync replicas都已经接收到消息了，消息才算发送成功</li>
<li>Producers设置retries，消息发送失败时应当重试多次，还不行再另作处理</li>
</ul>
<p>Broker端</p>
<ul>
<li><p>unclean.leader.election.enable = false，落后太多的副本不应当竞选leader</p>
</li>
<li><p>replication.factor &gt;= 3，将副本多保存几份</p>
</li>
<li><p>min.insync.replicas &gt; 1，这个配置是保证当Producer的ack=all时，Broker端至少存在多少个in-sync replicas才能进行写入。可参考<a href="https://accu.org/journals/overload/28/159/kozlovski/" title="Kafka Acks Explained">文章</a>。</p>
<p>要配置replication.factor &gt; min.insync.replicas，否则一个副本挂了分区就不可用了。推荐成replication.factor = min.insync.replicas + 1</p>
</li>
</ul>
<p>Consumer</p>
<ul>
<li>enable.auto.commit设置为false，改为手动提交，并采用手动提交位移</li>
</ul>
<h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>todo</p>
<h4 id="Producer一次发送流程"><a href="#Producer一次发送流程" class="headerlink" title="Producer一次发送流程"></a>Producer一次发送流程</h4><p>步骤如下：</p>
<ol>
<li>构造生产者对象所需的参数对象</li>
<li>根据参数创建KafkaProducer对象实例</li>
<li>调用send方法发送消息</li>
<li>调用close方法释放资源</li>
</ol>
<p>深入：</p>
<ol>
<li>在创建KafkaProducer对象时后台会创建一个名为Seeder的线程，该线程会与 bootstrap.servers配置的所有Broker进行Tcp连接，用于获取集群元数据信息。</li>
<li>Producer会通过metadata.max.age.ms 参数来定期地去更新元数据信息，默认时5分钟。</li>
<li>在发送消息时，Producer会从元数据缓存中找到需要发送的Broker信息，建立Tcp连接来发送信息</li>
</ol>
<h4 id="Message-Delivery-Semantics"><a href="#Message-Delivery-Semantics" class="headerlink" title="Message Delivery Semantics"></a>Message Delivery Semantics</h4><p>有如下三种语义保证：</p>
<ul>
<li><p>最多一次（at most once）：消息可能会丢失，但绝不会被重复发送</p>
</li>
<li><p>至少一次（at least once）：消息不会丢失，但有可能被重复发送</p>
</li>
<li><p>精确一次（exactly once）：消息不会丢失，也不会被重复发送</p>
</li>
</ul>
<p>Kafka默认提供at least once的可靠性保证，提供了重试的机制。</p>
<h5 id="Kafka如何保证exactly-once"><a href="#Kafka如何保证exactly-once" class="headerlink" title="Kafka如何保证exactly once"></a>Kafka如何保证exactly once</h5><h6 id="幂等性"><a href="#幂等性" class="headerlink" title="幂等性"></a>幂等性</h6><p>在0.11版本开始支持，Broker给每个Producer分配一个ID，且Producer的每条信息都会有一个序列号用来去重信息。可以通过指定<code>enable.idempotence=true</code>来配置幂等Producer</p>
<p>Kafka只能保证单分区上的幂等性，即一个幂等性 Producer 能够保证某个主题的一个分区 上不出现重复消息，它无法实现多个分区的幂等性。其次，它只能实现单会话上的幂等性，不 能实现跨会话的幂等性。这里的会话，你可以理解为 Producer 进程的一次运行。当你重启了 Producer 进程之后，这种幂等性保证就丧失了。</p>
<h6 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h6><p>从0.11版本开始支持，通过<code>置 isolation.level</code>来设置事务级别，有以下参数</p>
<ul>
<li>read_uncommitted：默认值，表明Consumer可以读取事务型Producer写入的任何消息</li>
<li>read_committed：表明 Consumer 只会读取事务型 Producer 成功提交事务写入的消 息</li>
</ul>
<p>事务型Producer通过流程代码控制，类似mysql那样(begin, commit)</p>
<p>事务可以保证跨分区，跨会话的幂等。</p>
<h4 id="消费机制"><a href="#消费机制" class="headerlink" title="消费机制"></a>消费机制</h4><h5 id="Consumer-Group"><a href="#Consumer-Group" class="headerlink" title="Consumer Group"></a>Consumer Group</h5><p>Consumer Group 是 Kafka 提供的可扩展且具 有容错性的消费者机制。每个组都有一个Group ID， 组内存在多个消费实例共同消费Topic所有的Partition，<strong>一个Partition只能被分配给组内一个Consumer消费</strong>。</p>
<h6 id="实现两大模型"><a href="#实现两大模型" class="headerlink" title="实现两大模型"></a>实现两大模型</h6><p>Consumer Group是Kafka实现两个模型的机制</p>
<ul>
<li>只有一个组进行消费Topic，那么就是队列模型</li>
<li>多个组消费Topic，那么就是发布/订阅模型</li>
</ul>
<h5 id="Standalone-Consumer"><a href="#Standalone-Consumer" class="headerlink" title="Standalone Consumer"></a>Standalone Consumer</h5><p>相当于只有一个Consumer的消费组，也需要Group ID标识</p>
<h5 id="consumer-offsets"><a href="#consumer-offsets" class="headerlink" title="_consumer_offsets"></a>_consumer_offsets</h5><p>_consumer_offsets是Kafka内部Topic，它的主要作用就是为了保持Consumer消费的位移信息，它是一个普通的Topic，可以对它进行操作，但请不要这么做</p>
<ol>
<li><p>创建时机</p>
<p>当 Kafka 集群中的第一个 Consumer 程序启动时，Kafka 会自动创建位移主题，默认分区数是50，副本数3。可以通过<code>offsets.topic.num.partitions</code>、<code>offsets.topic.replication.factor</code>配置，但不建议</p>
</li>
<li><p>消息格式</p>
<ul>
<li><p>位移信息格式</p>
<p>保存的消息格式是KV对，Key用&lt;Group ID, Topic, Partition&gt;来标识， Value保存位移值</p>
</li>
<li><p>保存 Consumer Group 信息的消息</p>
<p>用于注册Consumer Group</p>
</li>
<li><p>tombstone消息</p>
<p>删除 Group 过期位移甚至是删除 Group 的消息</p>
</li>
</ul>
</li>
<li><p>Group数据保存在哪个区？</p>
<p>$$partitionId=Math.abs(groupId.hashCode() % offsetsTopicPartitionCount)$$</p>
</li>
<li><p>Compact 策略</p>
<p>Kafka 使用Compact 策略来删除位移主题中的过期消息，避免该主题无限期 膨胀。过期定义：对于同一个 Key 的两条消息 M1 和 M2，如果 M1 的发送时间早于 M2，那么 M1 就是过期消息。Compact 的过程就是扫描日志 的所有消息，剔除那些过期的消息，然后把剩下的消息整理在一起。</p>
<p>Kafka 提供了专门的后台线程（ Log Cleaner）定期地巡检待 Compact 的主题，看看是否存在满足条件的可删 除数据</p>
</li>
</ol>
<h5 id="Coordinator组件"><a href="#Coordinator组件" class="headerlink" title="Coordinator组件"></a>Coordinator组件</h5><p>每个Broker都有各自的Coordinator组件，它是专门为Consumer Group服务的，负责为 Group 执行 Rebalance 以及提供位移管理和组成员管理</p>
<p>如何知道Group被哪个Coordinator管理？</p>
<ol>
<li>确定由的哪个_consumer_offsets分区来保存该 Group 数据（_consumer_offsets保存算法）</li>
<li>找出该分区 Leader 副本所在的 Broker，该 Broker 即为对应的 Coordinator。</li>
</ol>
<h5 id="Rebalance"><a href="#Rebalance" class="headerlink" title="Rebalance"></a>Rebalance</h5><p>Kafka对Consumer Group重新分配Partition的过程称为Rebalance。Rebalance 发生时，Group 下所有的 Consumer 实例都会协调在一起共同参与，在协调者组件的帮助下，完成订阅主题分区的分配</p>
<ol>
<li><p>何时触发？</p>
<ul>
<li>组成员数改变</li>
<li>订阅主题数改变</li>
<li>订阅主题分区数改变</li>
</ul>
</li>
<li><p>产生影响</p>
<p>在Rebalance过程中，所有的Consumer都会停止消费，如果有Consumer正在消费消息的话，将会导致消息重复消费问题</p>
</li>
<li><p>Coordinator如何判断Consumer实例退组</p>
<p>心跳机制，每个Consumer都会定期的向Coordinator发送心跳，如果不能及时发送心跳，那么Coordinator就会认为该Consumer退组，进而开始Rebalance。</p>
<p>Consumer端相关参数</p>
<ul>
<li><code>heartbeat.interval.ms</code>：心跳请求频率参数</li>
<li><code>max.poll.interval.ms</code>： 两次调 用 poll 方法的最大时间间隔。它的默认值是 5 分钟。在两次调用poll的间隔间，业务逻辑处理时间过长，超出配置值，那么Consumer就会自动退组</li>
<li><code>session.timout.ms</code>：存活时间间隔，默认10s。表明如果10s内没有任何心跳请求，Coordinator就判断Consumer已经退出</li>
</ul>
<p>推荐配置：</p>
<p><code>session.timeout.ms = 6s</code></p>
<p><code> heartbeat.interval.ms = 2s</code></p>
<p><code>max.poll.interval.ms</code>设置为业务逻辑处理最长时间</p>
</li>
</ol>
<h6 id="Rebalance要点"><a href="#Rebalance要点" class="headerlink" title="Rebalance要点"></a>Rebalance要点</h6><ul>
<li><p>通知机制</p>
<p>当发生Rebalance时，Coordinator将”REBALANCE_IN_PROGRESS“封装进心跳请求响应里面，Consumer也因此知道了重平衡马上就要开始了</p>
</li>
<li><p>Consumer Group状态机</p>
<p>Kafka为消费组定义了5种状态</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230303190703.png" loading="lazy"></p>
<p>状态机流转如下</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230303190823.png" loading="lazy"></p>
<p>一个消费者组最开始是 Empty 状态，当重平衡过程开启后，它会被置于 PreparingRebalance 状态等待成员加入，之后变更到 CompletingRebalance 状态等待分配方案，最后流转到 Stable 状态完成重平衡</p>
<p>如果组在Empty状态下的存在很长时间（整个组停掉长时间不在消费），位移数据可能会被删除</p>
</li>
</ul>
<h6 id="Consumer重平衡步骤"><a href="#Consumer重平衡步骤" class="headerlink" title="Consumer重平衡步骤"></a>Consumer重平衡步骤</h6><ol>
<li><p>加入组（JoinGroup请求）</p>
<p>每个组员都会将自己订阅信息上报，Coordinator会从组员中选出Leader Consumer，一般的第一个请求者。选举完后会将所有的订阅信息发送的Leaders Consumer，由其制定分配</p>
</li>
<li><p>等待Leader Consumers分配方案（SyncGroup请求）</p>
<p>Leaders Consumer完成分配方案后向Coordinate发送SyncGroup请求，同时其他组员也会发送SyncGroup请求，但没有实际内容。最后统一以响应的方式分发给所有组员</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230303192421.png" loading="lazy"></p>
<center>JoinGroup请求</center>

<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230303192537.png" loading="lazy"></p>
<center>SyncGroup请求</center>



<h5 id="位移提交"><a href="#位移提交" class="headerlink" title="位移提交"></a>位移提交</h5><p><strong>Consumer需要为分配给它的每个分区提交各自的位移数据</strong>，用来表示消费进度。比如提交位移进度X表示X以下都已经被消费</p>
<p>提交方式：</p>
<ol>
<li><p>自动提交</p>
<p>自动提交保证at least one，这就意味着可能存在消息重复消费，比如Consumer 正在消费时宕机了，产生了Rebalance，分配完后其他Consumer会从它消费的所有Partition的最近一次提交位移处开始消费，从而导致重复消费</p>
<blockquote>
<p>By default, the consumer is configured to auto-commit offsets. Using auto-commit gives you “at least once” delivery: Kafka guarantees that no messages will be missed, but duplicates are possible. Auto-commit basically works as a cron with a period set through the <code>auto.commit.interval.ms</code> configuration property. If the consumer crashes, then after a restart or a rebalance, the position of all partitions owned by the crashed consumer will be reset to the last committed offset. When this happens, the last committed position may be as old as the auto-commit interval itself. Any messages which have arrived since the last commit will have to be read again. <a href="https://docs.confluent.io/platform/current/clients/consumer.html#ak-consumer-configuration">consumer doc</a></p>
</blockquote>
<p>通过<code> enable.auto.commit</code>设置是否开启，默认是开启的</p>
<p><code>auto.commit.interval.ms</code>表示自动提交间隔，默认值为5s</p>
<p>自动提交逻辑是在poll方法里面执行的，每次poll的时候都会判断是否需要自动提交，大概逻辑如下</p>
<pre><code>第一次poll        设置提交时间为5s后
    +10s 
第二次poll        两次poll间隔为10s，比5s大就自动提交，然后设置下次提交时间为15s</code></pre>
</li>
<li><p>手动提交</p>
<p>将<code>enable.auto.commit</code>设置为false即可，Kafka提供同步和异步提交两种方式</p>
<ul>
<li><p>同步提交</p>
<p>使用KafkaConsumer#commitSync方法，提供重试机制，同步提交会影响TPS</p>
</li>
<li><p>异步提交</p>
<p>使用 KafkaConsumer#commitAsync()方法，没有重试机制，异步方式重试机制是没有意义的</p>
<p>异步提交可能会导致消息丢失，Kafka提供回调函数，可以通过回调函数时进行失败逻辑处理</p>
</li>
</ul>
<p>将同步提交和异步提交结合</p>
<pre><code class="java">try&#123;
    while (true) &#123;
        ConsumerRecords&lt;String, String&gt; records = 
        consumer.poll(Duration.ofSeconds(1));
         process(records); // 处理消息
         commitAysnc(); // 使用异步提交规避阻塞
     &#125;
&#125; catch (Exception e) &#123;
     handle(e); // 处理异常
&#125; finally &#123;
     try &#123;
         consumer.commitSync(); // 最后一次提交使用同步阻塞式提交
    &#125; finally &#123;
         consumer.close();
    &#125;
&#125;</code></pre>
<p>也可以使用<code>commitSync(final Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets)</code>及<code>commitAsync(final Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets, OffsetCommitCallback callback)</code>进行小批量提交，比如每消费一百条提交一次</p>
<pre><code class="java">
private Map&lt;TopicPartition, OffsetAndMetadata&gt; offsets = new HashMap&lt;&gt;();
int count = 0;
……
while (true) &#123;
     ConsumerRecords&lt;String, String&gt; records = consumer.poll(Duration.ofSeconds(1));
     for (ConsumerRecord&lt;String, String&gt; record: records) &#123;
         process(record); // 处理消息
         offsets.put(new TopicPartition(record.topic(), record.partition()),
         new OffsetAndMetadata(record.offset() + 1)；
         if（count % 100 == 0）
             consumer.commitAsync(offsets, null); // 回调处理逻辑是 n
         count++;
    &#125;
&#125;</code></pre>
</li>
</ol>
<p>自动提交和手动提交都无法避免消息重复消息问题，需要在业务上做去重</p>
<h5 id="Consumer建立TCP连接种类"><a href="#Consumer建立TCP连接种类" class="headerlink" title="Consumer建立TCP连接种类"></a>Consumer建立TCP连接种类</h5><p>有3类TCP连接</p>
<ol>
<li><p>发起 FindCoordinator 请求时（第一类）</p>
<p>创建TCP连接，发送FindCoordinator请求到<code>bootstrap.servers</code>的任意服务器，得到管理它的Broker元数据</p>
</li>
<li><p>连接Coordinator（第二类）</p>
<p>创建与Coordinator的TCP连接，这样才能开启组协调操作</p>
</li>
<li><p>消费消息时（第三类）</p>
<p>Consumer为每个要消费的分区创建于该分区领导者副本所在的Broker连接的TCP</p>
</li>
</ol>
<p>当第三类连接建立时，Consumer会kill掉第一类TCP连接</p>
<h5 id="消费进度监控"><a href="#消费进度监控" class="headerlink" title="消费进度监控"></a>消费进度监控</h5><ul>
<li>Lag：表示消费消息落后生产消息程度，比如产生了100万条消息，当前消费了80万条，那么消息滞后了20万条，即Lag=20w</li>
<li>Lead：表示最新消费消息的位移和分区第一条位移的差值，比如当前消费位移为5，第一条位移为0，那么Lead=5</li>
</ul>
<p>使用JMX监控</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230303160430.png" alt="image-20230303160423390" loading="lazy"></p>
<h4 id="副本机制"><a href="#副本机制" class="headerlink" title="副本机制"></a>副本机制</h4><p> Kafka采用了基于领导者的（Leader-based）的副本机制。</p>
<ol>
<li>副本分为Leader和Follower副本，Follower会自动追随Leader</li>
<li>只有Leader对外提供服务，Follower从Leader异步拉取消息</li>
<li>如果Leader挂了，Kafka会进行重新选举</li>
</ol>
<h5 id="In-sync-Replicas（ISR）"><a href="#In-sync-Replicas（ISR）" class="headerlink" title="In-sync Replicas（ISR）"></a>In-sync Replicas（ISR）</h5><p>与Leader保持同步的副本称为ISR，是否保持同步的标准就是Broker 端参数 <code>replica.lag.time.max.ms </code>参数值，默认10s。它表示的是Follower能够落后Leader的最长时间</p>
<p>Kafka在启动时会开启两个任务，一是定期检查是否需要缩减或扩大ISR集合，周期是<code>是replica.lag.time.max.ms</code>一半；二是定期检查isrChangeSet（缓存ISR变更记录集合），如果Set有变更记录，那么会在zk中持久化一个节点 。controller节点注册的watcher能感知到ISR的变化然后向它所管理的Broker节点发送更新元数据请求，最后删除处理过的节点</p>
<ul>
<li><p>踢出ISR</p>
<p>如果Follower在超出了<code>replica.lag.time.max.ms</code>时间后还出于落后状态，那就会被踢出ISR。</p>
</li>
<li><p>进入ISR</p>
<p>当检查到Follower的High Watermark追赶上Leader时就扩充ISR</p>
</li>
</ul>
<h5 id="Unclean-Leader-Election"><a href="#Unclean-Leader-Election" class="headerlink" title="Unclean Leader Election"></a>Unclean Leader Election</h5><p>Unclean Leader Election指的是当ISR为空（Leader也不在了）时，是否允许Kafka在非同步副本中选举新的Leader，如果不允许，那么分区就失效了。</p>
<p>通过Broker 端参数 <code>unclean.leader.election.enable</code>控制是否开启</p>
<p>开启选项可能会造成数据丢夫，好处在于提高了可用性</p>
<h5 id="High-Watermark-HW"><a href="#High-Watermark-HW" class="headerlink" title="High Watermark(HW)"></a>High Watermark(HW)</h5><p>Kafka用High Watermark来表征消息位移，有以下作用</p>
<ul>
<li>定义消息可见性，即分区哪些消息可被消费</li>
<li>帮助Kafka完成副本同步</li>
</ul>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230305165243.png" loading="lazy"></p>
<p>同一个副本对象，其高 水位值不会大于 LEO（Log End Offset) 值</p>
<h6 id="更新机制"><a href="#更新机制" class="headerlink" title="更新机制"></a>更新机制</h6><p><img src="https://raw.githubusercontent.com/soda1/img/main/20230305165811.png" loading="lazy"></p>
<p>每个副本都会保存HW和LEO两个属性，而Leader所在的Broker也会保存所有Follower的副本，用于帮助Leader确定其HW。</p>
<p><strong>Leader下更新逻辑</strong></p>
<p>处理Producer消息</p>
<ol>
<li>消息写入磁盘</li>
<li>更新分区HW<ol>
<li>获取Leader所在Broker保存的Followers的LEO值{LEO-1，LEO-2…}</li>
<li>更新HW=min(leader-LEO, LEO-1, LEO-2…..)</li>
</ol>
</li>
</ol>
<p>处理Follower拉取消息</p>
<ol>
<li>根据Follower发送来的LEO读取消息数据</li>
<li>将Follower发送来的LEO更新到Broker保存的对应副本中</li>
<li>更新分区HW（同上）</li>
</ol>
<p><strong>Follower下更新逻辑</strong></p>
<p>从Leader处拉取消息：</p>
<ol>
<li>将消息写入磁盘</li>
<li>更新LEO</li>
<li>更新HW<ol>
<li>获取Leader发送来的leader-LEO</li>
<li>获取更新过的currentLEO</li>
<li>更新高水位为min(leader-LEO, currentLEO)</li>
</ol>
</li>
</ol>
<p><strong>更新存在问题</strong></p>
<p>HW的更新通常需要额外一轮的拉取请求才能完成，容易引发以下问题</p>
<ul>
<li><p>备份数据丢失</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230305172705.png" loading="lazy"></p>
<p>如图所示，当A更新完HW后，B还未来得及更新就宕机了，重启后HW还是为1，此时向A发送Fetch请求，如果A恰好又宕机了，那么B就会成为Leader，后面A重启后向B发送Fetch请求，HW将更新为1，从而丢失数据</p>
</li>
<li><p>备份数据不一致</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230305235446.png" loading="lazy"></p>
<p>如图所示，当A的HW=2 和B的HW=1时同时发生了宕机，B重启后成为了Leader，此时Producer发送了消息给B，B就会覆盖消息2且HW也会更新为2，后面A重启回来会执行日志截断，但发现分区的HW和自己的HW都是2，故不作任何调整，从而引起数据不一致</p>
<p><strong>leader epoch</strong></p>
<p>Kafka从0.11引入leader epoch，从而规避以上问题。leader epoch实际是一对值（epoch， offset），epoch表示版本号，从0开始，每当leader角色发生变更就+1，offset表示写入该epoch的第一条消息位移。</p>
<p>Kafka Broker 会在内存中为每个分区都缓存  epoch 数据，同时它还将这些 信息持久化到一个 checkpoint 文件中。如果Leader 是首次写入消息，那么Broker会向缓存中增加一个 epoch 条目，否则就不做更新。</p>
<p>解决数据丢失</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230306010801.png" loading="lazy"></p>
<p>副本B重启后向A发送LeaderEpochRequest获取A的LEO值，发现A的LEO不比自己的小，且epoch中的offset也没有比2大，因此无需执行任何日志截断</p>
<p>当B成为Leader时,[epoch = 1, offset = 3],A重启后会向B发送LeaderEpochRequest去获取Leader的LEO值，发现其LEO比B的小且epoch中的offset也没有比3大，因此也无需截断</p>
<p>注意只有Follower才会执行日志截断，Leader是不会执行日志截断的</p>
</li>
</ul>
<h4 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h4><p><img src="https://raw.githubusercontent.com/soda1/img/main/20230306151424.png" loading="lazy"></p>
<p>todo：外网暂未找到相关资料</p>
<h5 id="Broker网络模型"><a href="#Broker网络模型" class="headerlink" title="Broker网络模型"></a>Broker网络模型</h5><p>Broker网络层采用了Reactor模式，有个核心组件SocketServer，线程模型如下：</p>
<ul>
<li>一个Acceptor线程接收请求</li>
<li>N个Processor线程,每个Processor都有自己的selector,从每个连接中读取请求</li>
<li>M个Handler线程处理请求,并将产生的请求返回给Processor线程用于写回客户端</li>
</ul>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230303184103.png" loading="lazy"></p>
<h4 id="Controller"><a href="#Controller" class="headerlink" title="Controller"></a>Controller</h4><p>控制器组件（Controller）是 Apache Kafka 的核心组件。它的主要作用是在 Apache ZooKeeper 的帮助下管理和协调整个 Kafka 集群。Kafka集群通过选举选出Controller。JMX指标为<code>activeController</code></p>
<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><ol>
<li><p>主题管理（创建、删除、增加分区）</p>
</li>
<li><p>分区重分配</p>
</li>
<li><p>.Preferred 领导者选举</p>
<p>Preferred选举是Kafka为了避免部分Broker负载过重而提供的一种换Leader方案</p>
</li>
<li><p>集群成员管理（新增 Broker、Broker 主动关闭、Broker 宕机）</p>
</li>
<li><p>数据服务（集群元数据信息）</p>
<p>Controller会有整个集群最完整的元数据信息，Zookeeper也会保存一份，Controller的初始化元数据信息由Zookeeper提供</p>
</li>
</ol>
<h5 id="如何选举"><a href="#如何选举" class="headerlink" title="如何选举"></a>如何选举</h5><p>当Broker启动时，会尝试在Zookeeper中/controller节点，第一个创建成功的Broker会被选举为Controller</p>
<h5 id="失效处理"><a href="#失效处理" class="headerlink" title="失效处理"></a>失效处理</h5><p>当Controller所在的Broker出现异常退出了集群，Zookeeper通过Watch机制感应并将/controller节点删除，之后存活的Broker会开始进行选举，选举成功的Broker会从Zookeeper中读取元数据信息，进行初始化。</p>
<h5 id="内部设计结构"><a href="#内部设计结构" class="headerlink" title="内部设计结构"></a>内部设计结构</h5><p><img src="https://raw.githubusercontent.com/soda1/img/main/20230304145246.png" loading="lazy"></p>
<h4 id="动态Broker参数"><a href="#动态Broker参数" class="headerlink" title="动态Broker参数"></a>动态Broker参数</h4><p>从1.1版本开始， Brokers Configs增加Update Model列，有三类值</p>
<ul>
<li>read-olny：表示修改只能重启Broker后才能生效</li>
<li>per-broker: 属于动态参数，修改后只在对应Broker上生效</li>
<li>cluster-wide：属于动态参数，修改后整个集群生效</li>
</ul>
<p><del>优先级别： per-broker &gt; cluster-wide &gt; read-only&gt; Kafka默认值</del></p>
<p><strong>使用场景</strong></p>
<ul>
<li>动态调整 Broker 端各种线程池大小，实时应对突发流量</li>
<li> 动态调整 Broker 端连接信息或安全配置信息</li>
<li> 动态更新 SSL Keystore 有效期</li>
<li> 动态调整 Broker 端 Compact 操作性能</li>
<li> 实时变更 JMX 指标收集器 (JMX Metrics Reporter)</li>
</ul>
<p><strong>如何配置</strong></p>
<p>使用kafka-config.sh</p>
<h4 id="重设消费组位移"><a href="#重设消费组位移" class="headerlink" title="重设消费组位移"></a>重设消费组位移</h4><p><strong>策略</strong></p>
<ul>
<li>Earliest：把位移调整到当前最早位移处</li>
<li>Latest：把位移调整到当前最新位移处</li>
<li>Current：把位移调整到当前最新提交位移处</li>
<li>Specified-Offset：把位移调整到指定位移处</li>
<li>Shift-By-N：把位移调整到当前位移 +N处（N可为负值）</li>
<li>DateTime：把位移调整到大于给定时间的最小位移处</li>
<li>Duration：把位移调整到距离当前时间指定间隔位移处</li>
</ul>
<p><strong>方法</strong></p>
<ul>
<li>通过Java API重设位移：调用KafkaConsumer的seek方法，或者它的变种方法seekToBeginning和seekToEnd</li>
<li>用脚本kafka-consumer-groups脚本</li>
</ul>
<h4 id="脚本工具"><a href="#脚本工具" class="headerlink" title="脚本工具"></a>脚本工具</h4><ul>
<li><p>kafka-acls：设置Kafka权限</p>
</li>
<li><p>kafka-broker-api-versions：验证不同Kafka版本直接服务器与客户端的适配性</p>
</li>
<li><p>kafka-config：动态参数配置</p>
</li>
<li><p>kafka-console-consumer：消费组脚本</p>
<pre><code class="bash">bin/kafka-console-consumer.sh --bootstrap-server kafka-host:port --topic test-topic --group test-group --from-beginning --consumer-property enable.auto.commit=false 
#指定了 group 信息。如果没有指定的话，每次运行 Console Consumer，它都会自动生成一个新的消费者组来消费</code></pre>
</li>
<li><p>kafka-console-producer：生产者脚本</p>
<pre><code class="bash">bin/kafka-console-producer.sh --broker-list kafka-host:port --topic test-topic --request-required-acks -1 --producer-property compression.type=lz4
&gt;
#指定生产者参数 acks 为 -1，同时启用了 LZ4 的压缩算法。这个脚本可以很方便地让我们使用控制台来向 Kafka 的指定主题发送消息  </code></pre>
</li>
<li><p>kafka-producer-perf-test：生产者测试工具</p>
<pre><code class="bash">bin/kafka-producer-perf-test.sh --topic test-topic --num-records 10000000 --throughput -1 --record-size 1024 --producer-props bootstrap.servers=kafka-host:port acks=-1 linger.ms=2000 compression.type=lz4
#向指定主题发送了 1 千万条消息，每条消息大小是 1KB。</code></pre>
</li>
<li><p>kafka-consumer-perf-test：消费者测试工具</p>
<pre><code class="bash">bin/kafka-consumer-perf-test.sh --broker-list kafka-host:port --messages 10000000 --topic test-topic</code></pre>
</li>
<li><p>kafka-consumer-groups：查看消费组位移</p>
<pre><code class="bash">bin/kafka-consumer-groups.sh --bootstrap-server localhost:9092 --describe --group test-group</code></pre>
</li>
<li><p>kafka-dump-log：查看kafka消息文件内容，包含各自元数据信息</p>
<pre><code class="bash">$ bin/kafka-dump-log.sh --files ../data_dir/kafka_1/test-topic-1/00000000000000000000.log </code></pre>
</li>
<li><p>kafka-log-dirs：查询各个Broker上日志路线下的磁盘占用情况</p>
</li>
<li><p>kafka-mirror-maker：实现集群消息同步</p>
</li>
<li><p>kafka-preferred-replica-election：执行 Preferred Leader 选举的</p>
</li>
<li><p>kafka-reassign-partitions：执行分区副本迁移及副本文件路径迁移</p>
</li>
<li><p>kafka-topics：主题管理</p>
</li>
</ul>
<p>所有的脚本都可以用 –help来查看选项，比如<code>./kafka-console-consumer.sh --help</code></p>
]]></content>
      <categories>
        <category>Kafka</category>
      </categories>
  </entry>
  <entry>
    <title>shell scripting basics</title>
    <url>/2021/01/02/linux/2021_01_02-shell%E7%BC%96%E7%A8%8B/</url>
    <content><![CDATA[<h2 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h2><h3 id="运行例子"><a href="#运行例子" class="headerlink" title="运行例子"></a>运行例子</h3><p>test.sh</p>
<pre><code class="sh">#指定解释器
#! /bin/sh
#home
cd ~
#创建文件
mkdir shell_tut
cd shell_tut
# for loop create file
for((i=0; i&lt;10; i++))
do
    touch shell_$i.txt
done</code></pre>
<p>shell只有单行注释，如果要注释多行可以写成一个函数</p>
<p>运行test.sh</p>
<pre><code class="shell">#赋予执行权限
chmod test.sh
#运行脚本
./test.sh</code></pre>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><ul>
<li><p>定义</p>
<pre><code class="shell">your_name=&quot;lb&quot;</code></pre>
</li>
<li><p>变量种类</p>
<p><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</p>
<p><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</p>
<p><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</p>
</li>
<li><p>使用                </p>
<p>使用<code>$</code>来使用变量</p>
<pre><code class="shell">echo $your_name
echo $&#123;your_name&#125;
echo &quot;hello $&#123;your_name&#125;&quot;</code></pre>
<p>使用<code>&#123;&#125;</code>是为了和字符区分开来，避免有些特殊情况字符是连接在一起的（<code>echo $fileScript</code>变量file无法识别）</p>
<p>单引号和双引号的区别：</p>
<ul>
<li>单引号无法识别转换符，既只是单纯的<strong>字符串</strong>而已</li>
<li>双引号可以识别转换符</li>
</ul>
</li>
<li><p>只读变量</p>
<p>使用readonly命令</p>
<pre><code class="shell">#!/bin/sh
myUrl=&quot;http://baidu.com&quot;
readonly myUrl
myUrl=&quot;http://google.com&quot;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210103191601.png" alt="image-20210103191601854" loading="lazy"></p>
</li>
<li><p>删除变量</p>
<p>使用unset命令</p>
<pre><code class="shell">myUrl=&quot;http://baidu.com&quot;
echo $myUrl
unset myUrl
echo $myUrl</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210103191833.png" alt="image-20210103191833629" loading="lazy"></p>
</li>
<li><p>数据类型</p>
<p>shell只有数值和字符串这两种类型而已</p>
</li>
<li><p>数值运算(加法(+), 减法(-)，乘法（*），整除(/), 求余(%)四种运算)</p>
<pre><code class="shell">intv=1
intv=`expr $intv + 2`
echo $intv #3</code></pre>
</li>
<li><p>字符串操作</p>
<pre><code class="shell">#拼接字符串
greeting=&quot;hello, $&#123;your_name&#125;&quot;
#子字符串
string=&quot;hello, this is linux&quot;
#$&#123;var:pos:length&#125;
echo &quot;$&#123;string:1:4&#125;&quot;
#获取字符串长度
echo $&#123;#string&#125;
#查找子字符串expr命令
echo &quot;expr index $&#123;string&#125; is&quot;</code></pre>
</li>
</ul>
<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul>
<li><p>定义</p>
<pre><code class="shell">myarr=(value1, value2 value3...)</code></pre>
</li>
<li><p>读取</p>
<pre><code class="shell">$&#123;myarr[n]&#125; #n为下标
#get all
$&#123;myarr[@]&#125;</code></pre>
</li>
<li><p>获取长度</p>
<pre><code class="shell">#get total length
$&#123;#myarr[@]&#125;
#get single element length
$&#123;#myarr[n]&#125; #n:index</code></pre>
</li>
</ul>
<h3 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h3><p>shell可以向脚本里面传递参数 格式为<code>$n</code>，<code>$0</code>为执行的文件名，参数从<code>$1</code>开始知道<code>$n</code></p>
<pre><code class="sh">#!/bin/bash
echo &quot;Shell 传递参数实例！&quot;;
echo &quot;执行的文件名：$0&quot;;
echo &quot;第一个参数为：$1&quot;;
echo &quot;第二个参数为：$2&quot;;
echo &quot;第三个参数为：$3&quot;;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210103194109.png" alt="image-20210103194109053" loading="lazy"></p>
<ul>
<li><p>几个特殊参数</p>
<table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>$#</td>
<td>传递到脚本的参数个数</td>
</tr>
<tr>
<td>$*</td>
<td>以一个单字符串显示所有向脚本传递的参数。 如”$*”用「”」括起来的情况、以”$1 $2 … $n”的形式输出所有参数。</td>
</tr>
<tr>
<td>$$</td>
<td>脚本运行的当前进程ID号</td>
</tr>
<tr>
<td>$!</td>
<td>后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td>$@</td>
<td>与$*相同，但是使用时加引号，并在引号中返回每个参数。 如”$@”用「”」括起来的情况、以”$1” “$2” … “$n” 的形式输出所有参数。</td>
</tr>
<tr>
<td>$-</td>
<td>显示Shell使用的当前选项，与<a href="https://www.runoob.com/linux/linux-comm-set.html">set命令</a>功能相同。</td>
</tr>
<tr>
<td>$?</td>
<td>显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
<p><code>$*</code>和<code>$@</code>不同的是<code>$*</code>输出一个参数，而<code>$@</code>是多个</p>
</li>
</ul>
<h3 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h3><p>shell支持多种运算符</p>
<ul>
<li><p>算数运算符</p>
<p>使用expr命令来进行运算</p>
<pre><code class="shell">val=`expr 1 + 2`
val=$(expr 1 + 2) #t推荐使用这种</code></pre>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">+</td>
<td align="left">加法</td>
<td align="left"><code>expr $a + $b</code> 结果为 30。</td>
</tr>
<tr>
<td align="left">-</td>
<td align="left">减法</td>
<td align="left"><code>expr $a - $b</code> 结果为 -10。</td>
</tr>
<tr>
<td align="left">*</td>
<td align="left">乘法</td>
<td align="left"><code>expr $a \* $b</code> 结果为  200。</td>
</tr>
<tr>
<td align="left">/</td>
<td align="left">除法</td>
<td align="left"><code>expr $b / $a</code> 结果为 2。</td>
</tr>
<tr>
<td align="left">%</td>
<td align="left">取余</td>
<td align="left"><code>expr $b % $a</code> 结果为 0。</td>
</tr>
<tr>
<td align="left">=</td>
<td align="left">赋值</td>
<td align="left">a=$b 将把变量 b 的值赋给 a。</td>
</tr>
<tr>
<td align="left">==</td>
<td align="left">相等。用于比较两个数字，相同则返回 true。</td>
<td align="left">[ $a == $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">不相等。用于比较两个数字，不相同则返回 true。</td>
<td align="left">[ $a != $b ] 返回 true。</td>
</tr>
</tbody></table>
</li>
<li><p>关系运算符</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-eq</td>
<td align="left">检测两个数是否相等，相等返回 true。</td>
<td align="left">[ $a -eq $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-ne</td>
<td align="left">检测两个数是否不相等，不相等返回 true。</td>
<td align="left">[ $a -ne $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-gt</td>
<td align="left">检测左边的数是否大于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -gt $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-lt</td>
<td align="left">检测左边的数是否小于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -lt $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-ge</td>
<td align="left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -ge $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">-le</td>
<td align="left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td>
<td align="left">[ $a -le $b ] 返回 true。</td>
</tr>
</tbody></table>
</li>
<li><p>布尔运算符</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">!</td>
<td align="left">非运算，表达式为 true 则返回 false，否则返回 true。</td>
<td align="left">[ ! false ] 返回 true。</td>
</tr>
<tr>
<td align="left">-o</td>
<td align="left">或运算，有一个表达式为 true 则返回 true。</td>
<td align="left">[ $a -lt 20 -o $b -gt 100 ] 返回 true。</td>
</tr>
<tr>
<td align="left">-a</td>
<td align="left">与运算，两个表达式都为 true 才返回 true。</td>
<td align="left">[ $a -lt 20 -a $b -gt 100 ] 返回 false。</td>
</tr>
</tbody></table>
</li>
<li><p>字符串运算符</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">=</td>
<td align="left">检测两个字符串是否相等，相等返回 true。</td>
<td align="left">[ $a = $b ] 返回 false。</td>
</tr>
<tr>
<td align="left">!=</td>
<td align="left">检测两个字符串是否相等，不相等返回 true。</td>
<td align="left">[ $a != $b ] 返回 true。</td>
</tr>
<tr>
<td align="left">-z</td>
<td align="left">检测字符串长度是否为0，为0返回 true。</td>
<td align="left">[ -z $a ] 返回 false。</td>
</tr>
<tr>
<td align="left">-n</td>
<td align="left">检测字符串长度是否不为 0，不为 0 返回 true。</td>
<td align="left">[ -n “$a” ] 返回 true。</td>
</tr>
<tr>
<td align="left">$</td>
<td align="left">检测字符串是否为空，不为空返回 true。</td>
<td align="left">[ $a ] 返回 true。</td>
</tr>
</tbody></table>
</li>
<li><p>文件测试运算符</p>
<table>
<thead>
<tr>
<th align="left">操作符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-b file</td>
<td align="left">检测文件是否是块设备文件，如果是，则返回 true。</td>
<td align="left">[ -b $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-c file</td>
<td align="left">检测文件是否是字符设备文件，如果是，则返回 true。</td>
<td align="left">[ -c $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-d file</td>
<td align="left">检测文件是否是目录，如果是，则返回 true。</td>
<td align="left">[ -d $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-f file</td>
<td align="left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td>
<td align="left">[ -f $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-g file</td>
<td align="left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td>
<td align="left">[ -g $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-k file</td>
<td align="left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td>
<td align="left">[ -k $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-p file</td>
<td align="left">检测文件是否是有名管道，如果是，则返回 true。</td>
<td align="left">[ -p $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-u file</td>
<td align="left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td>
<td align="left">[ -u $file ] 返回 false。</td>
</tr>
<tr>
<td align="left">-r file</td>
<td align="left">检测文件是否可读，如果是，则返回 true。</td>
<td align="left">[ -r $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-w file</td>
<td align="left">检测文件是否可写，如果是，则返回 true。</td>
<td align="left">[ -w $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-x file</td>
<td align="left">检测文件是否可执行，如果是，则返回 true。</td>
<td align="left">[ -x $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-s file</td>
<td align="left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td>
<td align="left">[ -s $file ] 返回 true。</td>
</tr>
<tr>
<td align="left">-e file</td>
<td align="left">检测文件（包括目录）是否存在，如果是，则返回 true。</td>
<td align="left">[ -e $file ] 返回 true。</td>
</tr>
</tbody></table>
</li>
<li><p>逻辑运算符</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">说明</th>
<th align="left">举例</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">逻辑的 AND</td>
<td align="left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">逻辑的 OR</td>
<td align="left">[[ $a -lt 100 || $b -gt 100 ]] 返回 true</td>
</tr>
</tbody></table>
</li>
</ul>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p><strong>[] 表达式</strong></p>
<p><strong>注意</strong>：在 [] 表达式中，常见的 &gt;, &lt; 需要加转义字符，表示字符串大小比较，以 acill 码位置作为比较。不直接支持 &gt;, &lt; 运算符，还有逻辑运算符 || 、&amp;&amp; ，它需要用 -a[and] –o[or] 表示。</p>
<p><strong>[[ ]] 表达式</strong></p>
<p><strong>注意</strong>：[[]] 运算符只是 [] 运算符的扩充。能够支持 &gt;, &lt; 符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：**|| &amp;&amp;** ，不再使用 <strong>-a -o</strong>。</p>
<h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><h4 id="if语句"><a href="#if语句" class="headerlink" title="if语句"></a>if语句</h4><p>语法格式</p>
<pre><code class="shell">if condition 
then
    command1
    command2
    ...
else
    command
fi
#如果else没有任何命令就不要写，这个和编程语言不一样
#复杂一点的
if condition
then
    command1
elif condition
    command2
else 
    commandN
fi</code></pre>
<p>实例</p>
<pre><code class="shell">if [ $(ps -ef | grep -c ssh) -gt 1 ]
then
    echo &quot;true&quot;
else
    echo &quot;false&quot;
fi</code></pre>
<p>还可以搭配test命令使用</p>
<pre><code class="shell">if test $(ps -ef | grep -c ssh) -gt 1
then
    echo &quot;true&quot;
else
    echo &quot;false&quot;
fi</code></pre>
<h4 id="for语句"><a href="#for语句" class="headerlink" title="for语句"></a>for语句</h4><p>语法</p>
<pre><code class="shell">for var in item1 item2... itemN
do
    command1
    command2
    ....
done

#c风格的for
for((exp1; exp2; exp3)) 
do
    command1
    coommand2
    ...
done</code></pre>
<p>实例</p>
<pre><code class="shell">for loop in 1 2 3 4 5 6
do
    echo &quot;this value: $loop&quot;
done</code></pre>
<h4 id="while语句"><a href="#while语句" class="headerlink" title="while语句"></a>while语句</h4><p>语法</p>
<pre><code class="shell">while condition
do
    command1
    command2
    ...
done

#c风格
while ((condition))
do
    command1
    command2
    ...
done</code></pre>
<p>实例</p>
<pre><code class="shell">intv=1
while(($intv&lt;3))
do
    echo $intv
    intv=`expr $intv + 1 `
done</code></pre>
<h4 id="case语句"><a href="#case语句" class="headerlink" title="case语句"></a>case语句</h4><p>语法</p>
<pre><code class="shell">case 值 in 
模式1)
    command1
    command2
    command3
    ...
    ;;
模式2)
command1
    command2
    command3
    ...
    ;;
esac
#每个值后面要跟右括号，命令结束要用两个;;结束</code></pre>
<p>实例</p>
<pre><code class="shell">echo &quot;input number&quot;

read num

case $num in
1)
    echo &quot;you input 1&quot;
    ;;
2)
    echo &quot;you input 2&quot;
    ;;
*)
    echo &quot;you input other&quot;
    ;;
esac</code></pre>
<h4 id="跳出循环"><a href="#跳出循环" class="headerlink" title="跳出循环"></a>跳出循环</h4><ul>
<li><p>break命令(跳出循环)</p>
<pre><code class="shell">#!/bin/bash
while :
do
    echo -n &quot;输入 1 到 5 之间的数字:&quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;
            break
        ;;
    esac
done
</code></pre>
</li>
<li><p>continu命令（结束本次循环）</p>
<pre><code class="shell">#!/bin/bash
while :
do
    echo -n &quot;输入 1 到 5 之间的数字: &quot;
    read aNum
    case $aNum in
        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;
        ;;
        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;
            continue
            echo &quot;游戏结束&quot;
        ;;
    esac
done</code></pre>
</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><ul>
<li><p>定义</p>
<pre><code class="shell">[ function ] funname [()]

&#123;

    action;

    [return int;]

&#125;</code></pre>
<p>return 返回值为：0-255</p>
</li>
<li><p>获取返回值</p>
<p>在执行完函数之后使用<code>$?</code>来获取</p>
<p>注意：<code>$?</code>仅对上一条指令负责，如果没有取值那么就会被override</p>
</li>
<li><p>参数</p>
<p>在调用函数时可以向其传递参数</p>
<pre><code class="shell">demoFun 1 2 3 4 5 6</code></pre>
<p>在函数内读取参数使用<code>$n</code>来读取,从第十个参数开始就需要使用<code>$&#123;n&#125;</code>来读取了</p>
</li>
<li><p>其他参数补充</p>
<table>
<thead>
<tr>
<th align="left">参数处理</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$#</td>
<td align="left">传递到脚本或函数的参数个数</td>
</tr>
<tr>
<td align="left">$*</td>
<td align="left">以一个单字符串显示所有向脚本传递的参数</td>
</tr>
<tr>
<td align="left">$$</td>
<td align="left">脚本运行的当前进程ID号</td>
</tr>
<tr>
<td align="left">$!</td>
<td align="left">后台运行的最后一个进程的ID号</td>
</tr>
<tr>
<td align="left">$@</td>
<td align="left">与$*相同，但是使用时加引号，并在引号中返回每个参数。</td>
</tr>
<tr>
<td align="left">$-</td>
<td align="left">显示Shell使用的当前选项，与set命令功能相同。</td>
</tr>
<tr>
<td align="left">$?</td>
<td align="left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td>
</tr>
</tbody></table>
</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux base konwledge</title>
    <url>/2021/02/13/linux/2021_02_13-%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h1 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h1><h3 id="为什么要学Linux"><a href="#为什么要学Linux" class="headerlink" title="为什么要学Linux"></a>为什么要学Linux</h3><p> 在服务器端，在开发领域Linux是越来越受欢迎，很多程序员都觉得不懂点Linux都觉得不好意思，Linux在开源社区的地位依然岿然不动。<br> 尤其是作为一个后端程序员，是必须要掌握Linux的，因为这都成为了你找工作的基础门槛了，所以不得不学习！</p>
<h3 id="Linux简介"><a href="#Linux简介" class="headerlink" title="Linux简介"></a>Linux简介</h3><p> Linux内核最初只是由芬兰人林纳斯.托瓦兹( Linus Torvalds )在赫尔辛基大学上学时出于个人爱好而编写的。<br> Linux是一套免费使用和自由传播的<strong>类Unix操作系统</strong>,是一个基于POSIX (可移植操作系统接口)和UNIX的<strong>多用户</strong>、<strong>多任务</strong>、支持<strong>多线程</strong>和<strong>多CPU</strong>的操作系统。<br> Linux<strong>能运行主要的UNIX工具软件、应用程序和网络协议</strong>。它支持32位和64位硬件。Linux 继承了Unix以<strong>网络为核心</strong>的设计思想，是一个性能稳定的多用户网络操作系统。</p>
<h3 id="Linux发行版"><a href="#Linux发行版" class="headerlink" title="Linux发行版"></a>Linux发行版</h3><p>发行版就是将Linux内核与应用软件做一个打包<br><img src="https://raw.githubusercontent.com/soda1/img/main/20210213183101.png" loading="lazy"></p>
<p>​                                                                                                                        图 版本图解</p>
<h3 id="Linux应用领域"><a href="#Linux应用领域" class="headerlink" title="Linux应用领域"></a>Linux应用领域</h3><p> 今天各种场合都有使用各种Linux发行版,从嵌入式设备到超级计算机,并且在服务器领域确定了地位,通常服务器使用LAMP(Linux + Apache + MySQL + PHP)或LNMP(Linux + Nginx + MySQL + PHP)组合。<br> 目前Linux不仅在家庭与企业中使用,并且在政府中也很受欢迎。<br> 许多国家都在使用Linux系统</p>
<h3 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h3><p>跳过<br>环境：虚拟机VMware Workstation Pro 15.2+CentOS 7</p>
<h3 id="走近Linux系统"><a href="#走近Linux系统" class="headerlink" title="走近Linux系统"></a>走近Linux系统</h3><h4 id="开机"><a href="#开机" class="headerlink" title="开机"></a>开机</h4><p>会启动许多程序。它们在Windows叫做’服务” ( service ) , **在Linux就叫做”守护进程” ( daemon)**。<br>一般来说，用户的登录方式有三种:<br> ●命令行登录<br> ●SSH登录(远程)<br> ●图形界面登录<br> 最高权限账户为root,可以操作一切!</p>
<h4 id="关机"><a href="#关机" class="headerlink" title="关机"></a>关机</h4><p> 在linux领域内大多用在服务器上,很少遇到关机的操作。毕竟服务器上跑一个服务是永无止境的,除非特殊情况下,不得已才会关机。<br> 关机指令为shutdown</p>
<pre><code class="bash">sync #将数据由内存同步到硬盘中。
shutdown #关机指令，你可以man shutdown 来看一下 帮助文档。例如你可以运行如下命令关机:
shutdown -h 10 #这个命令告诉大家，计算机将在10分钟后关机
shutdown -h now#立马关机
shutdown -h 20:25 #系统会在今天20:25关机
shutdown -h +10 #十分钟后关机
shutdown -r now #系统立马重启
shutdown -r +10 #系统十分钟后重启
reboot #就是重启，等同于shutdown -r now
halt #关闭系统，等同于shutdown -h now和poweroff</code></pre>
<p> 最后总结：不管是重启还是关闭系统，首先要运行sync命令，把内存中的数据写到磁盘中，执行命令之后没有返回消息则表明运行成功</p>
<h4 id="系统目录"><a href="#系统目录" class="headerlink" title="系统目录"></a>系统目录</h4><p>1、一切皆文件<br>2、根目录/ ,所有的文件都挂载在这个节点下</p>
<pre><code class="bash">ls / #查看当前下的目录
1</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200630084025462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 树状目录结构</p>
<h2 id="目录解释"><a href="#目录解释" class="headerlink" title="目录解释"></a>目录解释</h2><table>
<thead>
<tr>
<th></th>
<th></th>
</tr>
</thead>
<tbody><tr>
<td>/bin</td>
<td>bin是Binary的缩写, 这个目录存放着最经常使用的命令</td>
</tr>
<tr>
<td>/boot</td>
<td>这里存放的是启动Linux时使用的一些核心文件，包括一些连接文件以及镜像文件</td>
</tr>
<tr>
<td>/dev</td>
<td>dev是Device(设备)的缩写, 存放的是Linux的外部设备，在Linux中访问设备的方式和访问文件的方式是相同的</td>
</tr>
<tr>
<td>/etc</td>
<td>这个目录用来存放所有的系统管理所需要的配置文件和子目录</td>
</tr>
<tr>
<td>/home</td>
<td>用户的主目录，在Linux中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的</td>
</tr>
<tr>
<td>/lib</td>
<td>这个目录里存放着系统最基本的动态连接共享库，其作用类似于Windows里的DLL文件</td>
</tr>
<tr>
<td>/lost+found</td>
<td>这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件</td>
</tr>
<tr>
<td>/media</td>
<td>linux系统会自动识别一些设备，例如U盘、光驱等等，当识别后，linux会把识别的设备挂载到这个目录下</td>
</tr>
<tr>
<td>/mnt</td>
<td>系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在/mnt/上，然后进入该目录就可以查看光驱里的内容了</td>
</tr>
<tr>
<td>/opt</td>
<td>这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的</td>
</tr>
<tr>
<td>/proc</td>
<td>这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息</td>
</tr>
<tr>
<td>/root</td>
<td>该目录为系统管理员，也称作超级权限者的用户主目录</td>
</tr>
<tr>
<td>/sbin</td>
<td>s就是Super User的意思，这里存放的是系统管理员使用的系统管理程序</td>
</tr>
<tr>
<td>/srv</td>
<td>该目录存放一些服务启动之后需要提取的数据</td>
</tr>
<tr>
<td>/sys</td>
<td>这是linux2.6内核的一个很大的变化。该目录下安装了2.6内核中新出现的一个文件系统 sysfs</td>
</tr>
<tr>
<td>/tmp</td>
<td>这个目录是用来存放一些临时文件的。 用完即丢的文件可以放在这个目录下</td>
</tr>
<tr>
<td>/usr</td>
<td>这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于windows下的program files目录</td>
</tr>
<tr>
<td>/usr/bin</td>
<td>系统用户使用的应用程序</td>
</tr>
<tr>
<td>/usr/sbin</td>
<td>超级用户使用的比较高级的管理程序和系统守护程序</td>
</tr>
<tr>
<td>/usr/src</td>
<td>内核源代码默认的放置目录</td>
</tr>
<tr>
<td>/var</td>
<td>这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件</td>
</tr>
<tr>
<td>/run</td>
<td>是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除</td>
</tr>
<tr>
<td>/www</td>
<td>存放服务器网站相关的资源，环境，网站的项目</td>
</tr>
</tbody></table>
<h1 id="常用的基本命令"><a href="#常用的基本命令" class="headerlink" title="常用的基本命令"></a>常用的基本命令</h1><h2 id="cd-切换目录"><a href="#cd-切换目录" class="headerlink" title="cd:切换目录"></a>cd:切换目录</h2><pre><code class="bash">cd:#切换目录命令!
./:#当前目录
/:#绝对路径
cd..:#返回上一级目录
cd ~:#回到当前的用户目录
pwd :#显示当前用户所在的目录
</code></pre>
<p><img src="https://img-blog.csdnimg.cn/20200630084914110.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 pwd展示</p>
<h2 id="ls-列出目录！"><a href="#ls-列出目录！" class="headerlink" title="ls(列出目录！)"></a>ls(列出目录！)</h2><p>在Linux中Is可能是最常常被使用的!</p>
<pre><code class="bash">-a:#参数: all ,查看全部的文件,包括隐藏文件
-l:#参数列出所有的文件,包含文件的属性和权限,没有隐藏文件
12</code></pre>
<p>所有Linux可以组合使用!</p>
<pre><code class="bash">ls -al 查看全部的文件包括隐藏文件的属性和权限
1</code></pre>
<h2 id="mkdir-创建一个目录"><a href="#mkdir-创建一个目录" class="headerlink" title="mkdir 创建一个目录"></a>mkdir 创建一个目录</h2><pre><code class="bash">mkdir -p test2/test3/test4 # 用-p递归创建层级目录
1</code></pre>
<h2 id="rmdir-删除目录"><a href="#rmdir-删除目录" class="headerlink" title="rmdir 删除目录"></a>rmdir 删除目录</h2><pre><code class="bash">rmdir -p test2/test3/test4 #递归删除文件
1</code></pre>
<p>rmdir仅能删除空的目录,如果下面存在文件,需要先删除文件,递归删除多个目录-p参数即可</p>
<h2 id="cp-复制文件或者目录"><a href="#cp-复制文件或者目录" class="headerlink" title="cp(复制文件或者目录)"></a>cp(复制文件或者目录)</h2><pre><code class="bash">cp install.sh cqhstudy #将当前目录下的install.sh 复制到cqhstudy文件夹中
1</code></pre>
<h2 id="rm-移除文件或者目录"><a href="#rm-移除文件或者目录" class="headerlink" title="rm 移除文件或者目录"></a>rm 移除文件或者目录</h2><pre><code class="bash">-f #忽略不存在的文件,不会出现警告,强制删除!
-r #递归删除目录!
-i #互动,删除询问是否删除
rm -rf install.sh/#删除系统中的install.sh
1234</code></pre>
<h2 id="mv-移动文件或者目录-重命名文件"><a href="#mv-移动文件或者目录-重命名文件" class="headerlink" title="mv 移动文件或者目录|重命名文件"></a>mv 移动文件或者目录|重命名文件</h2><pre><code class="bash">-f #强制
-u #只替换已经更新过的文件
mv install.sh cqhstudy #移动文件
mv cqhstudy cqhstudy2 #重命名文件夹名</code></pre>
<h2 id="chmod-修改文件权限"><a href="#chmod-修改文件权限" class="headerlink" title="chmod 修改文件权限"></a>chmod 修改文件权限</h2><pre><code class="sh">#所有人读写运行此文件
chmod 777 file_name </code></pre>
<h2 id="chown-修改文件所属用户-组"><a href="#chown-修改文件所属用户-组" class="headerlink" title="chown 修改文件所属用户/组"></a>chown 修改文件所属用户/组</h2><pre><code class="sh">chown -c user:group file_name</code></pre>
<h1 id="基本属性"><a href="#基本属性" class="headerlink" title="基本属性"></a>基本属性</h1><p> Linux系统是一种典型的多用户系统,不同的用户处于不同的地位,拥有不同的权限。为了保护系统的安全性, Linux系统对不同的用户访问同一文件(包括目录文件)的权限做了不同的规定。<br> 在Linux中我们可以使用ll或者ls -l命令来显示一个文件的属性以及文件所属的用户和组,如:<br> 实例中, boot文件的第一个属性用”d”表示。 “d”在Linux中代表该文件是一 个目录文件。<br> 在Linux中第一个字符代表这个文件是目录、 文件或链接文件等等:<br> ●当为[d]则是目录<br> ●当为[-]则是文件;<br> ●若是[l]则表示为链接文档( link file);<br> ●若是[b]则表示为装置文件里面的可供储存的接口设备(可随机存取装置) ;<br> ●若是[c]则表示为装置文件里面的串行端口设备,例如键盘、鼠标( 一次性读取装置)。<br> 接下来的字符中,以三个为一组,且均为[rwx] 的三个参数的组合。<br> 其中，[r]代表可读(read)、[w]代表可写(write)、[x]代表可执行(execute)。<br> 要注意的是,这三个权限的位置不会改变,如果没有权限,就会出现减号[-]而已。<br> 每个文件的属性由左边第一部分的10个字符来确定 (如下图) :<br><img src="https://img-blog.csdnimg.cn/20200630091157920.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L29rRm9ycmVzdDI3,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 属性图解</p>
<p>从左至右用0-9这些数字来表示。<br>第0位确定文件类型,第1-3位确定属主(该文件的所有者)拥有该文件的权限。第4-6位确定属组 (所有者的同组用户)拥有该文件的权限,第7-9位确定其他用户拥有该文件的权限。<br>其中:<br>第1、4、7位表示读权限,如果用”r”字符表示,则有读权限,如果用”-“字符表示,则没有读权限;<br>第2、5、8位表示写权限,如果用”W”字符表示,则有写权限,如果用”-“字符表示没有写权限;<br>第3、6、9位表示可执行权限,如果用”x”字符表示,则有执行权限,如果用”-“字符表示,则没有执行权限。<br>对于文件来说,它都有一个特定的所有者,也就是对该文件具有所有权的用户。<br>同时,在Linux系统中,用户是按组分类的, - -个用户属于一个或多个组。<br>文件所有者以外的用户又可以分为文件所有者的同组用户和其他用户。<br><strong>因此, Linux系统按文件所有者、文件所有者同组用户和其他用户来规定了不同的文件访问权限。</strong><br>在以上实例中, boot文件是一个目录文件,属主和属组都为root。<br><img src="https://raw.githubusercontent.com/soda1/img/main/20210214160208.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 图解</p>
<h2 id="修改文件属性"><a href="#修改文件属性" class="headerlink" title="修改文件属性"></a>修改文件属性</h2><p>1、chgrp :更改文件属组</p>
<pre><code class="bash">chgrp [-R] 属组名文件名
1</code></pre>
<p>-R :递归更改文件属组,就是在更改某个目录文件的属组时,如果加上R的参数,那么该目录下的所有文件的属组都会更改。<br>2、chown :更改文件属主,也可以同时更改文件属组</p>
<pre><code class="bash">chown [-R] 属主名文件名
chown [-R] 属主名:属组名文件名
12</code></pre>
<p>3、chmod :更改文件9个属性</p>
<pre><code class="bash">chmod [-R] xyz 文件或目录
1</code></pre>
<p>Linux文件属性有两种设置方法,一种是数字（常用的是数字）, 一种是符号。<br>Linux文件的基本权限就有九个,分别是owner/group/others三种身份各有自己的read/write/execute权限。<br>先复习一下刚刚上面提到的数据:文件的权限字符为: [-rwxrwxrwx]，这九个权限是三个三个一组的!其中,我们可以使用字来代表各个权限,各权限的分数对照表如下:<br>r:4 w:2 x:1<br>可读可写不可执行 rw- 6<br>可读可写可执行 rwx 7<br>chomd 777 文件赋予所有用户可读可执行!<br><img src="https://raw.githubusercontent.com/soda1/img/main/20210214160230.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 示例</p>
<h2 id="文件内容查看"><a href="#文件内容查看" class="headerlink" title="文件内容查看"></a>文件内容查看</h2><p>Linux系统中使用以下命令来查看文件的内容:<br>●cat由第一行开始显示文件内容<br>●tac从最后一行开始显示，可以看出tac是cat的倒着写!<br><img src="https://raw.githubusercontent.com/soda1/img/main/20210214160251.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 cat和tac图解</p>
<p>●nl显示的时候,顺道输出行号!<br><img src="https://raw.githubusercontent.com/soda1/img/main/20210214160312.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 nl命令图解</p>
<p>●more一页一页的显示文件内容（空格表示翻页，enter代表向下看下一行）<br><img src="https://img-blog.csdnimg.cn/20200630092344102.png#pic_center" alt="在这里插入图片描述" loading="lazy"><br><img src="https://raw.githubusercontent.com/soda1/img/main/20210214160329.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 more命令图解</p>
<p><strong>●less与more类似,但是比more更好的是,他可以往前翻页!（空格翻页，上下键代表上下翻动页面，退出q命令，查找字符串/要查询的字符向下查询，向上查询使用?要查询的字符串,用n继续搜寻下一个,用N向上寻找）</strong><br>●head 只看头几行 通过-n参数来控制显示几行<br>●tail只看尾巴几行 通过-n参数来控制显示几行<br>你可以使用man 命令来查看各个命令的使用文档,如: man [命令]。</p>
<h2 id="网络配置目录"><a href="#网络配置目录" class="headerlink" title="网络配置目录:"></a>网络配置目录:</h2><pre><code class="bash">cd /etc/ sysconfig/network-scripts
1</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210214160349.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 网络基础配置</p>
<pre><code class="bash">ping #用来查看网络是否连通
ifconfig #查看网络 和Windows的ipconfig是一样的
12</code></pre>
<h1 id="硬链接和软链接"><a href="#硬链接和软链接" class="headerlink" title="硬链接和软链接"></a>硬链接和软链接</h1><p>Linux链接分为两种：硬链接、软链接<br><strong>硬链接：A—B,假设B是A的硬链接，那么他们两个指向了同一个文件!允许一个文件拥有多个路径，用户可以通过这种机制硬链接到一个重要文件上，防止误删</strong><br><strong>软链接：类似Windows下的快捷方式，删除源文件，快捷方式也就访问不</strong>了<br>操作步骤：<br>创建链接 ln命令！<br>touch命令创建文件！<br>echo输入字符串<br><img src="https://raw.githubusercontent.com/soda1/img/main/20210214160405.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 图解</p>
<p>删除f1之后，查看f2和f3的区别<br><img src="https://raw.githubusercontent.com/soda1/img/main/20210214160420.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 删除f1之后 f2和f3的区别</p>
<h1 id="Vim编辑器"><a href="#Vim编辑器" class="headerlink" title="Vim编辑器"></a>Vim编辑器</h1><h2 id="什么是Vim编辑器"><a href="#什么是Vim编辑器" class="headerlink" title="什么是Vim编辑器"></a>什么是Vim编辑器</h2><p> Vim通过一些插件可以实现和IDE的功能!<br> Vim是从Vi发展出来的一个文本编辑器。代码补完、编译及错误跳转等方便编程的功能特别丰富,在程序员中被广泛使用。尤其是Linux中,必须要会使用Vim (查看内容, 编辑内容,保存内容! )<br> 简单的来说，Vi是老式的字处理器,不过功能已经很齐全了,但是还是有可以进步的地方。<br> Vim则可以说是程序开发者的一项很好用的工具。<br>三种使用方式:<br>基本上Vi/Vim共分为三种模式,分别是<br><strong>命令模式( Command mode) ,<br>输入模式( Insert mode )和<br>底线命令模式( Lastline mode )。</strong><br>这三种模式的作用分别是:</p>
<h2 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h2><p>用户刚刚启动Vi/Vim ,便进入了命令模式。<br>此状态下敲击键盘动作会被Vim识别为命令,而非输入字符。比如我们此时按下i ,并不会输入一个字符, i被当作了一个命令。<br>以下是常用的几个命令:<br>●i切换到输入模式,以输入字符。<br>●x删除当前光标所在处的字符。<br>●:切换到底线命令模式,以在最底一行输入命令。<br>若想要编辑文本:启动Vim,进入了命令模式,按下i,切换到输入模式。<br>命令模式只有一些最基本的命令,因此仍要依靠底线命令模式输入更多命令。</p>
<h2 id="输入模式"><a href="#输入模式" class="headerlink" title="输入模式"></a>输入模式</h2><p>在命令模式下按下i就进入了输入模式。<br>在输入模式中，可以使用以下按键：</p>
<ul>
<li>字符按键以及Shift组合，输入字符</li>
<li>ENTER，回车键，换行</li>
<li>BACK SPACE，退格键，删除光标前一个字</li>
<li>DEL，删除键，删除光标后一个字符</li>
<li>方向键，在文本中移动光标</li>
<li>HOME/END，移动光标到行首/行尾</li>
<li>Page Up/Page Down，上/下翻页</li>
<li>Insert，切换光标为输入/替换模式，光标将变成竖线/下划线</li>
<li>ESC，退出输入模式，切换到命令模式</li>
</ul>
<h2 id="底线命令模式"><a href="#底线命令模式" class="headerlink" title="底线命令模式"></a>底线命令模式</h2><p>在命令模式下按下:（英文冒号）就进入了底线命令模式。<br>底线命令模式可以输入单个或多个字符的命令，可用的命令非常多。<br>在底线命令模式中，基本的命令有（已经省略了冒号）：<br>q 退出程序<br>w 保存文件<br>按ESC键可随时退出底线命令模式。</p>
<h1 id="账号管理"><a href="#账号管理" class="headerlink" title="账号管理"></a>账号管理</h1><p> Linux系统是一个多用户多任务的分时操作系统,任何一个要使用系统资源的用户,都必须首先向系统管理员申请一个账号,然后以这个账号的身份进入系统。<br> 用户的账号一方面可以帮助系统管理员对使用系统的用户进行跟踪,并控制他们对系统资源的访问;另一方面也可以帮助用户组织文件,并为用户提供安全性保护。<br> 每个用户账号都拥有一个唯一的用户名和各自的口令。<br> 用户在登录时键入正确的用户名和口令后,就能够进入系统和自己的主目录。<br> 实现用户账号的管理,要完成的工作主要有如下几个方面:<br> ●用户账号的添加、删除与修改。<br> ●用户口令的管理。<br> ●用户组的管理。</p>
<h1 id="用户账号的管理"><a href="#用户账号的管理" class="headerlink" title="用户账号的管理"></a>用户账号的管理</h1><p> 用户账号的管理工作主要涉及到用户账号的添加、修改和删除。<br> 添加用户账号就是在系统中创建一个新账号,然后为新账号分配用户号、用户组、主目录和登录ShelI等资源。</p>
<h2 id="useradd-命令-添加用户"><a href="#useradd-命令-添加用户" class="headerlink" title="useradd 命令 添加用户"></a>useradd 命令 添加用户</h2><p>useradd -选项 用户名<br>-m:自动创建这个用户的主目录/home/cqh<br>-G:给用户分配组</p>
<pre><code class="bash">[root@cqh home]useradd -m cqh  #创建一个用户
[root@cqh home]ls
install.sh cqhstudy cqh www  
123</code></pre>
<p>理解一下本质: Linux中一切皆文件,这里的添加用户说白了就是往某-个文件中写入用户的信息了! /etc/passwd</p>
<pre><code class="bash">[root@cqh home]cat /etc/passwd  #创建一个用户
cqh:x:1002:1002::/home/cqh:/bin/bash
12</code></pre>
<h2 id="删除用户-userdel"><a href="#删除用户-userdel" class="headerlink" title="删除用户 userdel"></a>删除用户 userdel</h2><pre><code class="bash">userdel -r cqh #删除用户的时候把它的目录也删除掉
1</code></pre>
<h2 id="修改用户-usermod"><a href="#修改用户-usermod" class="headerlink" title="修改用户 usermod"></a>修改用户 usermod</h2><p>对应修改的内容 修改那个用户</p>
<pre><code class="bash">[root@cqh home]usermod -d /home/233 cqh
1</code></pre>
<p>修改完毕后查看配置文件 将cqh用户下的目录修改为233</p>
<h4 id="用户添加组"><a href="#用户添加组" class="headerlink" title="用户添加组"></a>用户添加组</h4><pre><code class="bash">usermod -a group username
# -a 追加组
# -g 作为登录初始化组
# -G 添加多个组，如果添加组时没有-a选项，那么用户就只会在新添加的这几个组里面，先前的组会没有该用户</code></pre>
<h4 id="删除用户所在组"><a href="#删除用户所在组" class="headerlink" title="删除用户所在组"></a>删除用户所在组</h4><pre><code class="bash">gpasswd -d  user group #只能一个一个组删除
#或者可以使用usermod -G来删除不需要的追加组</code></pre>
<h2 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h2><p><img src="https://raw.githubusercontent.com/soda1/img/main/20210217143723.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 细节说明</p>
<p>1.切换用户的命令为: su username [username是你的用户名]<br><img src="https://raw.githubusercontent.com/soda1/img/main/20210217143807.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 切换后的细节</p>
<p>2.从普通用户切换到root用户,还可以使用命令: sudo su<br>3.在终端输入exit或logout或使用快捷方式ctrl+d ,可以退回到原来用户,其实ctrl+d也是执行的exit命令<br>4.在切换用户时,如果想在切换用户之后使用新用户的工作环境,可以在su和username之间加,例如: [su- root]<br>$表示普通用户，#表示超级用户,也就是root用户</p>
<h2 id="用户的密码设置问题"><a href="#用户的密码设置问题" class="headerlink" title="用户的密码设置问题"></a>用户的密码设置问题</h2><p>我们一般通过root创建用户的时候!要配置密码!<br>如果是超级用户</p>
<pre><code class="bash">passwd username 
new password #新密码
re password #修改密码</code></pre>
<p>普通用户</p>
<pre><code class="bash">passwd
(current)UNIX password:
new password: #密码不能过于简单
re password:</code></pre>
<p>锁定账户<br>root ,比如张三辞职了!冻结这个账号, 一旦冻结,这个人就登录不上系统了!</p>
<pre><code class="bash">passwd -l cqh #锁定之后这个用户就不能再登录了
passwd -d cqh #把密码清空 这样也能防止用户登录
passwd -s cqh #检查用户状态
passwd -u cql #解锁用户</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210217144705.png" alt="在这里插入图片描述" loading="lazy"></p>
<h1 id="用户组管理"><a href="#用户组管理" class="headerlink" title="用户组管理"></a>用户组管理</h1><p> 属主、属组<br> 每个用户都有一个用户组,系统可以对一个用户组中的所有用户进行集中管理(开发、测试、运维)。不同Linux 系统对用户组的规定有所不同,如Linux下的用户属于与它同名的用户组,这个用户组在创建用户时同时创建。<br> 用户组的管理涉及用户组的添加、删除和修改。组的增加、删除和修改实际上就是对/etc/group文件的更新。</p>
<h2 id="创建一个用户组-groupadd"><a href="#创建一个用户组-groupadd" class="headerlink" title="创建一个用户组 groupadd"></a>创建一个用户组 groupadd</h2><pre><code class="bash">[root@cqh ~]groupadd cqh
[root@cqh ~]cat /etc/group</code></pre>
<p>创建完用户组后可以得到一一个组的id ,这个id是可以指定的! -g 520， 若果不指定就是自增1</p>
<h2 id="删除用户组-groupdel"><a href="#删除用户组-groupdel" class="headerlink" title="删除用户组 groupdel"></a>删除用户组 groupdel</h2><pre><code class="bash">[root@cqh ~]groupdel cqh
[root@cqh ~]cat /etc/group</code></pre>
<h2 id="修改用户组的权限和名字-groupmod-g-n"><a href="#修改用户组的权限和名字-groupmod-g-n" class="headerlink" title="修改用户组的权限和名字 groupmod -g-n"></a>修改用户组的权限和名字 groupmod -g-n</h2><pre><code class="bash">cqh:x:1003
[root@cqh ~]groupmod -g 666 -n newcqh cqh #修改cqh用户组id为666 重命名为newcqh </code></pre>
<h2 id="用户切换用户组"><a href="#用户切换用户组" class="headerlink" title="用户切换用户组"></a>用户切换用户组</h2><pre><code class="bash">#当前登录用户 cqh
$ newgrp root #切换为root
12</code></pre>
<h2 id="拓展-用户账户文件的查看-了解即可-etc-passwd"><a href="#拓展-用户账户文件的查看-了解即可-etc-passwd" class="headerlink" title="拓展 用户账户文件的查看(了解即可) /etc/passwd"></a>拓展 用户账户文件的查看(了解即可) /etc/passwd</h2><p> 用户名:口令(登录密码，我们不可见) :用户标识号:组标识号:注释性描述:主目录:登录She11<br>这个文件中的每一行都代表这一用户,我们可以从这里看出这个用户的主目录在那里,可以看到属于哪一个组!<br> 登录口令:把真正的加密后的用户口令字存放到/etc/shadow文件中,保证我们密码的安全性!<br>用户组的所有信息都存放在/etc/group文件中。</p>
<h1 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h1><p>df(列出文件系统整体的磁盘使用量) du(检查磁盘空间使用量)<br><img src="https://raw.githubusercontent.com/soda1/img/main/20210217153030.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 df命令</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210217153045.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 du命令</p>
<p>du -sm /*<br><img src="https://raw.githubusercontent.com/soda1/img/main/20210217153108.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 查看系统目录</p>
<p>Mac或者想使用Linux挂载我们的一些本地磁盘或者文件!</p>
<h2 id="挂载：mount"><a href="#挂载：mount" class="headerlink" title="挂载：mount"></a>挂载：mount</h2><p><img src="https://raw.githubusercontent.com/soda1/img/main/20210217153138.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 挂载图</p>
<p>卸载：umount-f [挂载位置] 强制卸载<br>除了这个之外，以后安装了JDK，可以使用Java命令查看信息</p>
<h1 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>1、在Linux中 ,每一个程序都是有自己的一个进程,每一个进程都有一个id号!<br>2、每一个进程呢,都会有一个父进程!<br>3、进程可以有两种存在方式:<strong>前台</strong>!<strong>后台</strong>运行!<br>4、一般的话<strong>服务都是后台运行</strong>的，基本的程序都是<strong>前台运行</strong>的<br>命令<br>ps 查看当前系统中正在执行的各种进程的信息！<br>ps- xx：<br>  -a 显示当前终端所有的进程信息<br>  -u 以用户的信息显示进程<br>  -x 显示后台运行进程的参数</p>
<pre><code class="bash">#ps -aux  查看所有进程
ps-aux|grep mysql  查看mysql相关进程
# | 在Linux中这个叫管道符   A|B
# grep 查找文件中符合条件的字符串
1234</code></pre>
<p>对于我们来说,这里目前只需要记住一个命令即可ps -xx|grep进程名字!过滤进程信息!<br>ps-ef ：可以查看到父进程的信息</p>
<pre><code class="bash">ps-ef|grep mysql 看父进程我们一般可以通过目录树结构来查看
#进程树
#pstree -pu
#-p 显示父id
#-u 显示用户组
12345</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210217153645.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>进程树效果图</p>
<p>结束进程：杀掉进程 等价于Windows结束任务</p>
<pre><code class="bash">kill -9 pid
1</code></pre>
<p>表示强制结束该进程</p>
<h1 id="环境安装"><a href="#环境安装" class="headerlink" title="环境安装"></a>环境安装</h1><p>安装软件一般有三种方式<br> rpm（在线发布一个SpringBoot项目）<br> 解压缩<br> yum在线安装</p>
<h2 id="JDK安装"><a href="#JDK安装" class="headerlink" title="JDK安装"></a>JDK安装</h2><p>1、下载IDK rpm。 去oralce官网下载即可!<br>2、安装java环境</p>
<pre><code class="bash">java -version 检测当前系统是否存在Java环境 和windows命令一样
#如果有的话就需要卸载
rpm -qa|grep jdk 查看JDK版本信息
rpm -e --nodeps jdk_ 卸载
#卸载完毕后可安装JDK
rpm -ivk rpm包 </code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210217153719.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 java-version命令</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210217153716.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 安装中</p>
<p>配置环境变量: /etc/profile 在文件的最后面增加java的配置和window安装环境变量一样!</p>
<pre><code class="bash">vim /etc/profile
1</code></pre>
<p>这个环境变量有问题 狂神老师敲的是有问题的</p>
<pre><code class="bash">JAVA_HOME=/usr/java/jdk-14.0.1
JRE_HOME=$JAVA_HOME/jre
PATH=$PATH:$JAVA_HOME/bin:$JRE_HOME/bin
CLASSPATH=.:$JAVA_HOME/lib/dt.jar:$JAVA_HOME/lib/tools.jar:$JRE_HOME/lib
export JAVA_HOME JRE_HOME PATH CLASSPATH
12345</code></pre>
<p>让这个配置文件生效!</p>
<pre><code class="bash">source /etc/profile
1</code></pre>
<p> 狂神老师用的是阿里云，自带网络了，此处给用虚拟机的同学使用。虚拟机联网教程：<a href="https://blog.csdn.net/u012049667/article/details/81171003">虚拟机和主机联网教程</a><br> 配置完后在Linux防火墙中开启相应端口 使用java -jar发布 如果你的项目在云服务器上，就可以在公网上进行发布查看了</p>
<pre><code class="bash">#开启防火墙端口
firewall-cmd --zone=public --add-port=9000/tcp --permanent
#重启防火墙
systemctl restart firewalld.service
#查看所有开启的端口，如果是阿里云 需要配置安全组规则
firewall-cmd --list-ports
123456</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210217153736.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>命令运行效果</p>
<p><img src="https://img-blog.csdnimg.cn/20200707090302192.png#pic_center" alt="在这里插入图片描述" loading="lazy"></p>
<p>查出centos7中的ip 外机进行访问</p>
<h2 id="Tomcat安装"><a href="#Tomcat安装" class="headerlink" title="Tomcat安装"></a>Tomcat安装</h2><p>ssm war 就需要放在tomcat中运行<br>1.下载tomcat 官网下载即可<br>2.解压tar -zxvf apache-tomcat-9.0.36.tar.gz<br>3.启动tomcat</p>
<pre><code class="bash">#执行 
./startup.sh
#停止
./shutdown.sh
1234</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210217153749.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>启动效果</p>
<pre><code class="bash">#开启端口
firewall-cmd --zone=public --add-port=8080/tcp –permanent
12</code></pre>
<p>命令含义:<br> –zone 作用域<br> –add-port-80/tcp 添加端口， 格式为:端口/通讯协议<br> –permanent 永久生效，没有此参数重启后失效</p>
<p> 如果是阿里云 上传完毕的项目直接购买自己的域名,备案解析过去即可!<br> 域名解析后,如果端口是80 - http或者443-https 可以直接访问,如果是9000 8080 ,就需要通过Apcahe或者Nginx做一下反向代理即可（配置文件）</p>
<h2 id="Docker（yum安装）"><a href="#Docker（yum安装）" class="headerlink" title="Docker（yum安装）"></a>Docker（yum安装）</h2><p>1.检测CentOS 7</p>
<pre><code class="bash">[root@localhost ~] cat /etc/redhat-release 
CentOS Linux release 7.3.1611 (Core)
12</code></pre>
<p>2.安装我们的准备环境</p>
<pre><code class="bash">yum -y install 包名
#yum install 安装命令 -y  所有的提示都为y
yum -y install gcc
yum -y install gcc-c++
1234</code></pre>
<p>3.卸载以前的docker</p>
<pre><code class="bash">yum remove docker \
                  docker-client \
                  docker-client-latest \
                  docker-common \
                  docker-latest \
                  docker-latest-logrotate \
                  docker-logrotate \
                  docker-engine
12345678</code></pre>
<p>4.下载环境</p>
<pre><code class="bash">yum install -y yum-utils \device-mapper-persistent-data \lvm2
1</code></pre>
<p>5.使用国内阿里云镜像</p>
<pre><code class="bash">yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo
1</code></pre>
<p>6.更新yum软件包安装</p>
<pre><code class="bash">yum makecache fast
1</code></pre>
<p>7.安装docker ce</p>
<pre><code class="bash">yum -y install docker-ce docker-ce-Cli containerd.io
1</code></pre>
<p>8.启动docker</p>
<pre><code class="bash">systemctl start docker
1</code></pre>
<p>9.测试</p>
<pre><code class="bash">docker version
docker run hello-world
docker images
123</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210217153809.png" alt="在这里插入图片描述" loading="lazy"></p>
<p>图 运行效果</p>
<p>到此完结 <em>★,°</em>:.☆(￣▽￣)/$:<em>.°★</em> 。</p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>linux常用命令</title>
    <url>/2021/05/09/linux/2021_05_09-linux%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h4 id="端口监听查看："><a href="#端口监听查看：" class="headerlink" title="端口监听查看："></a>端口监听查看：</h4><ul>
<li>ss -tln 查看TCP的listen的端口</li>
<li>ss -tlnp 查看哪些进程使用了监听端口</li>
</ul>
<h4 id="开放端口"><a href="#开放端口" class="headerlink" title="开放端口"></a>开放端口</h4><pre><code class="sh">#cetost 7
firewall-cmd --zone=public --add-port=端口号/tcp --permanent
#重启防火墙
systemctl restart firewalld.service 
#查看开放端口
firewall-cmd --list-ports</code></pre>
<h4 id="防火墙"><a href="#防火墙" class="headerlink" title="防火墙"></a>防火墙</h4><pre><code class="sh">#centos 7
systemctl status firewalld.service #防火墙状态
systemctl enable firewalld.service #开机自启防火墙
systemctl start firewalld.service #开启防火墙
# 6
systemctl status iptables (或service iptables status) 查看防火墙状态
systemctl stop iptables(或service iptables stop) 关闭防火墙</code></pre>
<h4 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h4><ul>
<li><p>curl <a href="https://link.zhihu.com/?target=http://ifconfig.me/">ifconfig.me</a> 查找本机公网IP</p>
</li>
<li><p>arch 显示机器的处理器架构(1)</p>
</li>
<li><p>uname -m 显示机器的处理器架构(2)</p>
</li>
<li><p>uname -r 显示正在使用的内核版本</p>
</li>
<li><p>dmidecode -q 显示硬件系统部件 - (SMBIOS / DMI)</p>
</li>
<li><p>hdparm -i /dev/hda 罗列一个磁盘的架构特性</p>
</li>
<li><p>hdparm -tT /dev/sda 在磁盘上执行测试性读取操作</p>
</li>
<li><p>cat /proc/cpuinfo 显示CPU info的信息</p>
</li>
<li><p>cat /proc/interrupts 显示中断</p>
</li>
<li><p>cat /proc/meminfo 校验内存使用</p>
</li>
<li><p>cat /proc/swaps 显示哪些swap被使用</p>
</li>
<li><p>cat /proc/version 显示内核的版本</p>
</li>
<li><p>cat /proc/net/dev 显示网络适配器及统计</p>
</li>
<li><p>cat /proc/mounts 显示已加载的文件系统</p>
</li>
<li><p>lspci -tv 罗列 PCI 设备</p>
</li>
<li><p>lsusb -tv 显示 USB 设备</p>
</li>
<li><p>date 显示系统日期</p>
</li>
<li><p>cal 2007 显示2007年的日历表</p>
</li>
<li><p>date 041217002007.00 设置日期和时间 - 月日时分年.秒</p>
</li>
<li><p>clock -w 将时间修改保存到 BIOS</p>
</li>
</ul>
<h4 id="ps命令常用用法（方便查看系统进程）"><a href="#ps命令常用用法（方便查看系统进程）" class="headerlink" title="ps命令常用用法（方便查看系统进程）"></a>ps命令常用用法（方便查看系统进程）</h4><ul>
<li><p>1）ps a 显示现行终端机下的所有程序，包括其他用户的程序。</p>
</li>
<li><p>2）ps -A 显示所有进程。</p>
</li>
<li><p>3）ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。</p>
</li>
<li><p>4）ps -e 此参数的效果和指定”A”参数相同。</p>
</li>
<li><p>5）ps e 列出程序时，显示每个程序所使用的环境变量。</p>
</li>
<li><p>6）ps f 用ASCII字符显示树状结构，表达程序间的相互关系。</p>
</li>
<li><p>7）ps -H 显示树状结构，表示程序间的相互关系。</p>
</li>
<li><p>8）ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。</p>
</li>
<li><p>9）ps s 采用程序信号的格式显示程序状况。</p>
</li>
<li><p>10）ps S 列出程序时，包括已中断的子程序资料。</p>
</li>
<li><p>11）ps -t&lt;终端机编号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。</p>
</li>
<li><p>12）ps u 　以用户为主的格式来显示程序状况。</p>
</li>
<li><p>13）ps x 　显示所有程序，不以终端机来区分。</p>
</li>
<li><p>常用指令组合 ：ps aux,然后再通过管道使用grep命令过滤查找特定的进程,然后再对特定的进程进行操作。</p>
</li>
<li><p>ps aux | grep program_filter_word,ps -ef |grep tomcat</p>
</li>
<li><p>ps -ef|grep java|grep -v grep 显示出所有的java进程，去处掉当前的grep进程。</p>
</li>
</ul>
<h4 id="关机-系统的关机、重启以及登出"><a href="#关机-系统的关机、重启以及登出" class="headerlink" title="关机 (系统的关机、重启以及登出 )"></a>关机 (系统的关机、重启以及登出 )</h4><ul>
<li><p>shutdown -h now 关闭系统(1)</p>
</li>
<li><p>init 0 关闭系统(2)</p>
</li>
<li><p>telinit 0 关闭系统(3)</p>
</li>
<li><p>shutdown -h hours:minutes &amp; 按预定时间关闭系统</p>
</li>
<li><p>shutdown -c 取消按预定时间关闭系统</p>
</li>
<li><p>shutdown -r now 重启(1)</p>
</li>
<li><p>reboot 重启(2)</p>
</li>
<li><p>logout 注销</p>
</li>
</ul>
<h4 id="文件和目录"><a href="#文件和目录" class="headerlink" title="文件和目录"></a>文件和目录</h4><ul>
<li><p>cd /home 进入 ‘/ home’ 目录’</p>
</li>
<li><p>cd .. 返回上一级目录</p>
</li>
<li><p>cd ../.. 返回上两级目录</p>
</li>
<li><p>cd 进入个人的主目录</p>
</li>
<li><p>cd ~user1 进入个人的主目录</p>
</li>
<li><p>cd - 返回上次所在的目录</p>
</li>
<li><p>pwd 显示工作路径</p>
</li>
<li><p>ls 查看目录中的文件</p>
</li>
<li><p>ls -F 查看目录中的文件</p>
</li>
<li><p>ls -l 显示文件和目录的详细资料</p>
</li>
<li><p>ls -a 显示隐藏文件</p>
</li>
<li><p>ls <em>[0-9]</em> 显示包含数字的文件名和目录名</p>
</li>
<li><p>tree 显示文件和目录由根目录开始的树形结构(1)</p>
</li>
<li><p>lstree 显示文件和目录由根目录开始的树形结构(2)</p>
</li>
<li><p>mkdir dir1 创建一个叫做 ‘dir1’ 的目录’</p>
</li>
<li><p>mkdir dir1 dir2 同时创建两个目录</p>
</li>
<li><p>mkdir -p /tmp/dir1/dir2 创建一个目录树</p>
</li>
<li><p>rm -f file1 删除一个叫做 ‘file1’ 的文件’</p>
</li>
<li><p>rmdir dir1 删除一个叫做 ‘dir1’ 的目录’</p>
</li>
<li><p>rm -rf dir1 删除一个叫做 ‘dir1’ 的目录并同时删除其内容</p>
</li>
<li><p>rm -rf dir1 dir2 同时删除两个目录及它们的内容</p>
</li>
<li><p>mv dir1 new_dir 重命名/移动 一个目录</p>
</li>
<li><p>cp file1 file2 复制一个文件</p>
</li>
<li><p>cp dir/* . 复制一个目录下的所有文件到当前工作目录</p>
</li>
<li><p>cp -a /tmp/dir1 . 复制一个目录到当前工作目录</p>
</li>
<li><p>cp -a dir1 dir2 复制一个目录</p>
</li>
<li><p>ln -s file1 lnk1 创建一个指向文件或目录的软链接</p>
</li>
<li><p>ln file1 lnk1 创建一个指向文件或目录的物理链接</p>
</li>
<li><p>touch -t 0712250000 file1 修改一个文件或目录的时间戳 - (YYMMDDhhmm)</p>
</li>
<li><p>file file1 outputs the mime type of the file as text</p>
</li>
<li><p>iconv -l 列出已知的编码</p>
</li>
<li><p>iconv -f fromEncoding -t toEncoding inputFile &gt; outputFile creates a new from the given input file by assuming it is encoded in fromEncoding and converting it to toEncoding.</p>
</li>
<li><p>find . -maxdepth 1 -name *.jpg -print -exec convert “{}” -resize 80x60 “thumbs/{}” ; batch resize files in the current directory and send them to a thumbnails directory (requires convert from Imagemagick)</p>
</li>
</ul>
<h4 id="文件搜索"><a href="#文件搜索" class="headerlink" title="文件搜索"></a>文件搜索</h4><ul>
<li><p>find / -name file1 从 ‘/‘ 开始进入根文件系统搜索文件和目录</p>
</li>
<li><p>find / -user user1 搜索属于用户 ‘user1’ 的文件和目录</p>
</li>
<li><p>find /home/user1 -name *.bin 在目录 ‘/ home/user1’ 中搜索带有’.bin’ 结尾的文件</p>
</li>
<li><p>find /usr/bin -type f -atime +100 搜索在过去100天内未被使用过的执行文件</p>
</li>
<li><p>find /usr/bin -type f -mtime -10 搜索在10天内被创建或者修改过的文件</p>
</li>
<li><p>find / -name *.rpm -exec chmod 755 ‘{}’ ; 搜索以 ‘.rpm’ 结尾的文件并定义其权限</p>
</li>
<li><p>find / -xdev -name *.rpm 搜索以 ‘.rpm’ 结尾的文件，忽略光驱、捷盘等可移动设备</p>
</li>
<li><p>locate *.ps 寻找以 ‘.ps’ 结尾的文件 - 先运行 ‘updatedb’ 命令</p>
</li>
<li><p>whereis halt 显示一个二进制文件、源码或man的位置</p>
</li>
<li><p>which halt 显示一个二进制文件或可执行文件的完整路径</p>
</li>
</ul>
<h4 id="挂载一个文件系统"><a href="#挂载一个文件系统" class="headerlink" title="挂载一个文件系统"></a>挂载一个文件系统</h4><ul>
<li><p>mount /dev/hda2 /mnt/hda2 挂载一个叫做hda2的盘 - 确定目录 ‘/ mnt/hda2’ 已经存在</p>
</li>
<li><p>umount /dev/hda2 卸载一个叫做hda2的盘 - 先从挂载点 ‘/ mnt/hda2’ 退出</p>
</li>
<li><p>fuser -km /mnt/hda2 当设备繁忙时强制卸载</p>
</li>
<li><p>umount -n /mnt/hda2 运行卸载操作而不写入 /etc/mtab 文件- 当文件为只读或当磁盘写满时非常有用</p>
</li>
<li><p>mount /dev/fd0 /mnt/floppy 挂载一个软盘</p>
</li>
<li><p>mount /dev/cdrom /mnt/cdrom 挂载一个cdrom或dvdrom</p>
</li>
<li><p>mount /dev/hdc /mnt/cdrecorder 挂载一个cdrw或dvdrom</p>
</li>
<li><p>mount /dev/hdb /mnt/cdrecorder 挂载一个cdrw或dvdrom</p>
</li>
<li><p>mount -o loop file.iso /mnt/cdrom 挂载一个文件或ISO镜像文件</p>
</li>
<li><p>mount -t vfat /dev/hda5 /mnt/hda5 挂载一个Windows FAT32文件系统</p>
</li>
<li><p>mount /dev/sda1 /mnt/usbdisk 挂载一个usb 捷盘或闪存设备</p>
</li>
<li><p>mount -t smbfs -o username=user,password=pass //WinClient/share /mnt/share 挂载一个windows网络共享</p>
</li>
</ul>
<h4 id="磁盘空间"><a href="#磁盘空间" class="headerlink" title="磁盘空间"></a>磁盘空间</h4><ul>
<li><p>df -h 显示已经挂载的分区列表</p>
</li>
<li><p>ls -lSr |more 以尺寸大小排列文件和目录</p>
</li>
<li><p>du -sh dir1 估算目录 ‘dir1’ 已经使用的磁盘空间’</p>
</li>
<li><p>du -sk * | sort -rn 以容量大小为依据依次显示文件和目录的大小</p>
</li>
<li><p>rpm -q -a –qf ‘%10{SIZE}t%{NAME}n’ | sort -k1,1n 以大小为依据依次显示已安装的rpm包所使用的空间 (fedora, redhat类系统)</p>
</li>
<li><p>dpkg-query -W -f=’${Installed-Size;10}t${Package}n’ | sort -k1,1n 以大小为依据显示已安装的deb包所使用的空间 (ubuntu, debian类系统)</p>
</li>
</ul>
<h4 id="用户和群组"><a href="#用户和群组" class="headerlink" title="用户和群组"></a>用户和群组</h4><ul>
<li>groupadd group_name 创建一个新用户组</li>
<li>groupdel group_name 删除一个用户组</li>
<li>groupmod -n new_group_name old_group_name 重命名一个用户组</li>
<li>useradd -c “Name Surname “ -g admin -d /home/user1 -s /bin/bash user1 创建一个属于 “admin” 用户组的用户</li>
<li>useradd user1 创建一个新用户</li>
<li>userdel -r user1 删除一个用户 ( ‘-r’ 排除主目录)</li>
<li>usermod -c “User FTP” -g system -d /ftp/user1 -s /bin/nologin user1 修改用户属性</li>
<li>passwd 修改口令</li>
<li>passwd user1 修改一个用户的口令 (只允许root执行)</li>
<li>chage -E 2005-12-31 user1 设置用户口令的失效期限</li>
<li>pwck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的用户</li>
<li>grpck 检查 ‘/etc/passwd’ 的文件格式和语法修正以及存在的群组</li>
<li>newgrp group_name 登陆进一个新的群组以改变新创建文件的预设群组</li>
</ul>
<p>文件的权限 - 使用 “+” 设置权限，使用 “-“ 用于取消</p>
<p>ls -lh 显示权限</p>
<p>ls /tmp | pr -T5 -W$COLUMNS 将终端划分成5栏显示</p>
<p>chmod ugo+rwx directory1 设置目录的所有人(u)、群组(g)以及其他人(o)以读（r ）、写(w)和执行(x)的权限</p>
<p>chmod go-rwx directory1 删除群组(g)与其他人(o)对目录的读写执行权限</p>
<p>chown user1 file1 改变一个文件的所有人属性</p>
<p>chown -R user1 directory1 改变一个目录的所有人属性并同时改变改目录下所有文件的属性</p>
<p>chgrp group1 file1 改变文件的群组</p>
<p>chown user1:group1 file1 改变一个文件的所有人和群组属性</p>
<p>find / -perm -u+s 罗列一个系统中所有使用了SUID控制的文件</p>
<p>chmod u+s /bin/file1 设置一个二进制文件的 SUID 位 - 运行该文件的用户也被赋予和所有者同样的权限</p>
<p>chmod u-s /bin/file1 禁用一个二进制文件的 SUID位</p>
<p>chmod g+s /home/public 设置一个目录的SGID 位 - 类似SUID ，不过这是针对目录的</p>
<p>chmod g-s /home/public 禁用一个目录的 SGID 位</p>
<p>chmod o+t /home/public 设置一个文件的 STIKY 位 - 只允许合法所有人删除文件</p>
<p>chmod o-t /home/public 禁用一个目录的 STIKY 位</p>
<p>文件的特殊属性 - 使用 “+” 设置权限，使用 “-“ 用于取消</p>
<p>chattr +a file1 只允许以追加方式读写文件</p>
<p>chattr +c file1 允许这个文件能被内核自动压缩/解压</p>
<p>chattr +d file1 在进行文件系统备份时，dump程序将忽略这个文件</p>
<p>chattr +i file1 设置成不可变的文件，不能被删除、修改、重命名或者链接</p>
<p>chattr +s file1 允许一个文件被安全地删除</p>
<p>chattr +S file1 一旦应用程序对这个文件执行了写操作，使系统立刻把修改的结果写到磁盘</p>
<p>chattr +u file1 若文件被删除，系统会允许你在以后恢复这个被删除的文件</p>
<p>lsattr 显示特殊的属性</p>
<p>打包和压缩文件</p>
<p>bunzip2 file1.bz2 解压一个叫做 ‘file1.bz2’的文件</p>
<p>bzip2 file1 压缩一个叫做 ‘file1’ 的文件</p>
<p>gunzip file1.gz 解压一个叫做 ‘file1.gz’的文件</p>
<p>gzip file1 压缩一个叫做 ‘file1’的文件</p>
<p>gzip -9 file1 最大程度压缩</p>
<p>rar a file1.rar test_file 创建一个叫做 ‘file1.rar’ 的包</p>
<p>rar a file1.rar file1 file2 dir1 同时压缩 ‘file1’, ‘file2’ 以及目录 ‘dir1’</p>
<p>rar x file1.rar 解压rar包</p>
<p>unrar x file1.rar 解压rar包</p>
<p>tar -cvf archive.tar file1 创建一个非压缩的 tarball</p>
<p>tar -cvf archive.tar file1 file2 dir1 创建一个包含了 ‘file1’, ‘file2’ 以及 ‘dir1’的档案文件</p>
<p>tar -tf archive.tar 显示一个包中的内容</p>
<p>tar -xvf archive.tar 释放一个包</p>
<p>tar -xvf archive.tar -C /tmp 将压缩包释放到 /tmp目录下</p>
<p>tar -cvfj archive.tar.bz2 dir1 创建一个bzip2格式的压缩包</p>
<p>tar -xvfj archive.tar.bz2 解压一个bzip2格式的压缩包</p>
<p>tar -cvfz archive.tar.gz dir1 创建一个gzip格式的压缩包</p>
<p>tar -xvfz archive.tar.gz 解压一个gzip格式的压缩包</p>
<p>zip <a href="https://link.zhihu.com/?target=http://file1.zip/">file1.zip</a> file1 创建一个zip格式的压缩包</p>
<p>zip -r <a href="https://link.zhihu.com/?target=http://file1.zip/">file1.zip</a> file1 file2 dir1 将几个文件和目录同时压缩成一个zip格式的压缩包</p>
<p>unzip <a href="https://link.zhihu.com/?target=http://file1.zip/">file1.zip</a> 解压一个zip格式压缩包</p>
<h4 id="看文件内容"><a href="#看文件内容" class="headerlink" title="看文件内容"></a>看文件内容</h4><ul>
<li>cat file1 从第一个字节开始正向查看文件的内容</li>
<li>tac file1 从最后一行开始反向查看一个文件的内容</li>
<li>more file1 查看一个长文件的内容</li>
<li>less file1 类似于 ‘more’ 命令，但是它允许在文件中和正向操作一样的反向操作</li>
<li>head -2 file1 查看一个文件的前两行</li>
<li>tail -2 file1 查看一个文件的最后两行</li>
<li>tail -f /var/log/messages 实时查看被添加到一个文件中的内容</li>
</ul>
<h4 id="文本处理"><a href="#文本处理" class="headerlink" title="文本处理"></a>文本处理</h4><ul>
<li>cat file1 file2 … | command &lt;&gt; file1_in.txt_or_file1_out.txt general syntax for text manipulation using PIPE, STDIN and STDOUT</li>
<li>cat file1 | command( sed, grep, awk, grep, etc…) &gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个新文件中</li>
<li>cat file1 | command( sed, grep, awk, grep, etc…) &gt;&gt; result.txt 合并一个文件的详细说明文本，并将简介写入一个已有的文件中</li>
<li>grep Aug /var/log/messages 在文件 ‘/var/log/messages’中查找关键词”Aug”</li>
<li>grep ^Aug /var/log/messages 在文件 ‘/var/log/messages’中查找以”Aug”开始的词汇</li>
<li>grep [0-9] /var/log/messages 选择 ‘/var/log/messages’ 文件中所有包含数字的行</li>
<li>grep Aug -R /var/log/* 在目录 ‘/var/log’ 及随后的目录中搜索字符串”Aug”</li>
<li>sed ‘s/stringa1/stringa2/g’ example.txt 将example.txt文件中的 “string1” 替换成 “string2”</li>
<li>sed ‘/^$/d’ example.txt 从example.txt文件中删除所有空白行</li>
<li>sed ‘/ *#/d; /^$/d’ example.txt 从example.txt文件中删除所有注释和空白行</li>
<li>echo ‘esempio’ | tr ‘[:lower:]’ ‘[:upper:]’ 合并上下单元格内容</li>
<li>sed -e ‘1d’ result.txt 从文件example.txt 中排除第一行</li>
<li>sed -n ‘/stringa1/p’ 查看只包含词汇 “string1”的行</li>
<li>sed -e ‘s/ *$//‘ example.txt 删除每一行最后的空白字符</li>
<li>sed -e ‘s/stringa1//g’ example.txt 从文档中只删除词汇 “string1” 并保留剩余全部</li>
<li>sed -n ‘1,5p;5q’ example.txt 查看从第一行到第5行内容</li>
<li>sed -n ‘5p;5q’ example.txt 查看第5行</li>
<li>sed -e ‘s/00*/0/g’ example.txt 用单个零替换多个零</li>
<li>cat -n file1 标示文件的行数</li>
<li>cat example.txt | awk ‘NR%2==1’ 删除example.txt文件中的所有偶数行</li>
<li>echo a b c | awk ‘{print $1}’ 查看一行第一栏</li>
<li>echo a b c | awk ‘{print $1,$3}’ 查看一行的第一和第三栏</li>
<li>paste file1 file2 合并两个文件或两栏的内容</li>
<li>paste -d ‘+’ file1 file2 合并两个文件或两栏的内容，中间用”+”区分</li>
<li>sort file1 file2 排序两个文件的内容</li>
<li>sort file1 file2 | uniq 取出两个文件的并集(重复的行只保留一份)</li>
<li>sort file1 file2 | uniq -u 删除交集，留下其他的行</li>
<li>sort file1 file2 | uniq -d 取出两个文件的交集(只留下同时存在于两个文件中的文件)</li>
<li>comm -1 file1 file2 比较两个文件的内容只删除 ‘file1’ 所包含的内容</li>
<li>comm -2 file1 file2 比较两个文件的内容只删除 ‘file2’ 所包含的内容</li>
<li>comm -3 file1 file2 比较两个文件的内容只删除两个文件共有的部分</li>
</ul>
<h4 id="字符设置和文件格式转换"><a href="#字符设置和文件格式转换" class="headerlink" title="字符设置和文件格式转换"></a>字符设置和文件格式转换</h4><ul>
<li>dos2unix filedos.txt fileunix.txt 将一个文本文件的格式从MSDOS转换成UNIX</li>
<li>unix2dos fileunix.txt filedos.txt 将一个文本文件的格式从UNIX转换成MSDOS</li>
<li>recode ..HTML &lt; page.txt &gt; page.html 将一个文本文件转换成html</li>
<li>recode -l | more 显示所有允许的转换格式</li>
</ul>
<h4 id="文件系统分析"><a href="#文件系统分析" class="headerlink" title="文件系统分析"></a>文件系统分析</h4><ul>
<li>badblocks -v /dev/hda1 检查磁盘hda1上的坏磁块</li>
<li>fsck /dev/hda1 修复/检查hda1磁盘上linux文件系统的完整性</li>
<li>fsck.ext2 /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性</li>
<li>e2fsck /dev/hda1 修复/检查hda1磁盘上ext2文件系统的完整性</li>
<li>e2fsck -j /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性</li>
<li>fsck.ext3 /dev/hda1 修复/检查hda1磁盘上ext3文件系统的完整性</li>
<li>fsck.vfat /dev/hda1 修复/检查hda1磁盘上fat文件系统的完整性</li>
<li>fsck.msdos /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</li>
<li>dosfsck /dev/hda1 修复/检查hda1磁盘上dos文件系统的完整性</li>
</ul>
<h4 id="初始化一个文件系统"><a href="#初始化一个文件系统" class="headerlink" title="初始化一个文件系统"></a>初始化一个文件系统</h4><ul>
<li>mkfs /dev/hda1 在hda1分区创建一个文件系统</li>
<li>mke2fs /dev/hda1 在hda1分区创建一个linux ext2的文件系统</li>
<li>mke2fs -j /dev/hda1 在hda1分区创建一个linux ext3(日志型)的文件系统</li>
<li>mkfs -t vfat 32 -F /dev/hda1 创建一个 FAT32 文件系统</li>
<li>fdformat -n /dev/fd0 格式化一个软盘</li>
<li>mkswap /dev/hda3 创建一个swap文件系统</li>
</ul>
<h4 id="SWAP文件系统"><a href="#SWAP文件系统" class="headerlink" title="SWAP文件系统"></a>SWAP文件系统</h4><ul>
<li>mkswap /dev/hda3 创建一个swap文件系统</li>
<li>swapon /dev/hda3 启用一个新的swap文件系统</li>
<li>swapon /dev/hda2 /dev/hdb3 启用两个swap分区</li>
</ul>
<h4 id="备份"><a href="#备份" class="headerlink" title="备份"></a>备份</h4><ul>
<li>dump -0aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的完整备份</li>
<li>dump -1aj -f /tmp/home0.bak /home 制作一个 ‘/home’ 目录的交互式备份</li>
<li>restore -if /tmp/home0.bak 还原一个交互式备份</li>
<li>rsync -rogpav –delete /home /tmp 同步两边的目录</li>
<li>rsync -rogpav -e ssh –delete /home ip_address:/tmp 通过SSH通道rsync</li>
<li>rsync -az -e ssh –delete ip_addr:/home/public /home/local 通过ssh和压缩将一个远程目录同步到本地目录</li>
<li>rsync -az -e ssh –delete /home/local ip_addr:/home/public 通过ssh和压缩将本地目录同步到远程目录</li>
<li>dd bs=1M if=/dev/hda | gzip | ssh user@ip_addr ‘dd of=hda.gz’ 通过ssh在远程主机上执行一次备份本地磁盘的操作</li>
<li>dd if=/dev/sda of=/tmp/file1 备份磁盘内容到一个文件</li>
<li>tar -Puf backup.tar /home/user 执行一次对 ‘/home/user’ 目录的交互式备份操作</li>
<li>( cd /tmp/local/ &amp;&amp; tar c . ) | ssh -C user@ip_addr ‘cd /home/share/ &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个目录内容</li>
<li>( tar c /home ) | ssh -C user@ip_addr ‘cd /home/backup-home &amp;&amp; tar x -p’ 通过ssh在远程目录中复制一个本地目录</li>
<li>tar cf - . | (cd /tmp/backup ; tar xf - ) 本地将一个目录复制到另一个地方，保留原有权限及链接</li>
<li>find /home/user1 -name ‘*.txt’ | xargs cp -av –target-directory=/home/backup/ –parents 从一个目录查找并复制所有以 ‘.txt’ 结尾的文件到另一个目录</li>
<li>find /var/log -name ‘*.log’ | tar cv –files-from=- | bzip2 &gt; log.tar.bz2 查找所有以 ‘.log’ 结尾的文件并做成一个bzip包</li>
<li>dd if=/dev/hda of=/dev/fd0 bs=512 count=1 做一个将 MBR (Master Boot Record)内容复制到软盘的动作</li>
<li>dd if=/dev/fd0 of=/dev/hda bs=512 count=1 从已经保存到软盘的备份中恢复MBR内容</li>
</ul>
<h4 id="光盘"><a href="#光盘" class="headerlink" title="光盘"></a>光盘</h4><ul>
<li>cdrecord -v gracetime=2 dev=/dev/cdrom -eject blank=fast -force 清空一个可复写的光盘内容</li>
<li>mkisofs /dev/cdrom &gt; cd.iso 在磁盘上创建一个光盘的iso镜像文件</li>
<li>mkisofs /dev/cdrom | gzip &gt; cd_iso.gz 在磁盘上创建一个压缩了的光盘iso镜像文件</li>
<li>mkisofs -J -allow-leading-dots -R -V “Label CD” -iso-level 4 -o ./cd.iso data_cd 创建一个目录的iso镜像文件</li>
<li>cdrecord -v dev=/dev/cdrom cd.iso 刻录一个ISO镜像文件</li>
<li>gzip -dc cd_iso.gz | cdrecord dev=/dev/cdrom - 刻录一个压缩了的ISO镜像文件</li>
<li>mount -o loop cd.iso /mnt/iso 挂载一个ISO镜像文件</li>
<li>cd-paranoia -B 从一个CD光盘转录音轨到 wav 文件中</li>
<li>cd-paranoia – “-3” 从一个CD光盘转录音轨到 wav 文件中（参数-3）</li>
<li>cdrecord –scanbus 扫描总线以识别scsi通道</li>
<li>dd if=/dev/hdc | md5sum 校验一个设备的md5sum编码，例如一张 CD</li>
</ul>
<h4 id="网络-（以太网和WIFI无线）"><a href="#网络-（以太网和WIFI无线）" class="headerlink" title="网络 - （以太网和WIFI无线）"></a>网络 - （以太网和WIFI无线）</h4><ul>
<li>ifconfig eth0 显示一个以太网卡的配置</li>
<li>ifup eth0 启用一个 ‘eth0’ 网络设备</li>
<li>ifdown eth0 禁用一个 ‘eth0’ 网络设备</li>
<li>ifconfig eth0 192.168.1.1 netmask 255.255.255.0 控制IP地址</li>
<li>ifconfig eth0 promisc 设置 ‘eth0’ 成混杂模式以嗅探数据包 (sniffing)</li>
<li>dhclient eth0 以dhcp模式启用 ‘eth0’</li>
<li>route -n show routing table</li>
<li>route add -net 0/0 gw IP_Gateway configura default gateway</li>
<li>route add -net 192.168.0.0 netmask 255.255.0.0 gw 192.168.1.1 configure static route to reach network ‘192.168.0.0/16’</li>
<li>route del 0/0 gw IP_gateway remove static route</li>
<li>echo “1” &gt; /proc/sys/net/ipv4/ip_forward activate ip routing</li>
<li>hostname show hostname of system</li>
<li>host <a href="https://link.zhihu.com/?target=http://www.example.com/">Example Domain</a> lookup hostname to resolve name to ip address and viceversa(1)</li>
<li>nslookup <a href="https://link.zhihu.com/?target=http://www.example.com/">Example Domain</a> lookup hostname to resolve name to ip address and viceversa(2)</li>
<li>ip link show show link status of all interfaces</li>
<li>mii-tool eth0 show link status of ‘eth0’</li>
<li>ethtool eth0 show statistics of network card ‘eth0’</li>
<li>netstat -tup show all active network connections and their PID</li>
<li>netstat -tupl show all network services listening on the system and their PID</li>
<li>tcpdump tcp port 80 show all HTTP traffic</li>
<li>iwlist scan show wireless networks</li>
<li>iwconfig eth1 show configuration of a wireless network card</li>
<li>hostname show hostname</li>
<li>host <a href="https://link.zhihu.com/?target=http://www.example.com/">Example Domain</a> lookup hostname to resolve name to ip address and viceversa</li>
<li>nslookup <a href="https://link.zhihu.com/?target=http://www.example.com/">Example Domain</a> lookup hostname to resolve name to ip address and viceversa</li>
<li>whois <a href="https://link.zhihu.com/?target=http://www.example.com/">Example Domain</a> lookup on Whois database</li>
</ul>
<h4 id="JPS工具"><a href="#JPS工具" class="headerlink" title="JPS工具"></a>JPS工具</h4><p>jps(Java Virtual Machine Process Status Tool)是JDK 1.5提供的一个显示当前所有java进程pid的命令，简单实用，非常适合在linux/unix平台上简单察看当前java进程的一些简单情况。</p>
<p>我想很多人都是用过unix系统里的ps命令，这个命令主要是用来显示当前系统的进程情况，有哪些进程，及其 id。 jps 也是一样，它的作用是显示当前系统的java进程情况，及其id号。我们可以通过它来查看我们到底启动了几个java进程（因为每一个java程序都会独占一个java虚拟机实例），和他们的进程号（为下面几个程序做准备），并可通过opt来查看这些进程的详细启动参数。</p>
<p>使用方法：在当前命令行下打 jps(需要JAVA_HOME，没有的话，到改程序的目录下打) 。</p>
<p>jps存放在JAVA_HOME/bin/jps，使用时为了方便请将JAVA_HOME/bin/加入到Path.</p>
<pre><code>$&gt; jps

23991 Jps
23789 BossMain
23651 Resin</code></pre>
<p>比较常用的参数：-q 只显示pid，不显示class名称,jar文件名和传递给main 方法的参数</p>
<pre><code>$&gt; jps -q

28680
23789
23651
</code></pre>
<p>-m 输出传递给main 方法的参数，在嵌入式jvm上可能是null</p>
<pre><code>$&gt; jps -m

28715 Jps -m
23789 BossMain
23651 Resin -socketwait 32768 -stdout /data/aoxj/resin/log/stdout.log -stderr /data/aoxj/resin/log/stderr.log</code></pre>
<p>-l 输出应用程序main class的完整package名 或者 应用程序的jar文件完整路径名</p>
<pre><code>$&gt; jps -l

28729 sun.tools.jps.Jps
23789 com.asiainfo.aimc.bossbi.BossMain
23651 com.caucho.server.resin.Resin</code></pre>
<p>-v 输出传递给JVM的参数</p>
<pre><code>$&gt; jps -v

23789 BossMain
28802 Jps -Denv.class.path=/data/aoxj/bossbi/twsecurity/java/trustwork140.jar:/data/aoxj/bossbi/twsecurity/java/:/data/aoxj/bossbi/twsecurity/java/twcmcc.jar:/data/aoxj/jdk15/lib/rt.jar:/data/aoxj/jd
k15/lib/tools.jar -Dapplication.home=/data/aoxj/jdk15 -Xms8m
23651 Resin -Xss1m -Dresin.home=/data/aoxj/resin -Dserver.root=/data/aoxj/resin -Djava.util.logging.manager=com.caucho.log.LogManagerImpl 

Djavax.management.builder.initial=com.caucho.jmx.MBeanServerBuilderImpl</code></pre>
<p>sudo jps看到的进程数量最全</p>
<pre><code>jps 192.168.0.77</code></pre>
<p>列出远程服务器192.168.0.77机器所有的jvm实例，采用rmi协议，默认连接端口为1099</p>
<p>（前提是远程服务器提供jstatd服务）</p>
<p>注：jps命令有个地方很不好，似乎只能显示当前用户的java进程，要显示其他用户的还是只能用unix/linux的ps命令。</p>
<h4 id="RPM-包-（Fedora-Redhat及类似系统）"><a href="#RPM-包-（Fedora-Redhat及类似系统）" class="headerlink" title="RPM 包 - （Fedora, Redhat及类似系统）"></a>RPM 包 - （Fedora, Redhat及类似系统）</h4><ul>
<li>rpm -ivh package.rpm 安装一个rpm包</li>
<li>rpm -ivh –nodeeps package.rpm 安装一个rpm包而忽略依赖关系警告</li>
<li>rpm -U package.rpm 更新一个rpm包但不改变其配置文件</li>
<li>rpm -F package.rpm 更新一个确定已经安装的rpm包</li>
<li>rpm -e package_name.rpm 删除一个rpm包</li>
<li>rpm -qa 显示系统中所有已经安装的rpm包</li>
<li>rpm -qa | grep httpd 显示所有名称中包含 “httpd” 字样的rpm包</li>
<li>rpm -qi package_name 获取一个已安装包的特殊信息</li>
<li>rpm -qg “System Environment/Daemons” 显示一个组件的rpm包</li>
<li>rpm -ql package_name 显示一个已经安装的rpm包提供的文件列表</li>
<li>rpm -qc package_name 显示一个已经安装的rpm包提供的配置文件列表</li>
<li>rpm -q package_name –whatrequires 显示与一个rpm包存在依赖关系的列表</li>
<li>rpm -q package_name –whatprovides 显示一个rpm包所占的体积</li>
<li>rpm -q package_name –scripts 显示在安装/删除期间所执行的脚本l</li>
<li>rpm -q package_name –changelog 显示一个rpm包的修改历史</li>
<li>rpm -qf /etc/httpd/conf/httpd.conf 确认所给的文件由哪个rpm包所提供</li>
<li>rpm -qp package.rpm -l 显示由一个尚未安装的rpm包提供的文件列表</li>
<li>rpm –import /media/cdrom/RPM-GPG-KEY 导入公钥数字证书</li>
<li>rpm –checksig package.rpm 确认一个rpm包的完整性</li>
<li>rpm -qa gpg-pubkey 确认已安装的所有rpm包的完整性</li>
<li>rpm -V package_name 检查文件尺寸、 许可、类型、所有者、群组、MD5检查以及最后修改时间</li>
<li>rpm -Va 检查系统中所有已安装的rpm包- 小心使用</li>
<li>rpm -Vp package.rpm 确认一个rpm包还未安装</li>
<li>rpm2cpio package.rpm | cpio –extract –make-directories <em>bin</em> 从一个rpm包运行可执行文件</li>
<li>rpm -ivh /usr/src/redhat/RPMS/<code>arch</code>/package.rpm 从一个rpm源码安装一个构建好的包</li>
<li>rpmbuild –rebuild package_name.src.rpm 从一个rpm源码构建一个 rpm 包</li>
</ul>
<h4 id="YUM-软件包升级器-（Fedora-RedHat及类似系统）"><a href="#YUM-软件包升级器-（Fedora-RedHat及类似系统）" class="headerlink" title="YUM 软件包升级器 - （Fedora, RedHat及类似系统）"></a>YUM 软件包升级器 - （Fedora, RedHat及类似系统）</h4><ul>
<li>yum install package_name 下载并安装一个rpm包</li>
<li>yum localinstall package_name.rpm 将安装一个rpm包，使用你自己的软件仓库为你解决所有依赖关系</li>
<li>yum update package_name.rpm 更新当前系统中所有安装的rpm包</li>
<li>yum update package_name 更新一个rpm包</li>
<li>yum remove package_name 删除一个rpm包</li>
<li>yum list 列出当前系统中安装的所有包</li>
<li>yum search package_name 在rpm仓库中搜寻软件包</li>
<li>yum clean packages 清理rpm缓存删除下载的包</li>
<li>yum clean headers 删除所有头文件</li>
<li>yum clean all 删除所有缓存的包和头文件</li>
</ul>
<h4 id="DEB-包-Debian-Ubuntu-以及类似系统"><a href="#DEB-包-Debian-Ubuntu-以及类似系统" class="headerlink" title="DEB 包 (Debian, Ubuntu 以及类似系统)"></a>DEB 包 (Debian, Ubuntu 以及类似系统)</h4><ul>
<li>dpkg -i package.deb 安装/更新一个 deb 包</li>
<li>dpkg -r package_name 从系统删除一个 deb 包</li>
<li>dpkg -l 显示系统中所有已经安装的 deb 包</li>
<li>dpkg -l | grep httpd 显示所有名称中包含 “httpd” 字样的deb包</li>
<li>dpkg -s package_name 获得已经安装在系统中一个特殊包的信息</li>
<li>dpkg -L package_name 显示系统中已经安装的一个deb包所提供的文件列表</li>
<li>dpkg –contents package.deb 显示尚未安装的一个包所提供的文件列表</li>
<li>dpkg -S /bin/ping 确认所给的文件由哪个deb包提供</li>
</ul>
<h4 id="APT-软件工具-Debian-Ubuntu-以及类似系统"><a href="#APT-软件工具-Debian-Ubuntu-以及类似系统" class="headerlink" title="APT 软件工具 (Debian, Ubuntu 以及类似系统)"></a>APT 软件工具 (Debian, Ubuntu 以及类似系统)</h4><ul>
<li>apt-get install package_name 安装/更新一个 deb 包</li>
<li>apt-cdrom install package_name 从光盘安装/更新一个 deb 包</li>
<li>apt-get update 升级列表中的软件包</li>
<li>apt-get upgrade 升级所有已安装的软件</li>
<li>apt-get remove package_name 从系统删除一个deb包</li>
<li>apt-get check 确认依赖的软件仓库正确</li>
<li>apt-get clean 从下载的软件包中清理缓存</li>
<li>apt-cache search searched-package 返回包含所要搜索字符串的软件包名称</li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>磁盘扩容</title>
    <url>/2021/05/15/linux/2021_05_15-%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h3 id="磁盘扩容（centos7）"><a href="#磁盘扩容（centos7）" class="headerlink" title="磁盘扩容（centos7）"></a>磁盘扩容（centos7）</h3><h4 id="lvm结构"><a href="#lvm结构" class="headerlink" title="lvm结构"></a>lvm结构</h4><p><img src="https://raw.githubusercontent.com/soda1/img/main/20210515164512.png" alt="img" loading="lazy"></p>
<center> lvm 的结构</center>

<p>在centos中，对于储存和磁盘空间的管理是lvm。 常用的 fdisk -l 命令，显示的就是物理分区。</p>
<ul>
<li>物理卷（PV)：由物理盘割分出来的分区 </li>
<li>逻辑卷组(VG)：由多个物理卷组成</li>
<li>逻辑卷(LV)：由逻辑卷组分割而成</li>
</ul>
<p><strong>扩容逻辑就是将新增的物理盘切分成物理卷，然后将新增物理卷加入逻辑卷所在的逻辑卷组，最后进行逻辑卷扩容。</strong></p>
<h4 id="对根目录扩容"><a href="#对根目录扩容" class="headerlink" title="对根目录扩容"></a>对根目录扩容</h4><h5 id="创建物理分区"><a href="#创建物理分区" class="headerlink" title="创建物理分区"></a>创建物理分区</h5><pre><code># /dev/sda为通过fdisk -l 查看到的物理磁盘(第一行)
fdisk /dev/sda 

#进入fdisk命令行 n为创建一个新的分区
Command (m for help): n 

# 这里需要选择时创建主分区还是扩展分区，都可以，这里直接选了主分区
Partition type:   
   p   primary (2 primary, 0 extended, 2 free)   
   e   extended
# 选择创建一个主分区，主分区只能有4个，编号为1-4,下面的全部直接回车就好了，会自动将剩余所用空间都创建
Select (default p): p 

Partition number (3,4, default 3):   
First sector (104857600-209715199, default 104857600): 
Using default value 104857600
Last sector, +sectors or +size&#123;K,M,G&#125; (104857600-209715199, default 209715199): 
Using default value 209715199
Partition 3 of type Linux and of size 50 GiB is set

# t为修改分区类型 修改为lvm
Command (m for help): t
# 刚才创建的分区编号为3
Partition number (1-3, default 3): 3  
# 8e就是 lvm格式的分区
Hex code (type L to list all codes): 8e
Changed type of partition &#39;Linux&#39; to &#39;Linux LVM&#39;

# w保存并写入磁盘。
Command (m for help): w  
The partition table has been altered!

Calling ioctl() to re-read partition table.

WARNING: Re-reading the partition table failed with error 16: Device or resource busy.
The kernel still uses the old table. The new table will be used at
the next reboot or after you run partprobe(8) or kpartx(8)
Syncing disks.
#报错无法读取分区信息，可以执行下面指令
partprobe</code></pre>
<h5 id="创建物理卷："><a href="#创建物理卷：" class="headerlink" title="创建物理卷："></a>创建物理卷：</h5><p> 将物理分区3 创建物理卷，这里这个/dev/sda3是第一步创建的物理分区，通过fdisk -l 就可以看到是，在第一个物理磁盘/dev/sda下面的分区(一个磁盘可以有多个分区)，原本已有/dev/sda1,/dev/sda2</p>
<p>通过第一步创建生成/dev/sda3这个分区，然后将这个分区 创建成物理卷</p>
<ol>
<li><p>将分区3创建物理卷</p>
<pre><code class="sh">pvcreate /dev/sda3</code></pre>
</li>
<li><p>查看物理卷</p>
<pre><code class="sh">pvdisplay</code></pre>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210515173418.png" alt="image-20210515173404164" loading="lazy"></p>
<h5 id="将物理卷添加到卷组"><a href="#将物理卷添加到卷组" class="headerlink" title="将物理卷添加到卷组"></a>将物理卷添加到卷组</h5><ol>
<li><p>查看卷组</p>
<pre><code class="sh">vgdisplay</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210515173751.png" alt="image-20210515173719857" loading="lazy"></p>
</li>
<li><p>加入卷组</p>
<pre><code>vgextend centos /dev/sda3</code></pre>
</li>
</ol>
<h5 id="逻辑卷进行扩容。"><a href="#逻辑卷进行扩容。" class="headerlink" title="逻辑卷进行扩容。"></a>逻辑卷进行扩容。</h5><ol>
<li><p>查看逻辑卷</p>
<pre><code>lvdisplay</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210515174406.png" alt="image-20210515174036139" loading="lazy"></p>
</li>
<li><p>将剩余百分百空间都添加到逻辑卷中</p>
<pre><code>lvextend -l +100%FREE /dev/centos/root</code></pre>
</li>
<li><p>重新识别分区大小</p>
<pre><code>xfs_growfs /dev/centos/root</code></pre>
</li>
<li><p>通过df -h就可以看到新增容量了</p>
</li>
</ol>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>性能指标</title>
    <url>/2023/01/14/linux/%E6%80%A7%E8%83%BD%E6%8C%87%E6%A0%87/</url>
    <content><![CDATA[<h4 id="指标"><a href="#指标" class="headerlink" title="指标"></a>指标</h4><ol>
<li><p>QPS：每秒请求数</p>
</li>
<li><p>TPS：每秒事务数，一个事务可能会包含多个请求，比如一个页面加载会发送多个请求至后端</p>
</li>
<li><p>RT：系统响应时间，执行一个请求从开始到最后收到响应数据所花费的总体时间</p>
</li>
<li><p>Concurrency：并发数，系统同时处理的请求数量，也反应了系统的负载能力</p>
</li>
<li><p>吞吐量：系统吞吐量和CPU消耗、外部接口、IO等因素等紧密关联。</p>
<p>重要指标参数：QPS（TPS）、并发数、平均响应时间</p>
</li>
</ol>
<p>关系：<br>$$<br>QPS(TPS) = 并发数 / 平均响应时间<br>$$</p>
<h4 id="QPS压测实验"><a href="#QPS压测实验" class="headerlink" title="QPS压测实验"></a>QPS压测实验</h4><p>压测工具：wrk</p>
<p>环境：ubuntu（wsl subSystem), 6核 11线程</p>
<p>并发200测试</p>
<pre><code class="shell">root@LAPTOP-6HNUFCIN:/usr/bin# wrk -t 11 -c 200 -d 30s --latency  http://127.0.0.1:8281/api/test
Running 30s test @ http://127.0.0.1:8281/api/test
  11 threads and 200 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    43.81ms   26.20ms 259.14ms   69.79%
    Req/Sec   419.92     56.97   680.00     68.39%
  Latency Distribution
     50%   44.25ms
     75%   60.54ms
     90%   76.10ms
     99%  109.90ms
  138097 requests in 30.05s, 40.98MB read
  Non-2xx or 3xx responses: 138097
Requests/sec:   4596.04 //QPS
Transfer/sec:      1.36MB</code></pre>
<p>avgRT为43ms，则在1s单位时间内，能串行处理23个请求。因此QPS = 23 * 200 = 4600个，和测试结果差不多。但在真实环境应该会更低。</p>
<p>并发300测试</p>
<pre><code class="shell">root@LAPTOP-6HNUFCIN:/usr/bin# wrk -t 11 -c 300 -d 30s --latency  http
://127.0.0.1:8281/api/test
Running 30s test @ http://127.0.0.1:8281/api/test
  11 threads and 300 connections
  Thread Stats   Avg      Stdev     Max   +/- Stdev
    Latency    63.50ms   35.50ms 358.22ms   58.62%
    Req/Sec   432.67     56.40     0.92k    69.47%
  Latency Distribution
     50%   64.55ms
     75%   87.37ms
     90%  108.46ms
     99%  155.62ms
  142058 requests in 30.03s, 42.16MB read
  Non-2xx or 3xx responses: 142058
Requests/sec:   4729.85
Transfer/sec:      1.40MB</code></pre>
<p>增加并发数QPS基本保持不变，验证了<code>QPS(TPS) = 并发数 / 平均响应时间</code></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
  </entry>
  <entry>
    <title>redis基础</title>
    <url>/2021/03/30/redis/2021_03_30-redis%E5%9F%BA%E7%A1%80/</url>
    <content><![CDATA[<h4 id="redis数据结构"><a href="#redis数据结构" class="headerlink" title="redis数据结构"></a>redis数据结构</h4><h5 id="string"><a href="#string" class="headerlink" title="string"></a>string</h5><ol>
<li><strong>介绍</strong> ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 <strong>简单动态字符串</strong>（simple dynamic string，<strong>SDS</strong>）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。</li>
<li><strong>常用命令:</strong> <code>set,get,strlen,exists,dect,incr,setex</code> 等等。</li>
<li><strong>应用场景</strong> ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。</li>
</ol>
<h5 id="list"><a href="#list" class="headerlink" title="list"></a>list</h5><ol>
<li><strong>介绍</strong> ：<strong>list</strong> 即是 <strong>链表</strong>。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 <strong>LinkedList</strong>，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 <strong>双向链表</strong>，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</li>
<li><strong>常用命令:</strong> <code>rpush,lpop,lpush,rpop,lrange、llen</code> 等。</li>
<li><strong>应用场景:</strong> 发布与订阅或者说消息队列、慢查询。</li>
</ol>
<p><strong>通过 <code>rpush/lpop</code> 实现队列：</strong></p>
<pre><code>127.0.0.1:6379&gt; rpush myList value1 # 向 list 的头部（右边）添加元素
(integer) 1
127.0.0.1:6379&gt; rpush myList value2 value3 # 向list的头部（最右边）添加多个元素
(integer) 3
127.0.0.1:6379&gt; lpop myList # 将 list的尾部(最左边)元素取出
&quot;value1&quot;
127.0.0.1:6379&gt; lrange myList 0 1 # 查看对应下标的list列表， 0 为 start,1为 end
1) &quot;value2&quot;
2) &quot;value3&quot;
127.0.0.1:6379&gt; lrange myList 0 -1 # 查看列表中的所有元素，-1表示倒数第一
1) &quot;value2&quot;
2) &quot;value3&quot;</code></pre>
<p><strong>通过 <code>rpush/rpop</code> 实现栈：</strong></p>
<pre><code>127.0.0.1:6379&gt; rpush myList2 value1 value2 value3
(integer) 3
127.0.0.1:6379&gt; rpop myList2 # 将 list的头部(最右边)元素取出
&quot;value3&quot;</code></pre>
<h5 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h5><ol>
<li><strong>介绍</strong> ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，<strong>特别适合用于存储对象</strong>，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。</li>
<li><strong>常用命令：</strong> <code>hset,hmset,hexists,hget,hgetall,hkeys,hvals</code> 等。</li>
<li><strong>应用场景:</strong> 系统中对象数据的存储。</li>
</ol>
<h5 id="set"><a href="#set" class="headerlink" title="set"></a>set</h5><ol>
<li><strong>介绍 ：</strong> set 类似于 Java 中的 <code>HashSet</code> 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。</li>
<li><strong>常用命令：</strong> <code>sadd,spop,smembers,sismember,scard,sinterstore,sunion</code> 等。</li>
<li><strong>应用场景:</strong> 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景</li>
</ol>
<h5 id="sortset"><a href="#sortset" class="headerlink" title="sortset"></a>sortset</h5><ol>
<li><strong>介绍：</strong> 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。</li>
<li><strong>常用命令：</strong> <code>zadd,zcard,zscore,zrange,zrevrange,zrem</code> 等。</li>
<li><strong>应用场景：</strong> 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。</li>
</ol>
<h5 id="bitmap"><a href="#bitmap" class="headerlink" title="bitmap"></a>bitmap</h5><ol>
<li><strong>介绍 ：</strong> bitmap 存储的是连续的二进制数字（0 和 1），也是key-value的形式存储，value的最大长度有2^32个bit位。</li>
<li><strong>常用命令：</strong> <code>setbit</code> 、<code>getbit</code> 、<code>bitcount</code>、<code>bitop</code></li>
<li><strong>应用场景:</strong> 适合需要保存状态信息（比如是否签到、是否登录…）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。</li>
</ol>
<p>实例：用户点赞视频</p>
<pre><code>public void test7() &#123;

    //随机用户点赞视频最大为1000次
    //多次运行先前的设置的bit位也还是会存在的
    for (int i = 0; i &lt; 1000; i++) &#123;

        double d = Math.random() * 100000;
        long loc = (long) d;
        redisTemplate.opsForValue().setBit(&quot;videoLike&quot;, loc, true);
    &#125;

    //获取视频点赞的用户数
    System.out.println(redisTemplate.execute(new RedisCallback() &#123;
        @Override
        public Object doInRedis(RedisConnection connection) throws DataAccessException &#123;
            //connection的bitcount方法参数直接接收bytes，需要先转换再传进去
            Jackson2JsonRedisSerializer&lt;String&gt; stringJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer&lt;&gt;(String.class);
            byte[] videoLikes = stringJackson2JsonRedisSerializer.serialize(&quot;videoLike&quot;);
            return connection.bitCount(videoLikes);
        &#125;
    &#125;));
&#125;</code></pre>
<h4 id="redis过期时间"><a href="#redis过期时间" class="headerlink" title="redis过期时间"></a>redis过期时间</h4><p>redis通过过期字典来保存数据的过期时间，字典的键保存的是数据的key地址，value是一个long long类型，保存的是指向的数据的过期时间</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210401182302.png" alt="redis过期时间" loading="lazy"></p>
<h4 id="redis的过期删除策略"><a href="#redis的过期删除策略" class="headerlink" title="redis的过期删除策略"></a>redis的过期删除策略</h4><p>redis有两种过期删除策略</p>
<ul>
<li><p>惰性删除策略</p>
<p>只有当取出key的时候才会对数据进行过期检查，对cpu比较友好</p>
</li>
<li><p>定时删除策略</p>
<p>每隔一段时间抽取一批key来执行删除操作，对内存友好</p>
</li>
</ul>
<p>redis采用惰性+定时的删除策略来管理设定了过期的数据</p>
<ul>
<li><p>缺点</p>
<p>即使采用惰性+定时的删除策略也会有过期的数据没有被找到，导致有大量的过期的key存在于内存中，从而发生OOM</p>
</li>
</ul>
<h4 id="redis内存淘汰策略"><a href="#redis内存淘汰策略" class="headerlink" title="redis内存淘汰策略"></a>redis内存淘汰策略</h4><p>redis加入内存淘汰策略来应对内存溢出的情况，有以下6种</p>
<ol>
<li><strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li>
<li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li>
<li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li>
<li><strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li>
<li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li>
<li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li>
</ol>
<p>4.0 版本后增加以下两种：</p>
<ol>
<li><strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li>
<li><strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li>
</ol>
<h4 id="redis持久化机制"><a href="#redis持久化机制" class="headerlink" title="redis持久化机制"></a>redis持久化机制</h4><p>redis有两种持久化机制，分别是RDB(快照）和AOF（追加写入)</p>
<ul>
<li><p>RDB</p>
<p>redis通过创建快照的方式来获得某一时刻内存中的数据作为副本，用于还原数据或者拷贝到其他服务器中（主从结构）</p>
<p>快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：</p>
<pre><code>save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。

save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</code></pre>
</li>
<li><p>AOF</p>
<p>AOF比RDB的实时性更好，每次修改数据都会写入到硬盘中，目前已经是主流的配置方法。</p>
<p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p>
<pre><code>appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度
appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘
appendfsync no        #让操作系统决定何时进行同步</code></pre>
<p>一般为了兼顾性能，采用<code>appendfsync everysec</code>,这样即使出现故障了，最多也就丢失了一秒的数据。</p>
</li>
</ul>
<h4 id="redis事务"><a href="#redis事务" class="headerlink" title="redis事务"></a>redis事务</h4><p>redis事务就是将多条命令打包然后按顺序执行。</p>
<p>redis没有回滚功能，也就是不支持原子性。redis团队认为命令执行错误（redis认为只有程序执行错误才会导致执行命令失败）应该发生在开发过程，而不是在生产过程因此不支持回滚。</p>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>redis缓存穿透</title>
    <url>/2021/04/01/redis/2021_04_01-%E7%BC%93%E5%AD%98case/</url>
    <content><![CDATA[<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>当大量的请求的key没有落在redis的缓存上时，从而直接请求数据库，导致数据库压力瞬间增大。</p>
<p>解决方法</p>
<ul>
<li><p>缓存不存在的key，并设置过期时间。如果key是变化的，那么起到的作用是比较小的</p>
</li>
<li><p>布隆过滤器</p>
<p>具体做法就是将所有可能存在的key放在布隆过滤器中，当请求过滤时，现在布隆过滤器中查找请求的key是否存在，存在就走正常缓存查询流程，不存在就直接返回错误信息。</p>
<p><strong>判断一个元素是否存在于布隆过滤器的时候，进行的操作：</strong></p>
<ol>
<li><p>对给定元素再次进行相同的哈希计算；</p>
</li>
<li><p>得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。</p>
</li>
</ol>
<p>从布隆过滤器判断元素是否存在的操作可以知道一定会有不同的key计算出来的hash是相同的，因此会出现误判的情况。</p>
<p>总结就是<strong>布隆过滤器会存在小概率误判的情况，如果判定key不存在那么它就一定是不存在的。</strong></p>
</li>
</ul>
<h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><p>缓存雪崩描述的是<strong>缓存中大量数据同时失效，导致大量的请求直接请求数据库，让数据库短时间压力突然增大，从而可能引发宕机的情况</strong>。</p>
<p>解决方法</p>
<ol>
<li>采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li>
<li>限流，避免同时处理大量的请求。</li>
</ol>
<h4 id="缓存一致性"><a href="#缓存一致性" class="headerlink" title="缓存一致性"></a>缓存一致性</h4><p>当数据发生改变时，为了让数据库和缓存中数据保持一致性，推荐的做法是采用<strong>Cache Aside Pattern</strong>（旁路缓存模式）:</p>
<p>对于读请求：</p>
<ul>
<li>读cache，cache hit，返回数据；cache miss，读db，set cache 再返回再读db</li>
</ul>
<p>对于写请求：</p>
<ol>
<li>操作数据库</li>
<li>delete cache</li>
</ol>
<p>思考:</p>
<ul>
<li><p>写请求为什么不是set缓存而是delete缓存</p>
<p>并发写情况下，无论是先操作数据库还是先set更新，都有可能出现缓存不一致的情况</p>
<ol>
<li>请求1先操作数据库，请求2后操作数据库</li>
<li>请求2先更新缓存，请求1后更新缓存</li>
</ol>
</li>
<li><p>对于写请求为什么先操作数据库</p>
<p>并发读写情况下，如果先delete缓存，会出现缓存不一致的情况</p>
<ol>
<li>写请求delete缓存</li>
<li>写请求操作数据库（主从同步没有完成）</li>
<li>读请求读cache（cache miss）</li>
<li>读请求读取从库（旧数据）</li>
<li>读请求set cache（旧数据）</li>
<li>主从同步完成</li>
</ol>
</li>
<li><p>对于写请求先操作数据库是否完美？</p>
<p>先操作数据库也会存在数据库操作成功，delete cache缓存失败的情况，常用的解决方法就是采用重试机制(比如rabbitmq的消息机制）来delete cache。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>redis</category>
      </categories>
  </entry>
  <entry>
    <title>类加载</title>
    <url>/2021/03/05/java/jvm/2021_03_05-%E7%B1%BB%E5%8A%A0%E8%BD%BD/</url>
    <content><![CDATA[<h4 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h4><p>类加载有三个阶段：</p>
<ul>
<li><p>加载</p>
<p>将class文件转换成字节流，并将静态数据转成方法区的运行时数据结构，然后在堆中生成一个Class对象</p>
</li>
<li><p>链接</p>
<ul>
<li><p>验证</p>
<p>验证class文件中的字节流是否符合虚拟机的要求，包括有<strong>文件格式的验证，元数据的验证，字节码验证，符号引用验证</strong></p>
</li>
<li><p>准备</p>
<p>为类变量分配内存及并设置类变量初始值，该阶段类变量的初始值是jvm中各数据类型的默认初始值</p>
</li>
<li><p>解析</p>
<p>将常量池中的<strong>符号引用</strong>替换为<strong>直接引用</strong>的过程</p>
</li>
</ul>
</li>
<li><p>初始化</p>
<p>执行类构造器<clinit>()方法的过程，类构造器方法是由静态代码块及类变量赋值语句收集而成，收集的顺序取决于它们在源代码中的先后顺序。</p>
<ul>
<li><p>tips</p>
<p>类构造器方法不需要显示调用父类构造器方法，虚拟机会在子类类构造器方法调用前先调用父类类构造器方法。因此父类类构造器中的赋值语句会优先执行</p>
<p>如果类/接口没有静态代码块及对类变量进行赋值的操作，那么编译器就不会生成类构造方法</p>
<p>接口执行类构造器方法时如果没有使用父类的变量，那么就不会执行父类类构造器方法</p>
<p>虚拟机保证在多线程环境下只能由一个线程去执行类构造器方法</p>
</li>
</ul>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210305142142.png" alt="img" loading="lazy"></p>
<center>类加载过程图</center>

<h4 id="类装载器"><a href="#类装载器" class="headerlink" title="类装载器"></a>类装载器</h4><ol>
<li><p>java中默认类加载器有三个</p>
<ol>
<li><p>BootStrap(不是java类）</p>
<p>加载java核心库 rt.jar</p>
</li>
<li><p>ExtClassloader</p>
<p>加载扩展类，加载java_home/jre/lib/ext下jar包</p>
</li>
<li><p>AppClassLoader</p>
<p>加载classpath下的class及jar包</p>
</li>
</ol>
<p>也可以自定义类加载器，一般开发中用不到</p>
</li>
<li><p>类加载机制（双亲委派机制）</p>
<p>当一个类加载器收到了类加载请求，它不会立马去加载，而是向上委托父类加载，父类没有则才由自己加载。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210305142805.jpg" alt="img" loading="lazy"></p>
<h4 id="类初始化时机"><a href="#类初始化时机" class="headerlink" title="类初始化时机"></a>类初始化时机</h4><p>主动引用（一定会发生初始化）</p>
<ol>
<li>要执行的main函数所在的类要进行初始化</li>
<li>new一个类对象</li>
<li>调用一个类变量（常量除外）及静态方法</li>
<li>对类进行反射调用</li>
<li>初始化一个类时，父类若没有初始化，则会先初始化父类</li>
</ol>
<p>被动引用（不会发生初始化）</p>
<ol>
<li><p>调用类的常量（链接阶段就存入调用类的常量池）</p>
</li>
<li><p>数组定义类引用</p>
<pre><code class="java">B[] bs = new B[4];</code></pre>
</li>
<li><p>访问静态域时，只有声明了这个静态域的类会被初始化</p>
<p>例：B1继承B，B1调用B中的类变量m（B1.m)，只有B会被初始化</p>
</li>
</ol>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JVM调优</title>
    <url>/2023/03/12/java/jvm/JVM%E8%B0%83%E4%BC%98/</url>
    <content><![CDATA[<h4 id="调优原则"><a href="#调优原则" class="headerlink" title="调优原则"></a>调优原则</h4><p>JVM调优不是常规手段，性能问题一般第一选择是优化程序，最后的选择才是进行JVM调优。</p>
<h4 id="调优时机"><a href="#调优时机" class="headerlink" title="调优时机"></a>调优时机</h4><ul>
<li>Heap内存（老年代）持续上涨达到设置的最大内存值；</li>
<li>Full GC 次数频繁；</li>
<li>GC 停顿时间过长（超过1秒）；</li>
<li>应用出现OutOfMemory 等内存异常；</li>
<li>应用中有使用本地缓存且占用大量内存空间；</li>
<li>系统吞吐量与响应性能不高或下降。</li>
</ul>
<h4 id="调优指标"><a href="#调优指标" class="headerlink" title="调优指标"></a>调优指标</h4><ul>
<li>延迟：GC低停顿和GC低频率</li>
<li>低内存占用</li>
<li>高吞吐量</li>
</ul>
<p>三者不可兼得，任何一个属性提高，几乎是于其他属性的性能损失为代价</p>
<h4 id="调优步骤"><a href="#调优步骤" class="headerlink" title="调优步骤"></a>调优步骤</h4><p>一般情况下，JVM调优可通过以下步骤进行：</p>
<ul>
<li>分析GC日志及dump文件，判断是否需要优化，确定瓶颈问题点；</li>
<li>确定JVM调优量化目标；</li>
<li>确定JVM调优参数（根据历史JVM参数来调整）；</li>
<li>依次调优内存、延迟、吞吐量等指标；</li>
<li>对比观察调优前后的差异；</li>
<li>不断的分析和调整，直到找到合适的JVM参数配置；</li>
<li>找到最合适的参数，将这些参数应用到所有服务器，并进行后续跟踪。</li>
</ul>
<h4 id="JVM参数"><a href="#JVM参数" class="headerlink" title="JVM参数"></a>JVM参数</h4><p>一般调优都是调整JVM堆参数</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230312025734.png" loading="lazy"></p>
<p><strong>1.8版本</strong></p>
<p>在1.8版本中Permanent generation已经被Meta space替换了，Meta space参数如下</p>
<table>
<thead>
<tr>
<th align="left">参数名称</th>
<th align="left">含义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-XX:MetaspaceSize</td>
<td align="left">初始元空间大小</td>
</tr>
<tr>
<td align="left">-XX:MaxMetaspaceSize</td>
<td align="left">最大元空间</td>
</tr>
</tbody></table>
<p><strong>语法规则</strong></p>
<p>布尔类型参数值：</p>
<ul>
<li>-XX:+ ‘+’表示启用该选项</li>
<li>-XX:- ‘-‘表示关闭该选项</li>
</ul>
<p>数字类型参数值：</p>
<ul>
<li>-XX:=给选项设置一个数字类型值，可跟随单位，例如：’m’或’M’表示兆字节;’k’或’K’千字节;’g’或’G’千兆字节。32K与32768是相同大小的。</li>
</ul>
<p>字符串类型参数值：</p>
<ul>
<li>-XX:=给选项设置一个字符串类型值，通常用于指定一个文件、路径或一系列命令列表。例如：-XX:HeapDumpPath=./dump.core</li>
</ul>
<p>示例：</p>
<pre><code class="bash">java  -Xmx4g –Xms4g –Xmn1200m –Xss512k -XX:NewRatio=4 -XX:SurvivorRatio=8 -XX:PermSize=100m -XX:MaxPermSize=256m -XX:MaxTenuringThreshold=15 -jar xxx.jar</code></pre>
<h4 id="性能监控工具"><a href="#性能监控工具" class="headerlink" title="性能监控工具"></a>性能监控工具</h4><p><strong>JDK自带工具</strong></p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230312031532.png" loading="lazy"></p>
<p>Linux命令行工具</p>
<table>
<thead>
<tr>
<th align="left">命令</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">top</td>
<td align="left">实时显示正在执行进程的 CPU 使用率、内存使用率以及系统负载等信息</td>
</tr>
<tr>
<td align="left">vmstat</td>
<td align="left">对操作系统的虚拟内存、进程、CPU活动进行监控</td>
</tr>
<tr>
<td align="left">pidstat</td>
<td align="left">监控指定进程的上下文切换</td>
</tr>
<tr>
<td align="left">iostat</td>
<td align="left">监控磁盘IO</td>
</tr>
</tbody></table>
<p>参考：</p>
<p><a href="https://www.alibabacloud.com/blog/how-to-properly-plan-jvm-performance-tuning_594663" title="How to Properly Plan JVM Performance Tuning">How to Properly Plan JVM Performance Tuning</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1812722" title="JVM调优总结">JVM调优总结</a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>JVM Architecture</title>
    <url>/2023/03/10/java/jvm/jvm%20architecture/</url>
    <content><![CDATA[<h4 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h4><p><img src="https://raw.githubusercontent.com/soda1/img/main/20230310143101.png" loading="lazy"></p>
<p>JVM架构如图所示，主要分为ClassLoader Subsystem， Runtime Data Area，Execution Engine</p>
<h4 id="ClassLoader-Subsystem"><a href="#ClassLoader-Subsystem" class="headerlink" title="ClassLoader Subsystem"></a>ClassLoader Subsystem</h4><p>它的职能主要是动态加载创建类对象，类在第一次被引用时就需要创建类对象，一个类对象被创建包含Loading、Linking、initialization三个阶段。</p>
<h5 id="Loading"><a href="#Loading" class="headerlink" title="Loading"></a>Loading</h5><p>在Loading阶段有3个类加载器用来加载Class文件</p>
<ol>
<li><p>BootStrap ClassLoader（启动类加载器）</p>
<p>加载<code>$JAVA_HOME/jre/lib</code>路径的核心类（rt.jar etc)，它是所有加载器的顶级父类</p>
</li>
<li><p>Extension ClassLoader（扩展类加载器）</p>
<p>加载<code>$JAVA_HOME/jre/lib/ext</code>路径下的类或在系统属性<code>java.ext.dirs</code>列出的目录，它的上层父类是BootStrap ClassLoader</p>
</li>
<li><p>Application ClassLoader（应用程序类加载器）</p>
<p>现在叫做System ClassLoader，用于加载应用路径下的类，它的上层父类是Extension ClassLoader</p>
</li>
</ol>
<h5 id="Delegation-Hierarchy-Algorithm"><a href="#Delegation-Hierarchy-Algorithm" class="headerlink" title="Delegation Hierarchy Algorithm"></a><strong>Delegation Hierarchy Algorithm</strong></h5><p>中文习惯叫双亲委派机制，哪个家伙起的名，真的谢谢。<strong>主要思想就是在需要加载一个类的时候优先由其父类加载器进行尝试加载，如果父类加载器不能加载才有当前类路径下的加载器进行加载</strong></p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230310173929.jpg" loading="lazy"></p>
<p>目的：避免同一个类被多次加载，保证Java稳定允许</p>
<h5 id="Linking"><a href="#Linking" class="headerlink" title="Linking"></a>Linking</h5><ol>
<li><p>Verify</p>
<p>验证class文件中的字节流是否符合虚拟机的要求，包括有<strong>文件格式的验证，元数据的验证，字节码验证，符号引用验证</strong></p>
</li>
<li><p>Prepare</p>
<p>对静态变量进行内存分配，并赋予初始值</p>
</li>
<li><p>Resolve</p>
<p>将方法区对象内的运行时常量池中的符号引用解析成直接引用</p>
<blockquote>
<p>When a Java class is compiled, all references to variables and methods are stored in the class’s constant pool as a symbolic reference. A symbolic reference is a logical reference not a reference that actually points to a physical memory location. The JVM implementation can choose when to resolve symbolic references, this can happen when the class file is verified, after being loaded, called eager or static resolution, instead this can happen when the symbolic reference is used for the first time called lazy or late resolution. However the JVM has to behave as if the resolution occurred when each reference is first used and throw any resolution errors at this point. Binding is the process of the field, method or class identified by the symbolic reference being replaced by a direct reference, this only happens once because the symbolic reference is completely replaced. If the symbolic reference refers to a class that has not yet been resolved then this class will be loaded. Each direct reference is stored as an offset against the storage structure associated with the runtime location of the variable or method.</p>
</blockquote>
</li>
</ol>
<h5 id="Initialization"><a href="#Initialization" class="headerlink" title="Initialization"></a>Initialization</h5><p>所有静态变量都会被赋予初始值，静态代码块将会被执行</p>
<h4 id="Runtime-Data-Area"><a href="#Runtime-Data-Area" class="headerlink" title="Runtime Data Area"></a>Runtime Data Area</h4><p>这个是Java内存管理区域，以下图分析会比较清晰</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230311015106.png" loading="lazy"></p>
<p><strong>Non Heap</strong></p>
<ul>
<li><p>method area</p>
<p>方法区用于存储每个Class对象的信息：</p>
<ul>
<li>Classloader Reference</li>
<li>Field data</li>
<li>Run Time Constant Pool</li>
<li>Method data</li>
<li>Method code</li>
</ul>
</li>
<li><p>interned String 字符串常量池，在1.8版本它被移到Heap里面了</p>
</li>
</ul>
<p>**Heap **</p>
<p>所有的对象实例都会存储在堆这里，为所有线程共享</p>
<p>generation及垃圾回收内容查看<a href="#Garbage-Collector">Garbage Collector</a></p>
<p><strong>Stack</strong></p>
<p>每个线程都有以下三个组件</p>
<ol>
<li><p>Program Counter</p>
<p>PC用于存储当前指令运行位置的，如果当前调用的native方法，那么PC值为undefine，JVM用PC来跟踪其执行指令位置，方便在线程在获得cpu时间片后继续运行下去</p>
</li>
<li><p>Stack</p>
<p>按照先进后出规则执行，由存储调用方法的栈帧组成，每个栈帧包含如下信息：</p>
<ul>
<li>本地变量数组（基本类型，对象引用）</li>
<li>返回值</li>
<li>操作数栈</li>
<li>执行方法地址</li>
</ul>
</li>
<li><p>Native Stack</p>
<p>类似于Stack</p>
</li>
</ol>
<h4 id="Execution-Engine"><a href="#Execution-Engine" class="headerlink" title="Execution Engine"></a>Execution Engine</h4><h5 id="Interpreter"><a href="#Interpreter" class="headerlink" title="Interpreter"></a><strong>Interpreter</strong></h5><p>用于解释字节码，将其转换成系统识别指令，使其能运行。缺点在于每次执行方法都要先解释一遍</p>
<h5 id="JIT-Compiler"><a href="#JIT-Compiler" class="headerlink" title="JIT Compiler"></a><strong>JIT Compiler</strong></h5><p>用于改正解释器缺点，当代码第一次运行时会使用解释器来解释代码，后面如果发现有重复代码时，会使用JIT编译器，将代码编译成native code。native code将直接用于重复方法的调用，从而提高系统性能</p>
<h5 id="Garbage-Collector"><a href="#Garbage-Collector" class="headerlink" title="Garbage Collector"></a><strong>Garbage Collector</strong></h5><p>垃圾回收器用于回收无用对象，从而释放内存，防止内存泄露。Java中的垃圾回收是自动的，也可以通过调用<code>System.gc()</code>来触发</p>
<h6 id="无用对象定义"><a href="#无用对象定义" class="headerlink" title="无用对象定义"></a><strong>无用对象定义</strong></h6><p>在Java中有一些对象被称为 <strong>Garbage Collection Roots</strong>（GC Roots)，它们在垃圾回收中被作为Root对象来用于进行可达性分析。如下图所示，如果一个对象和任何GC Root间不存在<strong>引用链</strong>，那么就说明该对象是无用对象</p>
<blockquote>
<p>Every object tree must have one or more root objects. As long as the application can reach those roots, the whole tree is reachable.But when are those root objects considered reachable? Special objects called garbage-collection roots (GC roots; see Figure below) are always reachable and so is any object that has a garbage-collection root at its own root.</p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230311031540.jpg" loading="lazy"></p>
<p>有4种类型GC Roots</p>
<ul>
<li>Local variables</li>
<li>Static variables</li>
<li>Active Java threads </li>
<li>JNI References</li>
</ul>
<p><strong>回收器针对Java引用类型回收策略</strong></p>
<ul>
<li><p>Strong Reference（强引用）</p>
<p>只要可达GC root就不会回收</p>
</li>
<li><p>Soft Reference（软引用）</p>
<p>内存空间不足的时候就会被回收</p>
</li>
<li><p>Weak Reference（弱应用）</p>
<p>只要被垃圾回收期扫描到就会回收</p>
</li>
<li><p>Phantom Reference（虚引用）</p>
<p>任何时候都会被回收</p>
</li>
</ul>
<h6 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h6><ul>
<li><p>标记 — 清除算法</p>
<p>将可回收对象先标记出来，然后再清除。这种算法会造成内存碎片，导致本来有足够的容量来分配给新的对象，但却无法分配</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230311033334.png" loading="lazy"></p>
</li>
<li><p>复制算法</p>
<p>复制算法从标记-清除算法演进而来，解决了内存碎片化问题。将内存分为均等两块，每次只用一块，当一块内存用完时，就将存活的对象搬到另一块去，然后把直接清理内存空间。算法的弊端在于只能使用一半的内存</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230311033405.png" loading="lazy"></p>
</li>
<li><p>标记整理算法</p>
<p>标记整理算法中标记过程和标记清除算法一致，然后整理时存活对象会向一端移动，最后清除存活对象边界以外的内存区域。由于内存的频繁移动，在效率上会比复制算法差</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230311033431.png" loading="lazy"></p>
</li>
</ul>
<h6 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h6><p>大多数对象的生命周期都是非常短的，只有少部分的对象会一直存在，因此JVM将Heap分成了几部分，如下面官方图所示</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230311160312.png" loading="lazy"></p>
<ul>
<li><p>Young Generation</p>
<p>新创建对象会被分配在年轻代的Eden区里面，当Eden区满后会触发Minor GC，存活下来的对象会进入Survivor区且被标记年龄 = 1，而原先在Survivor区继续存活下来的对象则年龄+1，然后将Eden区清空</p>
<p>Survivor区又细分为S0和S1两个区，原因在于Survivor区的对象也会有被清理掉的可能性，这样会产生内存碎片，JVM采用了复制算法来整理内存</p>
<p>在经历多轮的GC后，Survivor中存活的对象一旦达到年轻代设置的年龄上限后会进入老年代，还有一些特殊的情况会直接进入老年区：</p>
<ul>
<li>当对象无法放入Survivor区</li>
<li>当大对象无法放入清理后的Eden区</li>
</ul>
<p>年轻代Minor GC具体流程查看<a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html">Java Garbage Collection Basics</a></p>
</li>
<li><p>Old Generation</p>
<p>老年代用于放置长期存活的对象，当老年代无法存放新的对象时会触发Major GC，对老年代进行垃圾回收，释放内存</p>
</li>
<li><p>Permanent generation</p>
<p>永久代存储的是Class对象及方法，对应JVM结构中的方法区，触发Full GC时会对永久代进行垃圾回收</p>
<p>永久代不属于Heap，上面的官方图是从generation的角度来解释其内存结构，下面图可以很好描述</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230311171414.png" loading="lazy"></p>
<p>在1.8版本使用 Meta space来替代Permanent generation</p>
</li>
</ul>
<h6 id="垃圾回收器"><a href="#垃圾回收器" class="headerlink" title="垃圾回收器"></a>垃圾回收器</h6><ul>
<li><p>The Serial GC</p>
<p>串行化收集器，Minor 和Major GC都是串行进行的，即单线程。使用标记整理算法，存在Stop The World问题</p>
<p>应用场景：适合客户端模式下的虚拟机（需要比较少的内存）</p>
<p>使用：<code>-XX:+UseSerialGC</code></p>
</li>
<li><p>The Parallel GC</p>
<p>并行收集器使用多线程来对年轻代进行垃圾回收，默认使用CPU个数的线程进程回收，存在Stop The World问题</p>
<p>应用场景：适用于追求高吞吐量，不需要太多交互</p>
<p>使用：</p>
<ul>
<li><code>-XX:+UseParallelGC</code>：年轻代回收使用多线程，老年代回收使用的单线程</li>
<li><code>-XX:+UseParallelOldGC</code>：年轻代老年代都是用多线程</li>
</ul>
<p>老年代都使用标记-整理算法，年轻代用复制算法</p>
</li>
<li><p>The Concurrent Mark Sweep (CMS) Collector</p>
<p>CMS是一种以并发的方式进行垃圾回收，以最短回收卡顿时间为目标的收集器，主要用于老年代，采用标记-清除算法，会造成碎片化问题，引发Full GC，导致临时使用Serial GC进行老年代垃圾回收</p>
<p>CMS用于年轻代时和并行收集器采用同样算法</p>
<p>应用场景：重视服务器响应速度，要求系统停顿时间最短。</p>
<p>使用：<code>-XX:+UseConcMarkSweepGC</code></p>
</li>
<li><p>The G1 Garbage Collector</p>
<p>G1收集器设计用于取代CMS，具有并发、并行，低卡顿时间等特点。G1整体来看使用标记-整理算法，局部使用复制算法</p>
<p>应用场景：面向服务端应用</p>
<p>使用：<code>-XX:+UseG1GC</code></p>
</li>
</ul>
<p>参考：</p>
<p><a href="https://dzone.com/articles/jvm-architecture-explained" title="The JVM Architecture Explained">The JVM Architecture Explained</a></p>
<p><a href="https://blog.jamesdbloom.com/JVMInternals.html" title="JVM Internals">JVM Internals</a></p>
<p><a href="https://dzone.com/articles/jvm-memory-architecture-and-gc" title="JVM Memory Architecture and GC Algorithm Basics">JVM Memory Architecture and GC Algorithm Basics</a></p>
<p><a href="https://dzone.com/articles/java-memory-management" title="Java Memory Management">Java Memory Management</a></p>
<p><a href="https://www.w3resource.com/java-tutorial/garbage-collection-in-java.php" title="Garbage Collection in Java">Garbage Collection in Java</a></p>
<p><a href="https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html" title="Java Garbage Collection Basics">Java Garbage Collection Basics</a></p>
<p><a href="https://blog.jamesdbloom.com/JVMInternals.html" title="JVM Internals"></a></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>lambda method reference</title>
    <url>/2021/03/11/java/lambda/2021_03_11-method%20reference/</url>
    <content><![CDATA[<h4 id="方法引用种类"><a href="#方法引用种类" class="headerlink" title="方法引用种类"></a>方法引用种类</h4><h5 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h5><ul>
<li><p>A static method (<code>ClassName::methName</code>)</p>
<p>函数接口参数和静态方法参数对应</p>
<pre><code class="java">//sum(int, int ) apply(T t, U u)
BiFunction&lt;Integer, Integer, Integer&gt; sumFunc = Integer::sum;
System.out.println(sumFunc.apply(5, 7));</code></pre>
</li>
</ul>
<h5 id="成员方法"><a href="#成员方法" class="headerlink" title="成员方法"></a>成员方法</h5><ul>
<li><p>An instance method of a particular object (<code>instanceRef::methName</code>)</p>
<p>decr签名方法为<code>(Mysum, Integer, Integer)Integer</code>，这里Mysum绑定为this，由于实例mysum是固定的，因此方法签名变成了<code>（Integer, Integer)Integer</code> 。因此也符合BiFunction接口，参数一致。</p>
<pre><code class="java">        MySum mySum = new MySum();
        BiFunction&lt;Integer, Integer, Integer&gt; sumFunc1 = mySum::decr;
        System.out.println(sumFunc1.apply(6, 3));

        class MySum implements Serializable &#123;

            Integer a = 4;

            public Integer decr(Integer b, Integer c) &#123;

                return this.a + b + c;
            &#125;

</code></pre>
</li>
</ul>
<pre><code>      &#125;</code></pre>
<pre><code>
- An instance method of an arbitrary object of a particular type (`ClassName::methName`)

lambda会将this作为第一个参数，因此insMethod的方法签名为(MySum, Integer)Integer。和BiFunction接口方法签名一致。
</code></pre>
<p>  MySum mySum1 = new MySum();<br>  BiFunction&lt;MySum, Integer, Integer&gt; sumFunc2 = MySum::insMethod;<br>  System.out.println(sumFunc2.apply(mySum, 2));</p>
<p>  class MySum implements Serializable {</p>
<pre><code> Integer a = 4;

  public  Integer insMethod(Integer integer) &#123;

      return this.a + integer;
  &#125;</code></pre>
<p>  }</p>
<pre><code>
- 总结

如果使用成员方法，界定符::前面如果是实例this是固定的，签名方法会省略this，如果是Class, this就不能省略。

##### 类构造器

- A class constructor reference (`ClassName::new`)

构造器的选择由接口函数来确定。

&gt; If a class has multiple constructors, the target type&#39;s method signature is used to select the best match in the same way that a constructor invocation is resolved.
&gt;
&gt; If the class to instantiate is generic, type arguments can be provided after the class name, or they are inferred as for a &quot;diamond&quot; constructor invocation.

```java
Supplier&lt;MySum&gt; sumSupplier = MySum::new;
//泛型构造器
Function&lt;String, MySum&gt; function = MySum::new;
Function&lt;Integer, MySum&gt; function2 = MySum::new;

System.out.println(&quot;default constructor: &quot; + &quot;a：&quot; + sumSupplier.get().a + &quot; c：&quot; + sumSupplier.get().c);
System.out.println(&quot;my constructor: &quot; + &quot;a：&quot; + function2.apply(5).a  + &quot; c：&quot; + function2.apply(5).c);
System.out.println(&quot;my constructor: &quot; + &quot;a：&quot; + function.apply(&quot;hello&quot;).a  + &quot; c：&quot; + function.apply(&quot;hello&quot;).c);

class MySum implements Serializable &#123;

       T c;
    Integer a = 4;
    public MySum(T c) &#123;
        this.c = c;
    &#125;
    public MySum(Integer a) &#123;
        this.a = a;
    &#125;

    public MySum() &#123;
        System.out.println(&quot;empty constructor&quot;);
    &#125;
&#125;</code></pre>
<h5 id="数组构造器"><a href="#数组构造器" class="headerlink" title="数组构造器"></a>数组构造器</h5><ul>
<li><p>An array constructor reference (<code>TypeName[]::new</code>)</p>
<pre><code class="java">IntFunction&lt;MySum[]&gt; arrayMaker = MySum[]::new;
MySum[] array = arrayMaker.apply(10);</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>thread and thread poll useage</title>
    <url>/2021/03/05/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2021_03_05-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%9F%BA%E6%9C%AC/</url>
    <content><![CDATA[<h4 id="线程实现的三种方式"><a href="#线程实现的三种方式" class="headerlink" title="线程实现的三种方式"></a>线程实现的三种方式</h4><ol>
<li><p>继承Thread,重写run方法</p>
<pre><code class="java">public class MyThread extends Thread&#123;

    @Override
    public void run() &#123;
        System.out.println(&quot;thread start&quot;);
        try &#123;
            sleep(2000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;thread end&quot;);
    &#125;
&#125;</code></pre>
</li>
<li><p>实现Runable接口</p>
<pre><code class="java">class MyRunable implements Runnable &#123;

    public void run() &#123;
        System.out.println(&quot;thread start&quot;);
        try &#123;
            sleep(2000);
            for (int i = 0; i &lt; 100; i++) &#123;
                if (i % 10 == 0) &#123;
                    System.out.println(&quot;yield&quot;);
                    Thread.yield();

                &#125;
                System.out.println(i);
            &#125;
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;thread end&quot;);
    &#125;</code></pre>
<p>调用</p>
<pre><code class="java">  public static void main(String[] args) &#123;
        MyThread myThread = new MyThread();
        //启动线程
        myThread.start();

        Thread thread = new Thread(new MyRunable());
        //启动线程
        thread.start();
    &#125;</code></pre>
</li>
</ol>
<ol start="3">
<li><p>实现Callable接口</p>
<p>Callable可以返回结果及抛出异常</p>
<pre><code class="java">        //需要使用FutureTask来封装才能丢入线程中执行
        FutureTask task = new FutureTask(() -&gt;&#123;
            System.out.println(&quot;2s后返回&quot;);
            TimeUnit.SECONDS.sleep(2);
            return &quot;hello&quot;;
        &#125;);
        Thread thread = new Thread(task);
        thread.start();
        System.out.println(task.get());
    &#125;
</code></pre>
<p>Thread并没有带有Callable接口的构造器，需要FutureTask封装后丢入线程</p>
</li>
</ol>
<h4 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h4><p>java中线程的状态有6种，定义在Thread.State枚举中</p>
<ul>
<li><p>NEW </p>
<p>程序new一个线程实例</p>
</li>
<li><p>RUNNABLE</p>
<p>线程处于运行状态，java将READY和RUNNING包括在了RUNNABLE中，线程调用start方法后处于就绪状态，等待cpu时间片的分配。获取时间片后处于RUNNING状态</p>
</li>
<li><p>WAITING</p>
<p>线程处于等待状态，会释放当前拥有的锁，等待唤醒</p>
</li>
<li><p>TIMED_WAITING</p>
<p>线程退出指定时间，超时后返回</p>
</li>
<li><p>BLOCKED</p>
<p>线程获取同步锁被阻塞</p>
</li>
<li><p>TERMINATED</p>
<p>线程执行完成</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210305183945.png" alt="img" loading="lazy"></p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><h5 id="工具类（Executors）"><a href="#工具类（Executors）" class="headerlink" title="工具类（Executors）"></a>工具类（Executors）</h5><pre><code class="java">
    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;
        ExecutorService executorService = Executors.newFixedThreadPool(10);

        //runnable接口
        executorService.execute(() -&gt;&#123;
            try &#123;
                //验证main线程在执行shutdown方法后，是不是等待线程执行完毕后才会往下执行
                Thread.sleep(2000);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
            System.out.println(Thread.currentThread().getName());
        &#125;);

        //callable接口
        Future str = executorService.submit(() -&gt;&#123;
            Thread.sleep(5000);
            return &quot;hello&quot;;
        &#125;);

        //调用get方法会阻塞当前线程，直到获取结果
        System.out.println(str.get());
        executorService.shutdown();
        System.out.println(&quot;任务完成&quot;);
    &#125;</code></pre>
<p>execute:用于执行实现了runnable接口的的任务</p>
<p>submit：用于执行实现callable接口的任务，可以返回结果</p>
<p>shutdown：关闭连接池，等任务执行完后关闭连接池</p>
<p>shotdownNow:停止所有正在执行的任务</p>
<h5 id="Executor接口"><a href="#Executor接口" class="headerlink" title="Executor接口"></a>Executor接口</h5><p>Executor是核心接口，它定义了执行任务的方法（execute）</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210308162248.png" alt="image-20210308162248448" loading="lazy"></p>
<p>ThreadPoolExecutor是ExecutorService的重要实现类，ScheduledThreadPoolExecutor支持周期性的任务调度，它继承了ThreadPoolExecutor，不过一般用不到，有更好的任务调度框架，如quarter。</p>
<h5 id="ThreadPoolExecutor简单分析"><a href="#ThreadPoolExecutor简单分析" class="headerlink" title="ThreadPoolExecutor简单分析"></a>ThreadPoolExecutor简单分析</h5><h6 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h6><p>有4个构造函数，拿最长的构造函数分析（其他的同理）</p>
<pre><code class="java">public ThreadPoolExecutor(int corePoolSize,
                          int maximumPoolSize,
                          long keepAliveTime,
                          TimeUnit unit,
                          BlockingQueue&lt;Runnable&gt; workQueue,
                          ThreadFactory threadFactory,
                          RejectedExecutionHandler handler)</code></pre>
<p>参数：</p>
<ul>
<li>corePoolSize：定义线程核心池的大小</li>
<li>maximumPoolSize：定义线程池的最大值</li>
<li>long keepAliveTime：定义空余线程的存活时间，超出核心线程池大小的部分线程，如果空闲下来后超过keepAliveTime就会释放</li>
<li>unit：keepAliveTime 的时间基本单位</li>
<li>workQueue：任务队列，线程池使用达到最大值后，后面进来的任务都会先进入任务队列保存</li>
<li>threadFactory：创建线程时使用，一般默认即可</li>
<li>handler：当线程池满载后（线程池达到最大数量，工作队列达到最大）时，执行的策略<ul>
<li>AbortPolicy：直接丢弃新进来的任务，且抛出RejectedExecutionException</li>
<li>DiscardOldestPolicy：丢弃最老的未执行的任务</li>
<li>CallerRunsPolicy：用调用了excute()方法的线程来执行新进来的任务</li>
<li>DiscardPolicy：丢弃任务并且不报错</li>
</ul>
</li>
</ul>
<h6 id="实战例子"><a href="#实战例子" class="headerlink" title="实战例子"></a>实战例子</h6><pre><code class="java">public static void main(String[] args) &#123;
    int coreSize = 5;
    int maximumSize = 10;
    int keepLongLiveTime = 1;
    int workCapacity = 10;
    ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(coreSize, maximumSize, keepLongLiveTime, TimeUnit.MINUTES,
            new ArrayBlockingQueue&lt;&gt;(workCapacity), new ThreadPoolExecutor.CallerRunsPolicy());

    for (int i = 0; i &lt; 30; i++) &#123;
        threadPoolExecutor.execute(() -&gt;&#123;
            System.out.println(Thread.currentThread().getName());
        &#125;);
    &#125;

&#125;</code></pre>
<p>tips：</p>
<p>​    满载执行完任务后，在经过了线程生存时间后，留下来的不一定是原先最开始创建的5个线程。比如开始创建的线程名为 1-5</p>
<p>​    执行完任务后留下来的可能是 2，3，5，7，8。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210308173323.png" alt="image-20210308173323360" loading="lazy"></p>
<h6 id="原理分析"><a href="#原理分析" class="headerlink" title="原理分析"></a>原理分析</h6><p>​    <img src="https://github.com/Snailclimb/JavaGuide/raw/master/docs/java/multi-thread/images/java%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/%E5%9B%BE%E8%A7%A3%E7%BA%BF%E7%A8%8B%E6%B1%A0%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86.png" alt="图解线程池实现原理" loading="lazy"></p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>this escape</title>
    <url>/2021/03/09/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2021_03_09-this%E9%80%83%E9%80%B8%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<p><a href="https://www.javaspecialists.eu/archive/Issue192-Implicit-Escape-of-this.html">Implicit Escape of ‘this’</a></p>
<p><strong>总结：</strong></p>
<p>​    this逃逸问题就是一个对象在还没有完全初始化的时候就将未完全初始化的值传递给其他对象，导致出现预期之外的问题。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>volatile理解</title>
    <url>/2021/03/09/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/2021_03_09-volatile/</url>
    <content><![CDATA[<h4 id="内存不可见性"><a href="#内存不可见性" class="headerlink" title="内存不可见性"></a>内存不可见性</h4><p>在java中，如果多个线程去操作同一个共享变量，有可能会造成结果的不一致。</p>
<p>例子</p>
<pre><code class="java">public class VolatileTest &#123;

    int i = 0;

    public static void main(String[] args) throws InterruptedException &#123;

        VolatileTest volatileTest = new VolatileTest();
        new Thread(() -&gt; &#123;
                try &#123;
                    TimeUnit.SECONDS.sleep(1);
                    volatileTest.i = 9;
                &#125; catch (InterruptedException e) &#123;
                    e.printStackTrace();
            &#125;
        &#125;).start();
        new Thread(() -&gt; &#123;

            while (true) &#123;
//                System.out.println(&quot;hello&quot;);
//                System.out.println(a.isFlage());
                if (volatileTest.i != 0) &#123;
                    System.out.println(volatileTest.i);
                    break;
                &#125;
            &#125;
        &#125;).start();
    &#125;
&#125;</code></pre>
<p>上面例子开启两个线程，第一个线程将i变量设置成9，线程2循环判断i是否为0，非0就跳出循环</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210309141404.png" alt="image-20210309141404750" loading="lazy"></p>
<p>程序一直在运行，说明线程2读到的i值一致为0，这就是内存的不可见性，CPU有L1/L2/L3缓存，线程运行时会将变量copy到缓存中，CUP读取变量顺序为：缓存-&gt;主内存。因此如果其他线程更改了变量并刷新到主存了，由于缓存的关系，当前线程读取到的仍是旧值。</p>
<h4 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h4><p>volatile关键字用于修饰变量，它的作用就是保持内存的可见性，强制要求去读取主存中的值，对上述的i变量增加volatile关键字</p>
<pre><code class="java">volatile int i = 0;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210309142321.png" alt="image-20210309142321136" loading="lazy"></p>
<p>线程2就可以读到更新的值了</p>
<h4 id="System-out-println刷新变量的值"><a href="#System-out-println刷新变量的值" class="headerlink" title="System.out.println刷新变量的值"></a>System.out.println刷新变量的值</h4><p>在上述例子中，如果在线程2中使用System.out.println来打印变量i的值，那么就会强制刷新缓存。</p>
<pre><code class="java">public void println(int x) &#123;
    synchronized (this) &#123;
        print(x);
        newLine();
    &#125;
&#125;</code></pre>
<p>从源码可以看到使用了synchronized，他会刷新缓存，从而可以读到最新的值。在做这个测试的时候使用了打印函数的话就有可能疑惑为什么和预期的结果有出入。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>understand ThreadLocal</title>
    <url>/2020/10/22/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/ThreadLocal/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>ThreadLocal类主要是为了让每个线程都有一个专属的本地变量。如果创建一个ThreadLocal共享变量，每个线程去访问时（set/get方法访问）都会创建这个变量的本地副本，从而保证了线程安全。</p>
<a id="more"></a>

<h3 id="demo"><a href="#demo" class="headerlink" title="demo"></a>demo</h3><pre><code class="java">public class ThreadLocalDemo &#123;

    private static ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyyMMdd hhmm&quot;));

/*
    等价于
    private static ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = new ThreadLocal&lt;SimpleDateFormat&gt;()&#123;
        @Override
        protected SimpleDateFormat initialValue() &#123;
            return new SimpleDateFormat(&quot;yyyyMMdd hhmm&quot;);
        &#125;
    &#125;;
*/


    public static void main(String[] args) &#123;

        new Thread(() -&gt;&#123;
            System.out.println(threadLocal.get().toPattern());
            threadLocal.set(new SimpleDateFormat());
            System.out.println(threadLocal.get().toPattern());
        &#125;).start();

        new Thread(() -&gt;&#123;
            try &#123;
                Thread.sleep(5000);
                System.out.println(threadLocal.get().toPattern());
                threadLocal.set(new SimpleDateFormat());
                System.out.println(threadLocal.get().toPattern());
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;).start();

    &#125;
&#125;
//结果
yyyyMMdd hhmm
yy-M-d ah:mm
yyyyMMdd hhmm
yy-M-d ah:mm</code></pre>
<p>从结果可以看到两个线程使用同一个ThreadLocal对象没有受到其他线程的影响。</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><pre><code class="java">   public Thread()&#123;
    * by the ThreadLocal class. */
    ThreadLocal.ThreadLocalMap threadLocals = null;
    /*
     * InheritableThreadLocal values pertaining to this thread. This map is
     * maintained by the InheritableThreadLocal class.
     */
    ThreadLocal.ThreadLocalMap inheritableThreadLocals = null;
   &#125;</code></pre>
<p>从Thread源码入手，可以看到Thread里面定义了两个ThreadLocalMap对象，初始化为null。ThreadLocalMap是在ThreadMap类里面的，可以将ThreadLocalMap当成一个没有链表的HashMap，只有数组。</p>
<p>接下来看下当调用ThreadLocal的set和get方法时，它是怎么实现数据绑定到当前线程的。</p>
<pre><code class="java">public T get() &#123;
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null) &#123;
            ThreadLocalMap.Entry e = map.getEntry(this);
            if (e != null) &#123;
                @SuppressWarnings(&quot;unchecked&quot;)
                T result = (T)e.value;
                return result;
            &#125;
        &#125;
        return setInitialValue();
    &#125;

public void set(T value) &#123;
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
    &#125;</code></pre>
<p>set方法里面是直接获取当前线程的ThreadLocalMap进行判断，如果不为null，就将ThreadLocal对象作为key（因此线程可以将多个ThreadLocal对象保存为本地变量），value为输入值，如果为null就给当前线程创建ThreadLocalMap并赋值。</p>
<p>get方法也是差不多的逻辑，需要注意的是setInitialValue方法，它会去调用InitialValue方法来获取初始值，如果你没有去重写这个方法，在没有进行set赋值的情况，直接使用get方法会返回null。</p>
<pre><code class="java">private T setInitialValue() &#123;
        T value = initialValue();
        Thread t = Thread.currentThread();
        ThreadLocalMap map = getMap(t);
        if (map != null)
            map.set(this, value);
        else
            createMap(t, value);
        return value;
    &#125;
protected T initialValue() &#123;
        return null;
    &#125;</code></pre>
<h3 id="内存泄漏问题"><a href="#内存泄漏问题" class="headerlink" title="内存泄漏问题"></a>内存泄漏问题</h3><p>ThreadLocalMap的key是一个<strong>弱引用</strong>，所以如果ThreadLocal对象外部没有强引用的时候，在GC时会其将回收，这时线程里面的ThreadLocalMap的<strong>key为null</strong>的Entry，如果我们没有采取措施，value可能永远没有办法进行回收，因此可能会产生内存泄漏。</p>
<pre><code class="java"> /**
         * The entries in this hash map extend WeakReference, using
         * its main ref field as the key (which is always a
         * ThreadLocal object).  Note that null keys (i.e. entry.get()
         * == null) mean that the key is no longer referenced, so the
         * entry can be expunged from table.  Such entries are referred to
         * as &quot;stale entries&quot; in the code that follows.
         */
        static class Entry extends WeakReference&lt;ThreadLocal&lt;?&gt;&gt; &#123;
            /** The value associated with this ThreadLocal. */
            Object value;

            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;
                super(k);
                value = v;
            &#125;
        &#125;</code></pre>
<h4 id="代码演示"><a href="#代码演示" class="headerlink" title="代码演示"></a>代码演示</h4><pre><code class="java">public class ThreadLocalDemo &#123;

    private static ThreadLocal&lt;SimpleDateFormat&gt; threadLocal = ThreadLocal.withInitial(() -&gt; new SimpleDateFormat(&quot;yyyyMMdd hhmm&quot;));
    private static ThreadLocal&lt;String&gt; threadLocal1 = new ThreadLocal&lt;String&gt;()&#123;

        @Override
        protected String initialValue() &#123;
            return &quot;hello&quot;;
        &#125;
    &#125;;
    public static void main(String[] args) &#123;
        new Thread(() -&gt;&#123;
                System.out.println(threadLocal.get().toPattern());
                threadLocal.set(new SimpleDateFormat());
                System.out.println(threadLocal.get().toPattern());
                Thread thread = Thread.currentThread();
                threadLocal1.get();
                while (true) &#123;

                &#125;
        &#125;).start();
        try &#123;
            Thread.sleep(5000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        threadLocal1 = null;
        threadLocal = null;
        System.gc();
    &#125;</code></pre>
<p>下图为代码运时进行GC后子线程的threadLocals变量图，可以看到两个Entry对象都出现了key为null的情况</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201022175558768.png" alt="image-20201022175558768" loading="lazy"></p>
<h4 id="为什么key不使用强引用"><a href="#为什么key不使用强引用" class="headerlink" title="为什么key不使用强引用"></a>为什么key不使用强引用</h4><p>如果使用强引用，即使线程外部没有了ThreadLocal对象的强引用了，但线程中仍有强引用指向ThreadLocal对象导致无法回收，如果使用线程池，可能会导致内存泄漏。</p>
<h4 id="ThreadLocalMap对于内存泄漏的处理"><a href="#ThreadLocalMap对于内存泄漏的处理" class="headerlink" title="ThreadLocalMap对于内存泄漏的处理"></a>ThreadLocalMap对于内存泄漏的处理</h4><p>ThreadMap中的getEntry和set和remove方法都对key为null做了清除。但这样并不是保险，如果我下次使用该线程不会再调用set/get方法，那么就会永远无法清除，因此每次使用完线程都要手动remove一下。</p>
<pre><code class="java">private void set(ThreadLocal&lt;?&gt; key, Object value) &#123;

            // We don&#39;t use a fast path as with get() because it is at
            // least as common to use set() to create new entries as
            // it is to replace existing ones, in which case, a fast
            // path would fail more often than not.

            Entry[] tab = table;
            int len = tab.length;
            int i = key.threadLocalHashCode &amp; (len-1);

            for (Entry e = tab[i];
                 e != null;
                 e = tab[i = nextIndex(i, len)]) &#123;
                ThreadLocal&lt;?&gt; k = e.get();

                if (k == key) &#123;
                    e.value = value;
                    return;
                &#125;

                if (k == null) &#123;
                    replaceStaleEntry(key, value, i);
                    return;
                &#125;
            &#125;

            tab[i] = new Entry(key, value);
            int sz = ++size;
            if (!cleanSomeSlots(i, sz) &amp;&amp; sz &gt;= threshold)
                rehash();
        &#125;</code></pre>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>ThreadLocal类似于钩子，每次使用get/set方法都会为线程提供一个本地变量</p>
<p>ThreadLocalMap采用弱引用是为了保证GC能够回收对象，但会发生内存泄漏，虽然ThreadLocalMap也做了处理，但我们还是要在使用完后手动remove</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>synchronized用法</title>
    <url>/2020/10/21/java/%E5%A4%9A%E7%BA%BF%E7%A8%8B/synchronized/</url>
    <content><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>synchronized关键字解决的是多线程下访问资源的同步性，它保证在任意时刻被它修饰的代码块或方法只有一个线程可以执行。</p>
<a id="more"></a>

<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><h4 id="修饰代码块"><a href="#修饰代码块" class="headerlink" title="修饰代码块"></a>修饰代码块</h4><p>synchronized可以指定给某个对象加锁，任何线程只有获取了这个对象的锁才可以执行代码里面的内容。    </p>
<pre><code class="java">public class SynchronizedTest &#123;

    public void synchronizedCodeBlock() &#123;
        System.out.println(Thread.currentThread().getName() + &quot;开始执行CodeBlock方法&quot;);
        synchronized (this) &#123;
            System.out.println(Thread.currentThread().getName() + &quot;进入同步代码块&quot;);
            try &#123;
                Thread.sleep(3000);
                System.out.println(Thread.currentThread().getName() + &quot;执行完同步代码块&quot;);
            &#125; catch (InterruptedException e) &#123;
                e.printStackTrace();
            &#125;
        &#125;
    &#125;
    public static void main(String[] args) &#123;

        SynchronizedTest synchronizedTest = new SynchronizedTest();
        //测试同步代码块
        new Thread(() -&gt; &#123;
                synchronizedTest.synchronizedCodeBlock();
        &#125;).start();

        new Thread(() -&gt; &#123;

                synchronizedTest.synchronizedCodeBlock();
        &#125;).start();

    &#125;

&#125;

//执行结果
Thread-0开始执行CodeBlock方法
Thread-0进入同步代码块
Thread-1开始执行CodeBlock方法
Thread-0执行完同步代码块
Thread-1进入同步代码块
Thread-1执行完同步代码块
</code></pre>
<p>从执行结果可以看到，当两个并发线程去访问同一个对象（synchronizedTest）用synchronized修饰的代码块时（两个线程访问的锁对象要相同），只能有一个线程可以同时访问，当Thread-0访问时，Thread-1是阻塞的。</p>
<h4 id="修饰方法"><a href="#修饰方法" class="headerlink" title="修饰方法"></a>修饰方法</h4><p>当synchronized修饰对象方法时，它锁住的是当前对象。</p>
<pre><code class="Java">public class SynchronizedTest &#123;
    public synchronized void synchronizedMethod() &#123;
        try &#123;
            System.out.println(Thread.currentThread().getName() + &quot;进入锁方法了&quot;);
            Thread.sleep(3000);
            System.out.println(Thread.currentThread().getName() + &quot;退出锁方法了&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;
    public static void main(String[] args) &#123;

        SynchronizedTest synchronizedTest = new SynchronizedTest();
        //测试同步方法
        new Thread(() -&gt;&#123;
            synchronizedTest.synchronizedMethod();&#125;).start();
        new Thread(() -&gt;&#123;
            synchronizedTest.synchronizedMethod();
        &#125;).start();

    &#125;
&#125;
//测试结果
Thread-0进入锁方法了
Thread-0退出锁方法了
Thread-1进入锁方法了
Thread-1退出锁方法了</code></pre>
<p>从执行结果可以看到，两个并发线程去访问同一对象synchronized修饰的方法时，同一时刻只能有一个线程访问该方法。</p>
<p>当synchronized修饰的是静态方法时，它锁住的是类对象</p>
<pre><code class="java">public class SynchronizedTest &#123;

   public synchronized static void synchronizedStatic() &#123;
        try &#123;
            System.out.println(Thread.currentThread().getName() + &quot;进入锁方法了&quot;);
            Thread.sleep(3000);
            System.out.println(Thread.currentThread().getName() + &quot;退出锁方法了&quot;);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
    &#125;

    public static void main(String[] args) &#123;

        SynchronizedTest synchronizedTest = new SynchronizedTest();
        SynchronizedTest synchronizedTest1 = new SynchronizedTest();
        //测试同步静态方法
        new Thread(() -&gt;&#123;
            synchronizedTest.synchronizedStatis();
        &#125;).start();

        new Thread(() -&gt;&#123;
            synchronizedTest1.synchronizedStatis();
        &#125;).start();

    &#125;
//测试结果
Thread-0进入锁方法了
Thread-0退出锁方法了
Thread-1进入锁方法了
Thread-1退出锁方法了</code></pre>
<p>从执行结果可看到并发线程是保持线程同步的，虽然新建了两个对象放在不同线程去执行同步静态方法，但是由于锁的是类对象，所以还是保持了线程同步。</p>
<h4 id="修饰类"><a href="#修饰类" class="headerlink" title="修饰类"></a>修饰类</h4><p>修饰类时，锁住的对象是类对象，demo就不写了</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>synchronized关键字修饰方法或代码块时，只要作用的对象不是静态的，那么它锁住的就是对象；修饰静态方法或类时，它锁住的是类。</p>
]]></content>
      <categories>
        <category>java</category>
      </categories>
  </entry>
  <entry>
    <title>DDL数据库定义语言</title>
    <url>/2020/11/09/mysql/%E5%9F%BA%E7%A1%80/2020_11_9-DDL/</url>
    <content><![CDATA[<h3 id="库管理"><a href="#库管理" class="headerlink" title="库管理"></a>库管理</h3><h4 id="一、创建库"><a href="#一、创建库" class="headerlink" title="一、创建库"></a>一、创建库</h4><ul>
<li>create database 【if not exists】 库名【 character set 字符集名】;</li>
</ul>
<h4 id="二、修改库"><a href="#二、修改库" class="headerlink" title="二、修改库"></a>二、修改库</h4><ul>
<li>alter database 库名 character set 字符集名;</li>
</ul>
<h4 id="三、删除库"><a href="#三、删除库" class="headerlink" title="三、删除库"></a>三、删除库</h4><ul>
<li>drop database 【if exists】 库名;</li>
</ul>
<h3 id="表管理"><a href="#表管理" class="headerlink" title="表管理"></a>表管理</h3><h4 id="一、创建表-★"><a href="#一、创建表-★" class="headerlink" title="一、创建表 ★"></a>一、创建表 ★</h4><pre><code class="sql">--建表常用
create table [if not exists] 表名(
    col_name data_type [constraint]
    |[INDEX | KEY] [index_name] (key_part,...)
    | CONSTRAINT [foreign_key_name]  FOREIGN KEY (col_name) REFERENCES tab_name (col_name)
)engine  innodb, character set utf8

 create table  if not exists actor(
    actor_id smallint(5) not null primary key,
    first_name varchar(45) not null ,
    last_name varchar(45) not null ,
    last_update date not null,
    user_id INT not NULL,
    constraint fh foreign key (user_id)  references user(id)
)engine innodb, character set utf8;</code></pre>
<h4 id="二、修改表"><a href="#二、修改表" class="headerlink" title="二、修改表"></a>二、修改表</h4><ul>
<li>1.添加列<ul>
<li>alter table 表名 add column 列名 类型 【first|after 字段名】;</li>
</ul>
</li>
<li>2.修改列的类型或约束<ul>
<li>alter table 表名 modify column 列名 新类型 【新约束】;</li>
</ul>
</li>
<li>3.修改列名<ul>
<li>alter table 表名 change column 旧列名 新列名 类型;</li>
</ul>
</li>
<li>4 .删除列<ul>
<li>alter table 表名 drop column 列名;</li>
</ul>
</li>
<li>5.修改表名<ul>
<li>alter table 表名 rename 【to】 新表名;</li>
</ul>
</li>
</ul>
<h4 id="三、删除表"><a href="#三、删除表" class="headerlink" title="三、删除表"></a>三、删除表</h4><ul>
<li>drop table【if exists】 表名;</li>
</ul>
<h4 id="四、复制表"><a href="#四、复制表" class="headerlink" title="四、复制表"></a>四、复制表</h4><ul>
<li>1、复制表的结构<ul>
<li>create table 表名 like 旧表;</li>
</ul>
</li>
<li>2、复制表的结构+数据<ul>
<li>create table 表名<br>select 查询列表 from 旧表【where 筛选】;</li>
</ul>
</li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><h4 id="一、数值型"><a href="#一、数值型" class="headerlink" title="一、数值型"></a>一、数值型</h4><ul>
<li><p>1、整型</p>
<ul>
<li>tinyint、smallint、mediumint、int/integer、bigint<br>1                  2                    3                 4                   8</li>
<li>特点：<ul>
<li>①都可以设置无符号和有符号，默认有符号，通过unsigned设置无符号<br>②如果超出了范围，会报out or range异常，插入临界值<br>③长度可以不指定，默认会有一个长度<br>长度代表显示的最大宽度，如果不够则左边用0填充，但需要搭配zerofill，并且默认变为无符号整型</li>
</ul>
</li>
</ul>
</li>
<li><p>2、浮点型</p>
</li>
<li><p>定点数：decimal(M,D)</p>
</li>
<li><p>浮点数:</p>
<pre><code>float(M,D)   4
  double(M,D)  8</code></pre>
<ul>
<li>特点：<ul>
<li>①M代表整数部位+小数部位的个数，D代表小数部位<br>②如果超出范围，则报out or range异常，并且插入临界值<br>③M和D都可以省略，但对于定点数，M默认为10，D默认为0<br>④如果精度要求较高，则优先考虑使用定点数</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="二、字符型"><a href="#二、字符型" class="headerlink" title="二、字符型"></a>二、字符型</h4><ul>
<li><p>char、varchar、binary、varbinary、enum、set、text、blob</p>
</li>
<li><p>char：固定长度的字符，写法为char(M)，最大长度不能超过M，其中M可以省略，默认为1</p>
</li>
<li><p>varchar：可变长度的字符，写法为varchar(M)，最大长度不能超过M，其中M不可以省略</p>
</li>
</ul>
<h4 id="三、日期型"><a href="#三、日期型" class="headerlink" title="三、日期型"></a>三、日期型</h4><ul>
<li>year年<br>date日期<br>time时间<br>datetime 日期+时间          8<br>timestamp 日期+时间         4   比较容易受时区、语法模式、版本的影响，更能反映当前时区的真实时间</li>
</ul>
<h3 id="常见约束"><a href="#常见约束" class="headerlink" title="常见约束"></a>常见约束</h3><h4 id="一、常见的约束"><a href="#一、常见的约束" class="headerlink" title="一、常见的约束"></a>一、常见的约束</h4><ul>
<li>NOT NULL：非空，该字段的值必填</li>
<li>UNIQUE：唯一，该字段的值不可重复</li>
<li>DEFAULT：默认，该字段的值不用手动插入有默认值</li>
<li>CHECK：检查，mysql不支持</li>
<li>PRIMARY KEY：主键，该字段的值不可重复并且非空  unique+not null</li>
<li>FOREIGN KEY：外键，该字段的值引用了另外的表的字段</li>
</ul>
<p>主键和唯一</p>
<ul>
<li>1、区别：<ul>
<li>①、一个表至多有一个主键，但可以有多个唯一</li>
<li>②、主键不允许为空，唯一可以为空</li>
</ul>
</li>
<li>2、相同点<ul>
<li>都具有唯一性</li>
<li>都支持组合键，但不推荐</li>
</ul>
</li>
</ul>
<p>外键：</p>
<ul>
<li><p>1、用于限制两个表的关系，从表的字段值引用了主表的某字段值</p>
</li>
<li><p>2、外键列和主表的被引用列要求类型一致，意义一样，名称无要求</p>
</li>
<li><p>3、主表的被引用列要求是一个key（一般就是主键）</p>
</li>
<li><p>4、插入数据，先插入主表</p>
</li>
<li><p>删除数据，先删除从表</p>
<ul>
<li><p>#方式一：级联删除</p>
<ul>
<li>ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE CASCADE;</li>
</ul>
</li>
<li><p>#方式二：级联置空</p>
<ul>
<li>ALTER TABLE stuinfo ADD CONSTRAINT fk_stu_major FOREIGN KEY(majorid) REFERENCES major(id) ON DELETE SET NULL;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="二、创建表时添加约束"><a href="#二、创建表时添加约束" class="headerlink" title="二、创建表时添加约束"></a>二、创建表时添加约束</h4><ul>
<li>create table 表名(<pre><code>字段名 字段类型 not null,#非空
  字段名 字段类型 primary key,#主键
  字段名 字段类型 unique,#唯一
  字段名 字段类型 default 值,#默认
  constraint 约束名 foreign key(字段名) references 主表（被引用列）</code></pre>
</li>
</ul>
<p>)</p>
<ul>
<li><p>注意：</p>
<ul>
<li><p>​                        支持类型                可以起约束名<br>列级约束        除了外键                不可以<br>表级约束        除了非空和默认    可以，但对主键无效</p>
</li>
<li><p>列级约束可以在一个字段上追加多个，中间用空格隔开，没有顺序要求</p>
</li>
</ul>
</li>
</ul>
<h4 id="三、修改表时添加或删除约束"><a href="#三、修改表时添加或删除约束" class="headerlink" title="三、修改表时添加或删除约束"></a>三、修改表时添加或删除约束</h4><ul>
<li><p>1、非空</p>
<ul>
<li>添加非空<ul>
<li>alter table 表名 modify column 字段名 字段类型 not null;</li>
</ul>
</li>
<li>删除非空<ul>
<li>alter table 表名 modify column 字段名 字段类型 ;</li>
</ul>
</li>
</ul>
</li>
<li><p>2、默认</p>
<ul>
<li>添加默认<ul>
<li>alter table 表名 modify column 字段名 字段类型 default 值;</li>
</ul>
</li>
<li>删除默认<ul>
<li>alter table 表名 modify column 字段名 字段类型 ;</li>
</ul>
</li>
</ul>
</li>
<li><p>3、主键</p>
<ul>
<li>添加主键<ul>
<li>alter table 表名 add【 constraint 约束名】 primary key(字段名);</li>
</ul>
</li>
<li>删除主键<ul>
<li>alter table 表名 drop primary key;</li>
</ul>
</li>
</ul>
</li>
<li><p>4、唯一</p>
<ul>
<li>添加唯一<ul>
<li>alter table 表名 add【 constraint 约束名】 unique(字段名);</li>
</ul>
</li>
<li>删除唯一<ul>
<li>alter table 表名 drop index 索引名;</li>
</ul>
</li>
</ul>
</li>
<li><p>5、外键</p>
<ul>
<li>添加外键<ul>
<li>alter table 表名 add【 constraint 约束名】 foreign key(字段名) references 主表（被引用列）;</li>
</ul>
</li>
<li>删除外键<ul>
<li>alter table 表名 drop foreign key 约束名;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="四、自增长列"><a href="#四、自增长列" class="headerlink" title="四、自增长列"></a>四、自增长列</h4><ul>
<li><p>特点：</p>
<ul>
<li>1、不用手动插入值，可以自动提供序列值，默认从1开始，步长为1t<ul>
<li>auto_increment_increment</li>
<li>如果要更改起始值：手动插入值</li>
<li>如果要更改步长：更改系统变量<ul>
<li>set auto_increment_increment=值;</li>
</ul>
</li>
</ul>
</li>
<li>2、一个表至多有一个自增长列</li>
<li>3、自增长列只能支持数值型</li>
<li>4、自增长列必须为一个key</li>
</ul>
</li>
<li><p>一、创建表时设置自增长列</p>
<ul>
<li>create table 表(<pre><code>字段名 字段类型 约束 auto_increment</code></pre>
)</li>
</ul>
</li>
<li><p>二、修改表时设置自增长列</p>
<ul>
<li>alter table 表 modify column 字段名 字段类型 约束 auto_increment</li>
</ul>
</li>
<li><p>三、删除自增长列</p>
<ul>
<li>alter table 表 modify column 字段名 字段类型 约束 </li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>base</category>
      </categories>
  </entry>
  <entry>
    <title>DML数据库操纵语言</title>
    <url>/2020/11/09/mysql/%E5%9F%BA%E7%A1%80/2020_11_9-DML/</url>
    <content><![CDATA[<h3 id="插入"><a href="#插入" class="headerlink" title="插入"></a>插入</h3><h4 id="一、方式一"><a href="#一、方式一" class="headerlink" title="一、方式一"></a>一、方式一</h4><ul>
<li>语法：<ul>
<li>insert into 表名[字段名,…] values(值,…);</li>
</ul>
</li>
<li>特点：<ul>
<li>1、要求值的类型和字段的类型要一致或兼容</li>
<li>2、字段的个数和顺序不一定与原始表中的字段个数和顺序一致<br>但必须保证值和字段一一对应</li>
<li>3、假如表中有可以为null的字段，注意可以通过以下两种方式插入null值<ul>
<li>①字段和值都省略</li>
<li>②字段写上，值使用null</li>
</ul>
</li>
<li>4、字段和值的个数必须一致</li>
<li>5、字段名可以省略，默认所有列</li>
</ul>
</li>
</ul>
<h4 id="二、方式二"><a href="#二、方式二" class="headerlink" title="二、方式二"></a>二、方式二</h4><ul>
<li>语法：<ul>
<li>insert into 表名 set 字段=值,字段=值,…;</li>
</ul>
</li>
</ul>
<h4 id="两种方式-的区别："><a href="#两种方式-的区别：" class="headerlink" title="两种方式 的区别："></a>两种方式 的区别：</h4><ul>
<li>1.方式一支持一次插入多行，语法如下：<ul>
<li>insert into 表名【(字段名,..)】 values(值，..),(值，…),…;</li>
</ul>
</li>
<li>2.方式一支持子查询，语法如下：<ul>
<li>insert into 表名<br>查询语句;</li>
</ul>
</li>
</ul>
<h4 id="insert…select-statement"><a href="#insert…select-statement" class="headerlink" title="insert…select statement"></a>insert…select statement</h4><ol>
<li><p>数据结构相同且没有表A中没有B的数据</p>
<pre><code>insert into table_A  select * from table_B</code></pre>
</li>
<li><p>复制某一字段</p>
<pre><code class="sql">insert into table_A (col_1, col_2) select col_1, col_2 from table_B where [condition]</code></pre>
</li>
</ol>
<h3 id="修改"><a href="#修改" class="headerlink" title="修改"></a>修改</h3><h4 id="一、修改单表的记录-★"><a href="#一、修改单表的记录-★" class="headerlink" title="一、修改单表的记录 ★"></a>一、修改单表的记录 ★</h4><ul>
<li>语法：update 表名 set 字段=值,字段=值 【where 筛选条件】;</li>
</ul>
<h4 id="二、修改多表的记录【补充】"><a href="#二、修改多表的记录【补充】" class="headerlink" title="二、修改多表的记录【补充】"></a>二、修改多表的记录【补充】</h4><ul>
<li>语法：<pre><code class="sql">update 表1 别名 
left|right|inner join 表2 别名 
on 连接条件  
set 字段=值,字段=值 
【where 筛选条件】;

</code></pre>
</li>
</ul>
<p>  –网络上的写法<br>  update table_A a set a.col_1 = (select b.col_1 from table_B b where a.col_2 = b.col_2)</p>
<p>  ```</p>
<p>  update是每一行只更新一次，根据这一行的值来更新值</p>
<p>  <img src="https://raw.githubusercontent.com/soda1/img/main/20201130220207.png" alt="image-20201130220207684" loading="lazy"></p>
<h3 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h3><h4 id="方式一：使用delete"><a href="#方式一：使用delete" class="headerlink" title="方式一：使用delete"></a>方式一：使用delete</h4><h5 id="一、删除单表的记录★"><a href="#一、删除单表的记录★" class="headerlink" title="一、删除单表的记录★"></a>一、删除单表的记录★</h5><ul>
<li>语法：delete from 表名 【where 筛选条件】【limit 条目数】</li>
</ul>
<h5 id="二、级联删除-补充"><a href="#二、级联删除-补充" class="headerlink" title="二、级联删除[补充]"></a>二、级联删除[补充]</h5><ul>
<li>语法：<ul>
<li>delete 别名1,别名2 from 表1 别名<br>inner|left|right join 表2 别名<br>on 连接条件<br> 【where 筛选条件】</li>
</ul>
</li>
</ul>
<h4 id="方式二：使用truncate（删除整表数据）"><a href="#方式二：使用truncate（删除整表数据）" class="headerlink" title="方式二：使用truncate（删除整表数据）"></a>方式二：使用truncate（删除整表数据）</h4><ul>
<li>语法：truncate table 表名</li>
</ul>
<h4 id="两种方式的区别【面试题】★"><a href="#两种方式的区别【面试题】★" class="headerlink" title="两种方式的区别【面试题】★"></a>两种方式的区别【面试题】★</h4><ul>
<li>1.truncate删除后，如果再插入，标识列从1开始<br>  delete删除后，如果再插入，标识列从断点开始</li>
<li>2.delete可以添加筛选条件<br> truncate不可以添加筛选条件</li>
<li>3.truncate效率较高</li>
<li>4.truncate没有返回值</li>
<li>delete可以返回受影响的行数</li>
<li>5.truncate不可以回滚</li>
<li>delete可以回滚</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>base</category>
      </categories>
  </entry>
  <entry>
    <title>DQL数据库查询语言</title>
    <url>/2020/11/09/mysql/%E5%9F%BA%E7%A1%80/2020_11_9-DQL/</url>
    <content><![CDATA[<h3 id="1、基础查询"><a href="#1、基础查询" class="headerlink" title="1、基础查询"></a>1、基础查询</h3><h4 id="一、语法"><a href="#一、语法" class="headerlink" title="一、语法"></a>一、语法</h4><p>select 查询列表  from 表名;</p>
<h4 id="二、特点"><a href="#二、特点" class="headerlink" title="二、特点"></a>二、特点</h4><ul>
<li>查询列表可以是字段、常量、表达式、函数，也可以是多个</li>
<li>查询结果是一个虚拟表</li>
</ul>
<h4 id="三、示例"><a href="#三、示例" class="headerlink" title="三、示例"></a>三、示例</h4><h5 id="查询单个字段"><a href="#查询单个字段" class="headerlink" title="查询单个字段"></a>查询单个字段</h5><ul>
<li>select 字段名 from 表名;</li>
</ul>
<h5 id="查询多个字段"><a href="#查询多个字段" class="headerlink" title="查询多个字段"></a>查询多个字段</h5><ul>
<li>select 字段名，字段名 from 表名;</li>
</ul>
<h5 id="查询所有字段"><a href="#查询所有字段" class="headerlink" title="查询所有字段"></a>查询所有字段</h5><ul>
<li>select * from 表名;</li>
</ul>
<h5 id="查询常量"><a href="#查询常量" class="headerlink" title="查询常量"></a>查询常量</h5><ul>
<li><p>select 常量值;</p>
</li>
<li><p>注意：字符型和日期型的常量值必须用单引号引起来，数值型不需要</p>
</li>
</ul>
<h5 id="查询函数"><a href="#查询函数" class="headerlink" title="查询函数"></a>查询函数</h5><ul>
<li>select 函数名(实参列表);</li>
</ul>
<h5 id="查询表达式"><a href="#查询表达式" class="headerlink" title="查询表达式"></a>查询表达式</h5><ul>
<li>select 100/1234;</li>
</ul>
<h5 id="起别名"><a href="#起别名" class="headerlink" title="起别名"></a>起别名</h5><ul>
<li><p>①as</p>
</li>
<li><p>②空格</p>
</li>
</ul>
<h5 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h5><ul>
<li>select distinct 字段名 from 表名;</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title="+"></a>+</h5><ul>
<li><p>作用：做加法运算</p>
</li>
<li><p>select 数值+数值; 直接运算</p>
</li>
<li><p>select 字符+数值;先试图将字符转换成数值，如果转换成功，则继续运算；否则转换成0，再做运算</p>
</li>
<li><p>select null+值;结果都为null</p>
</li>
</ul>
<h5 id="【补充】concat函数"><a href="#【补充】concat函数" class="headerlink" title="【补充】concat函数"></a>【补充】concat函数</h5><ul>
<li><p>功能：拼接字符</p>
</li>
<li><p>select concat(字符1，字符2，字符3,…);</p>
</li>
</ul>
<h5 id="【补充】ifnull函数"><a href="#【补充】ifnull函数" class="headerlink" title="【补充】ifnull函数"></a>【补充】ifnull函数</h5><ul>
<li><p>功能：判断某字段或表达式是否为null，如果为null 返回指定的值，否则返回原本的值</p>
</li>
<li><p>select ifnull(commission_pct,0) from employees;</p>
</li>
</ul>
<h5 id="【补充】isnull函数"><a href="#【补充】isnull函数" class="headerlink" title="【补充】isnull函数"></a>【补充】isnull函数</h5><ul>
<li>功能s：判断某字段或表达式是否为null，如果是，则返回1，否则返回0</li>
</ul>
<h3 id="2、条件查询"><a href="#2、条件查询" class="headerlink" title="2、条件查询"></a>2、条件查询</h3><h4 id="一、语法-1"><a href="#一、语法-1" class="headerlink" title="一、语法"></a>一、语法</h4><ul>
<li>select 查询列表 from 表名 where 筛选条件</li>
</ul>
<h4 id="二、筛选条件的分类"><a href="#二、筛选条件的分类" class="headerlink" title="二、筛选条件的分类"></a>二、筛选条件的分类</h4><h5 id="1、简单条件运算符"><a href="#1、简单条件运算符" class="headerlink" title="1、简单条件运算符"></a>1、简单条件运算符</h5><ul>
<li>&lt; 、 &gt;、=  、&lt;&gt;   != 、&gt;= 、&lt;= 、 &lt;=&gt;安全等于</li>
</ul>
<h5 id="2、逻辑运算符"><a href="#2、逻辑运算符" class="headerlink" title="2、逻辑运算符"></a>2、逻辑运算符</h5><p>&amp;&amp;、 and 、||、 or、  !、  not</p>
<h5 id="3、模糊查询"><a href="#3、模糊查询" class="headerlink" title="3、模糊查询"></a>3、模糊查询</h5><ul>
<li><p>like:一般搭配通配符使用，可以判断字符型或数值型  </p>
</li>
<li><p>通配符：%任意多个字符，_任意单个字符</p>
</li>
<li><p>between and</p>
</li>
<li><p>in</p>
</li>
<li><p>is null /is not null：用于判断null值</p>
</li>
<li><p>is null PK &lt;=&gt;</p>
<p>|         | 普通类型的数值 | null值 | 可读性 |<br>| :—–: | :————: | :—-: | :-updated: 2022-05-28 20:34:11<br>date: 2020-11-09 19:36:30<br>updated: 2022-05-28 20:34:11</p>
</li>
<li><p>–: |<br> | is null |       x        |   √    |   √    |<br> |   &lt;=&gt;   |       √        |   √    |   x    |</p>
</li>
</ul>
<h3 id="3、排序查询"><a href="#3、排序查询" class="headerlink" title="3、排序查询"></a>3、排序查询</h3><h4 id="一、语法-2"><a href="#一、语法-2" class="headerlink" title="一、语法"></a>一、语法</h4><ul>
<li>select 查询列表 from 表 where 筛选条件  order by 排序列表 【asc/desc】</li>
</ul>
<h4 id="二、特点-1"><a href="#二、特点-1" class="headerlink" title="二、特点"></a>二、特点</h4><ul>
<li><p>1、asc ：升序，如果不写默认升序<br>   desc：降序</p>
</li>
<li><p>2、排序列表 支持 单个字段、多个字段、函数、表达式、别名</p>
</li>
<li><p>3、order by的位置一般放在查询语句的最后（除limit语句之外）</p>
</li>
</ul>
<h3 id="4、常见函数"><a href="#4、常见函数" class="headerlink" title="4、常见函数"></a>4、常见函数</h3><h4 id="一、概述"><a href="#一、概述" class="headerlink" title="一、概述"></a>一、概述</h4><ul>
<li>功能：类似于java中的方法</li>
<li>好处：提高重用性和隐藏实现细节</li>
<li>调用：select 函数名(实参列表);</li>
</ul>
<h4 id="二、单行函数"><a href="#二、单行函数" class="headerlink" title="二、单行函数"></a>二、单行函数</h4><h5 id="1、字符函数"><a href="#1、字符函数" class="headerlink" title="1、字符函数"></a>1、字符函数</h5><ul>
<li>concat:连接</li>
<li>substr:截取子串</li>
<li>upper:变大写</li>
<li>lower：变小写</li>
<li>replace：替换</li>
<li>length：获取字节长度</li>
<li>trim:去前后空格</li>
<li>lpad：左填充</li>
<li>rpad：右填充</li>
<li>instr:获取子串第一次出现的索引</li>
</ul>
<h5 id="2、数学函数"><a href="#2、数学函数" class="headerlink" title="2、数学函数"></a>2、数学函数</h5><ul>
<li>ceil:向上取整</li>
<li>round：四舍五入</li>
<li>mod:取模</li>
<li>floor：向下取整</li>
<li>truncate:截断</li>
<li>rand:获取随机数，返回0-1之间的小数</li>
</ul>
<h5 id="3、日期函数"><a href="#3、日期函数" class="headerlink" title="3、日期函数"></a>3、日期函数</h5><ul>
<li>now：返回当前日期+时间</li>
<li>year:返回年</li>
<li>month：返回月</li>
<li>day:返回日</li>
<li>date_format:将日期转换成字符</li>
<li>curdate:返回当前日期</li>
<li>str_to_date:将字符转换成日期</li>
<li>curtime：返回当前时间</li>
<li>hour:小时</li>
<li>minute:分钟</li>
<li>second：秒</li>
<li>datediff:返回两个日期相差的天数</li>
<li>monthname:以英文形式返回月</li>
</ul>
<h5 id="4、其他函数"><a href="#4、其他函数" class="headerlink" title="4、其他函数"></a>4、其他函数</h5><ul>
<li>version 当前数据库服务器的版本</li>
<li>database 当前打开的数据库</li>
<li>user当前用户</li>
<li>password(‘字符’)：返回该字符的密码形式</li>
<li>md5(‘字符’):返回该字符的md5加密形式</li>
</ul>
<h5 id="5、流程控制函数"><a href="#5、流程控制函数" class="headerlink" title="5、流程控制函数"></a>5、流程控制函数</h5><ul>
<li><p>①if(条件表达式，表达式1，表达式2)：如果条件表达式成立，返回表达式1，否则返回表达式2</p>
</li>
<li><p>②case情况1</p>
<pre><code class="sql">case 变量或表达式或字段
    when 常量1 then 值1
    when 常量2 then 值2
    ...
else 值n
end</code></pre>
</li>
<li><p>③case情况2</p>
<pre><code class="sql">case 
when 条件1 then 值1
when 条件2 then 值2
...
else 值n
end</code></pre>
</li>
</ul>
<h4 id="三、分组函数"><a href="#三、分组函数" class="headerlink" title="三、分组函数"></a>三、分组函数</h4><h5 id="1、分类"><a href="#1、分类" class="headerlink" title="1、分类"></a>1、分类</h5><ul>
<li>max 最大值</li>
<li>min 最小值</li>
<li>sum 和</li>
<li>avg 平均值</li>
<li>count 计算个数</li>
</ul>
<h5 id="2、特点"><a href="#2、特点" class="headerlink" title="2、特点"></a>2、特点</h5><ul>
<li><p>①语法</p>
</li>
<li><p>select max(字段) from 表名;</p>
</li>
<li><p>②支持的类型</p>
<ul>
<li>sum和avg一般用于处理数值型<br>max、min、count可以处理任何数据类型</li>
</ul>
</li>
<li><p>③以上分组函数都忽略null</p>
</li>
<li><p>④都可以搭配distinct使用，实现去重的统计</p>
</li>
<li><p>select sum(distinct 字段) from 表;</p>
</li>
<li><p>⑤count函数</p>
<ul>
<li><p>count(字段)：统计该字段非空值的个数</p>
</li>
<li><p>count(*):统计结果集的行数</p>
</li>
<li><p>效率上：</p>
<ul>
<li>MyISAM存储引擎，count(*)最高<br>*</li>
<li><em>InnoDB存储引擎，count(</em>)和count(1)效率&gt;count(字段)</li>
</ul>
</li>
</ul>
</li>
<li><p>⑥ 和分组函数一同查询的字段，要求是group by后出现的字段</p>
</li>
<li><p>where 语句中不能出现分组函数</p>
</li>
</ul>
<h3 id="5、分组查询"><a href="#5、分组查询" class="headerlink" title="5、分组查询"></a>5、分组查询</h3><h4 id="一、语法-3"><a href="#一、语法-3" class="headerlink" title="一、语法"></a>一、语法</h4><ul>
<li>select 分组函数，分组后的字段 from 表<br>【where 筛选条件】group by 分组的字段 【having 分组后的筛选】<br>【order by 排序列表】</li>
</ul>
<h4 id="二、group-by，having理解"><a href="#二、group-by，having理解" class="headerlink" title="二、group by，having理解"></a>二、group by，having理解</h4><ul>
<li><p>group by</p>
<p><strong>group by 就是对已经查询好的结果集进行分组。</strong>查出了包含<strong>所有字段</strong>的结果集后然后根据group by的分组字段进行分组，因此也要求<strong>select只能包含group by后的字段与聚合函数</strong>。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201128124742.png" alt="image-20201128124741947" loading="lazy"></p>
</li>
<li><p>having</p>
<p>having是对分组后的子集进行过滤。跟在后面的可以是<strong>字段</strong>或<strong>分组函数</strong>，字段是需要在select中出现的字段，但是如果使用分组函数就可以不用。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201128124711.png" alt="image-20201128124711693" loading="lazy"></p>
</li>
</ul>
<h4 id="三、特性"><a href="#三、特性" class="headerlink" title="三、特性"></a>三、特性</h4><ol>
<li><p>在5.7以后, mysql启用了<code>ONLY_FULL_GROUP_BY</code>模式，就是在使用分组的时候，<strong>select中出现的字段需要在聚合函数或group by上</strong>。</p>
<p>但是也会有一些情况是允许的(具有<strong>函数依赖</strong>关系)</p>
<blockquote>
<p>SQL:1999 and later permits such nonaggregates per optional feature T301 if they are functionally dependent on <code>GROUP BY</code> columns: If such a relationship exists between <code>name</code> and <code>custid</code>, the query is legal. This would be the case, for example, were <code>custid</code> a primary key of <code>customers</code>.</p>
</blockquote>
<p><strong>functionally dependent</strong>：</p>
<blockquote>
<p>在关系模式R(U)中，X和Y是属性集U的子集，所有的元组都满足X→ Y，那么X→ Y在关系模式R(U)中成立，这种联系就是函数依赖</p>
<p>比如在设计学生表时，一个学生的学号能决定学生的姓名，也可称姓名属性依赖于学号，对于现实来说，就是如果知道一个学生的学号，就一定能知道学生的姓名，这种情况就是姓名依赖于学号，这就是函数依赖</p>
<p>属性之间有三种关系，但并不是每一种关系都存在函数依赖。设R(U)是属性集U上的关系模式，X、Y是U的子集：</p>
<p>● 如果X和Y之间是1：1关系（一对一关系），如学校和校长之间就是1:1关系，则存在函数依赖X → Y和Y →X。</p>
<p>● 如果X和Y之间是1：n关系（一对多关系），如年龄和姓名之间就是1:n关系，则存在函数依赖X → Y。</p>
<p>●如果X和Y之间是m：n关系（多对多关系），如学生和课程之间就是m:n关系，则X和Y之间不存在函数依赖。</p>
</blockquote>
<p>这段引用 <a href="https://baike.baidu.com/item/%E5%87%BD%E6%95%B0%E4%BE%9D%E8%B5%96">百度百科</a>，通过设计学生表的例子可以理解为什么mysql文档中说依赖于group by中的字段</p>
<ul>
<li>未分组字段被限制在单值</li>
</ul>
</li>
</ol>
<p>   <img src="https://raw.githubusercontent.com/soda1/img/main/20201127201858.png" alt="image-20201127201858821" loading="lazy"></p>
<p>   同样的，多字段也可以，但是必须使用and连接</p>
<p>   <img src="https://raw.githubusercontent.com/soda1/img/main/20201127235151.png" alt="image-20201127235151206" loading="lazy"></p>
<ul>
<li>分组的字段是一个<code>primary key</code>或者具有唯一性的列</li>
</ul>
<p>   <img src="https://raw.githubusercontent.com/soda1/img/main/20201128002222.png" alt="image-20201128002222696" loading="lazy"></p>
<ul>
<li>使用any_value(col)函数</li>
</ul>
<p>   <img src="https://raw.githubusercontent.com/soda1/img/main/20201128005638.png" alt="image-20201128005638432" loading="lazy"></p>
<ol start="2">
<li>使用<code>select colum1, 分组函数(colum2) from table-name</code>也会报错，尽管没有使用group by语句，但是如果使用了聚合函数，那么<code>colum1</code>就需要作为group by 的分组字段。</li>
</ol>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201124162833.png" alt="image-20201124162833727" loading="lazy"></p>
<ol start="3">
<li><p>标准sql语言不支持在group by中只支持列表达式，同时也不支持别名，但mysql支持<strong>非列表达式</strong>及<strong>别名</strong></p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201128010926.png" loading="lazy"></p>
<p>有一个感觉奇怪的地方就是如果group by后面跟的是a，c字段也可以查询，如果不写c字段只是会报c字段是非聚合字段。</p>
<p>我理解就是因为查询中非列表达式是能够通过c字段来推断出来的，有具体的唯一值，所以查询是合法的。</p>
</li>
</ol>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201128013244.png" alt="image-20201128013244452" loading="lazy"></p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201128160223.png" alt="image-20201128160223393" loading="lazy"></p>
<h3 id="6、连接查询"><a href="#6、连接查询" class="headerlink" title="6、连接查询"></a>6、连接查询</h3><h4 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a>一、含义</h4><ul>
<li><p>当查询中涉及到了多个表的字段，需要使用多表连接<br>select 字段1，字段2<br>from 表1，表2,…;</p>
</li>
<li><p>笛卡尔乘积：当查询多个表时，没有添加有效的连接条件，导致多个表所有行实现完全连接<br>如何解决：添加有效的连接条件</p>
</li>
</ul>
<h4 id="二、分类"><a href="#二、分类" class="headerlink" title="二、分类"></a>二、分类</h4><ul>
<li><p>按年代分类：</p>
<ul>
<li><p>sql92：</p>
<pre><code>    等值
      非等值
      自连接</code></pre>
<p>​        也支持一部分外连接（用于oracle、sqlserver，mysql不支持）</p>
</li>
<li><p>sql99【推荐使用】</p>
<p>​        内连接<br>​        等值<br>​        非等值<br>​        自连接<br>​        外连接<br>​        左外<br>​        右外<br>​        全外（mysql不支持）<br>​       交叉连接</p>
</li>
</ul>
</li>
</ul>
<h4 id="三、SQL92语法"><a href="#三、SQL92语法" class="headerlink" title="三、SQL92语法"></a>三、SQL92语法</h4><ul>
<li><p>1、等值连接</p>
<ul>
<li><p>语法：    </p>
<ul>
<li>select 查询列表<pre><code>from 表1 别名,表2 别名
  where 表1.key=表2.key
  【and 筛选条件】
  【group by 分组字段】
  【having 分组后的筛选】
  【order by 排序字段】</code></pre>
</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>① 一般为表起别名</li>
<li>②多表的顺序可以调换</li>
<li>③n表连接至少需要n-1个连接条件</li>
<li>④等值连接的结果是多表的交集部分</li>
</ul>
</li>
</ul>
</li>
<li><p>2、非等值连接</p>
<ul>
<li>语法：<ul>
<li>​    select 查询列表<br>​    from 表1 别名,表2 别名<br>​    where 非等值的连接条件<br>​    【and 筛选条件】<br>​    【group by 分组字段】<br>​    【having 分组后的筛选】<br>​    【order by 排序字段】</li>
</ul>
</li>
</ul>
</li>
<li><p>3、自连接</p>
<ul>
<li>语法：<ul>
<li>select 查询列表<pre><code>from 表 别名1,表 别名2
  where 等值的连接条件
  【and 筛选条件】
  【group by 分组字段】
  【having 分组后的筛选】
  【order by 排序字段】</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="四、SQL99语法"><a href="#四、SQL99语法" class="headerlink" title="四、SQL99语法"></a>四、SQL99语法</h4><ul>
<li><p>1、内连接</p>
<ul>
<li><p>语法：</p>
<ul>
<li>select 查询列表<br>from 表1 别名<br>【inner】 join 表2 别名 on 连接条件<br>where 筛选条件<br>group by 分组列表<br>having 分组后的筛选<br>order by 排序列表<br>limit 子句;</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>①表的顺序可以调换</li>
<li>②内连接的结果=多表的交集</li>
<li>③n表连接至少需要n-1个连接条件</li>
</ul>
</li>
<li><p>分类：</p>
<ul>
<li>等值连接</li>
<li>非等值连接</li>
<li>自连接</li>
</ul>
</li>
</ul>
</li>
<li><p>2、外连接</p>
<ul>
<li>语法：<ul>
<li>select 查询列表<br>from 表1 别名<br>left|right|full【outer】 join 表2 别名 on 连接条件<br>where 筛选条件<br>group by 分组列表<br>having 分组后的筛选<br>order by 排序列表<br>limit 子句;</li>
</ul>
</li>
<li>特点：<ul>
<li>①查询的结果=主表中所有的行，如果从表和它匹配的将显示匹配行，如果从表没有匹配的则显示null</li>
<li>②left join 左边的就是主表，right join 右边的就是主表<br>  full join 两边都是主表</li>
<li>③一般用于查询除了交集部分的剩余的不匹配的行</li>
</ul>
</li>
</ul>
</li>
<li><p>3、交叉连接</p>
<ul>
<li><p>语法：</p>
<ul>
<li>select 查询列表<br>from 表1 别名<br>cross join 表2 别名;</li>
</ul>
</li>
<li><p>特点：</p>
<ul>
<li>类似于笛卡尔乘积</li>
</ul>
</li>
</ul>
</li>
<li><p>4、7种join查询图示</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201111230359278.png" loading="lazy"></p>
</li>
</ul>
<h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><h4 id="一、含义-1"><a href="#一、含义-1" class="headerlink" title="一、含义"></a>一、含义</h4><ul>
<li>嵌套在其他语句内部的select语句称为子查询或内查询，<br>外面的语句可以是insert、update、delete、select等，一般select作为外面语句较多<br>外面如果为select语句，则此语句称为外查询或主查询</li>
</ul>
<h4 id="二、分类-1"><a href="#二、分类-1" class="headerlink" title="二、分类"></a>二、分类</h4><h5 id="1、按出现位置"><a href="#1、按出现位置" class="headerlink" title="1、按出现位置"></a>1、按出现位置</h5><ul>
<li>select后面：<pre><code>    仅仅支持标量子查询</code></pre>
from后面：<pre><code>    表子查询</code></pre>
where或having后面：<pre><code>    标量子查询
    列子查询
    行子查询</code></pre>
exists后面：<pre><code>    标量子查询
    列子查询
    行子查询
    表子查询</code></pre>
</li>
</ul>
<h5 id="2、按结果集的行列"><a href="#2、按结果集的行列" class="headerlink" title="2、按结果集的行列"></a>2、按结果集的行列</h5><ul>
<li>标量子查询（单行子查询）：结果集为一行一列</li>
<li>列子查询（多行子查询）：结果集为多行一列</li>
<li>行子查询：结果集为多行多列</li>
<li>表子查询：结果集为多行多列</li>
</ul>
<h4 id="三、示例-1"><a href="#三、示例-1" class="headerlink" title="三、示例"></a>三、示例</h4><h5 id="where或having后面"><a href="#where或having后面" class="headerlink" title="where或having后面"></a>where或having后面</h5><ul>
<li><p>1、标量子查询</p>
<ul>
<li><p>案例：查询最低工资的员工姓名和工资</p>
<ul>
<li><p>①最低工资</p>
<ul>
<li>select min(salary) from employees</li>
</ul>
</li>
<li><p>②查询员工的姓名和工资，要求工资=①</p>
<ul>
<li>select last_name,salary<br>from employees<br>where salary=(<pre><code>select min(salary) from employees</code></pre>
);</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>2、列子查询</p>
<ul>
<li><p>案例：查询所有是领导的员工姓名</p>
<ul>
<li>①查询所有员工的 manager_id<ul>
<li>select manager_id<br>from employees</li>
</ul>
</li>
</ul>
</li>
<li><p>②查询姓名，employee_id属于①列表的一个</p>
<ul>
<li>select last_name<br>from employees<br>where employee_id in(<pre><code>select manager_id
from employees</code></pre>
);</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="7、分页查询"><a href="#7、分页查询" class="headerlink" title="7、分页查询"></a>7、分页查询</h3><h4 id="一、应用场景"><a href="#一、应用场景" class="headerlink" title="一、应用场景"></a>一、应用场景</h4><ul>
<li>当要查询的条目数太多，一页显示不全</li>
</ul>
<h5 id="二、语法"><a href="#二、语法" class="headerlink" title="二、语法"></a>二、语法</h5><ul>
<li><p>select 查询列表<br>from 表<br>[limit [offset, ] size | limit size OFFSET offset ];</p>
</li>
<li><p>注意：<br>offset代表的是起始的条目索引，默认从0卡死<br>size代表的是显示的条目数</p>
</li>
<li><p>公式：</p>
<ul>
<li>假如要显示的页数为page，每一页条目数为size<ul>
<li>select 查询列表<br>from 表<br>limit (page-1)*size,size;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="9、联合查询"><a href="#9、联合查询" class="headerlink" title="9、联合查询"></a>9、联合查询</h3><h4 id="一、含义-2"><a href="#一、含义-2" class="headerlink" title="一、含义"></a>一、含义</h4><ul>
<li>union：合并、联合，将多次查询结果合并成一个结果</li>
</ul>
<h4 id="二、语法-1"><a href="#二、语法-1" class="headerlink" title="二、语法"></a>二、语法</h4><ul>
<li>查询语句1<br>union 【all】<br>查询语句2<br>union 【all】<br>…</li>
</ul>
<h4 id="三、意义"><a href="#三、意义" class="headerlink" title="三、意义"></a>三、意义</h4><ul>
<li>1、将一条比较复杂的查询语句拆分成多条语句</li>
<li>2、适用于查询多个表的时候，查询的列基本是一致</li>
</ul>
<h4 id="四、特点"><a href="#四、特点" class="headerlink" title="四、特点"></a>四、特点</h4><ul>
<li>1、要求多条查询语句的查询列数必须一致</li>
<li>2、要求多条查询语句的查询的各列类型、顺序最好一致</li>
<li>3、union 去重，union all包含重复项</li>
</ul>
<h3 id="10、总结"><a href="#10、总结" class="headerlink" title="10、总结"></a>10、总结</h3><ul>
<li>语法：<ul>
<li>select 查询列表    ⑦<br>from 表1 别名       ①<br>连接类型 join 表2   ②<br>on 连接条件         ③<br>where 筛选          ④<br>group by 分组列表   ⑤<br>having 筛选         ⑥<br>order by排序列表    ⑧<br>limit 起始条目索引，条目数;  ⑨</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>base</category>
      </categories>
  </entry>
  <entry>
    <title>TCL事务控制语言</title>
    <url>/2020/11/09/mysql/%E5%9F%BA%E7%A1%80/2020_11_9-TCL/</url>
    <content><![CDATA[<h3 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a>一、含义</h3><ul>
<li>事务：一条或多条sql语句组成一个执行单位，一组sql语句要么都执行要么都不执行</li>
</ul>
<h3 id="二、特点（ACID）"><a href="#二、特点（ACID）" class="headerlink" title="二、特点（ACID）"></a>二、特点（ACID）</h3><ul>
<li>A 原子性：一个事务是不可再分割的整体，要么都执行要么都不执行</li>
<li>C 一致性：一个事务可以使数据从一个一致状态切换到另外一个一致的状态</li>
<li>I 隔离性：一个事务不受其他事务的干扰，多个事务互相隔离的</li>
<li>D 持久性：一个事务一旦提交了，则永久的持久化到本地</li>
</ul>
<h3 id="三、事务的使用步骤-★"><a href="#三、事务的使用步骤-★" class="headerlink" title="三、事务的使用步骤 ★"></a>三、事务的使用步骤 ★</h3><ul>
<li><p>隐式（自动）事务：没有明显的开启和结束，本身就是一条事务可以自动提交，比如insert、update、delete<br>显式事务：具有明显的开启和结束</p>
<ul>
<li><p>使用显式事务：</p>
<ul>
<li><p>①开启事务</p>
<ul>
<li>set autocommit=0;<br>start transaction;#可以省略</li>
</ul>
</li>
<li><p>②编写一组逻辑sql语句</p>
<p>注意：sql语句支持的是insert、update、delete</p>
<ul>
<li>设置回滚点：<ul>
<li>savepoint 回滚点名;</li>
</ul>
</li>
</ul>
</li>
<li><p>③结束事务</p>
<ul>
<li>提交：commit;</li>
<li>回滚：rollback;<ul>
<li>回滚到指定的地方：rollback to 回滚点名;</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="四、并发事务"><a href="#四、并发事务" class="headerlink" title="四、并发事务"></a>四、并发事务</h3><ul>
<li><p>1、事务的并发问题是如何发生的？</p>
</li>
<li><p>多个事务 同时 操作 同一个数据库的相同数据时</p>
</li>
<li><p>2、并发问题都有哪些？</p>
<ul>
<li>脏读：一个事务读取了其他事务还没有提交的数据，读到的是其他事务“更新”的数据</li>
<li>不可重复读：一个事务多次读取，结果不一样</li>
<li>幻读：一个事务读取了其他事务还没有提交的数据，只是读到的是 其他事务“插入”的数据</li>
</ul>
</li>
<li><p>3、如何解决并发问题</p>
</li>
<li><p>通过设置隔离级别来解决并发问题</p>
</li>
<li><p>4、隔离级别</p>
<ul>
<li><p>​                                                      脏读        不可重复读        幻读<br>read uncommitted:读未提交     ×                       ×              ×        </p>
<p>read committed：读已提交      √                        ×              ×<br>repeatable read：可重复读      √                         √              ×<br>serializable：         串行化          √                         √              √</p>
</li>
</ul>
</li>
</ul>
<h3 id="五、设置隔离级别"><a href="#五、设置隔离级别" class="headerlink" title="五、设置隔离级别"></a>五、设置隔离级别</h3><ul>
<li>查看事务隔离级别使用select @@tx_isolation</li>
<li>修改当前会话事务隔离级别使用**SET session TRANSACTION ISOLATION LEVEL Serializable;**（参数可以为：Read uncommitted|Read committed|Repeatable read|Serializable）</li>
<li>修改全局事务隔离级别使用**SET global TRANSACTION ISOLATION LEVEL Serializable;**（参数可以为：Read uncommitted|Read committed|Repeatable read|Serializable）</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>base</category>
      </categories>
  </entry>
  <entry>
    <title>变量</title>
    <url>/2020/11/09/mysql/%E5%9F%BA%E7%A1%80/2020_11_9-%E5%8F%98%E9%87%8F/</url>
    <content><![CDATA[<h4 id="一、系统变量"><a href="#一、系统变量" class="headerlink" title="一、系统变量"></a>一、系统变量</h4><ul>
<li>说明：变量由系统提供的，不用自定义<ul>
<li>①查看系统变量<ul>
<li>show 【global|session 】variables like ‘’; 如果没有显式声明global还是session，则默认是session</li>
</ul>
</li>
<li>②查看指定的系统变量的值<ul>
<li>select @@【global|session】.变量名; 如果没有显式声明global还是session，则默认是session</li>
</ul>
</li>
<li>③为系统变量赋值<ul>
<li>方式一：<ul>
<li>set 【global|session 】 变量名=值; 如果没有显式声明global还是session，则默认是session</li>
</ul>
</li>
<li>方式二：<ul>
<li>set @@global.变量名=值;</li>
<li>set @@变量名=值；</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>1、全局变量</p>
<ul>
<li>服务器层面上的，必须拥有super权限才能为系统变量赋值，作用域为整个服务器，也就是针对于所有连接（会话）有效</li>
</ul>
</li>
<li><p>2、会话变量</p>
<ul>
<li>服务器为每一个连接的客户端都提供了系统变量，作用域为当前的连接（会话）</li>
</ul>
</li>
</ul>
<h4 id="二、自定义变量"><a href="#二、自定义变量" class="headerlink" title="二、自定义变量"></a>二、自定义变量</h4><h5 id="1、用户变量"><a href="#1、用户变量" class="headerlink" title="1、用户变量"></a>1、用户变量</h5><ul>
<li>作用域：针对于当前连接（会话）生效</li>
<li>位置：begin end里面，也可以放在外面</li>
<li>①声明并赋值：<ul>
<li>set @变量名=值;或</li>
<li>set @变量名:=值;或</li>
<li>select @变量名:=值;</li>
</ul>
</li>
<li>②更新值<ul>
<li>方式一：    <ul>
<li>set @变量名=值;或    </li>
<li>set @变量名:=值;或</li>
<li>select @变量名:=值;</li>
</ul>
</li>
<li>方式二：    <ul>
<li>select xx into @变量名 from 表;</li>
</ul>
</li>
</ul>
</li>
<li>③使用<ul>
<li>select @变量名;</li>
</ul>
</li>
</ul>
<h5 id="2、局部变量"><a href="#2、局部变量" class="headerlink" title="2、局部变量"></a>2、局部变量</h5><ul>
<li>作用域：仅仅在定义它的begin end中有效</li>
<li>位置：只能放在begin end中，而且<strong>声明</strong>只能放在第一句</li>
<li>使用：<ul>
<li>①声明<ul>
<li>declare 变量名 类型 【default 值】;</li>
</ul>
</li>
<li>②赋值或更新<ul>
<li>方式一：<ul>
<li>set 变量名=值;或    </li>
<li>set 变量名:=值;或    </li>
<li>select @变量名:=值;</li>
</ul>
</li>
<li>方式二：<ul>
<li>select xx into 变量名 from 表;</li>
</ul>
</li>
</ul>
</li>
<li>③使用<ul>
<li>select 变量名;</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3、小结"><a href="#3、小结" class="headerlink" title="3、小结"></a>3、小结</h4><p>用户变量必须使用在变量名前加上**@<strong>，局部变量除了<code>select @变量名:=值</code>外都不用加</strong>@**。如果在begin end中没有声明就赋值或更新，那么此变量会是用户变量。</p>
]]></content>
      <categories>
        <category>mysql</category>
        <category>base</category>
      </categories>
  </entry>
  <entry>
    <title>存储过程和函数</title>
    <url>/2020/11/09/mysql/%E5%9F%BA%E7%A1%80/2020_11_9-%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</url>
    <content><![CDATA[<ul>
<li>说明：都类似于java中的方法，将一组完成特定功能的逻辑语句包装起来，对外暴露名字<ul>
<li>好处：<ul>
<li>1、提高重用性</li>
<li>2、sql语句简单</li>
<li>3、减少了和数据库服务器连接的次数，提高了效率</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="一、创建-★"><a href="#一、创建-★" class="headerlink" title="一、创建 ★"></a>一、创建 ★</h4><ul>
<li><p>create procedure 存储过程名(参数模式 参数名 参数类型)<br>begin</p>
<pre><code>    存储过程体</code></pre>
<p>end</p>
</li>
<li><p>注意：</p>
<ul>
<li>1.参数模式：in、out、inout，其中in可以省略</li>
<li>2.存储过程体的每一条sql语句都需要用分号结尾</li>
<li>在命令行中执行，要使用先demiliter $，mysql是以分号;来判断一条语句是否结束的，所以需要更改，将语句结束改为$</li>
</ul>
</li>
<li><p>例子</p>
<pre><code class="sql">-- in:
CREATE PROCEDURE myp2(in name VARCHAR(20))
BEGIN
    INSERT into user VALUES(null, &#39;admin&#39;, &#39;admin&#39;, name);
END

-- out:
CREATE PROCEDURE myp3(in name VARCHAR(20), OUT finsh INT )
BEGIN
    INSERT into user VALUES(null, &#39;admin&#39;, &#39;admin&#39;, name),(null, &#39;admin1&#39;, &#39;admin1&#39;, &#39;get&#39;);
    set finsh = ROW_COUNT(); // 返回yin&#39;xiang
END;</code></pre>
</li>
</ul>
<h4 id="二、调用"><a href="#二、调用" class="headerlink" title="二、调用"></a>二、调用</h4><ul>
<li><p>call 存储过程名(实参列表)</p>
</li>
<li><p>举例：</p>
<ul>
<li><p>调用in模式的参数：call sp1（‘值’）;</p>
</li>
<li><p>调用out模式的参数：set @name; call sp1(@name);select @name;</p>
</li>
<li><p>调用inout模式的参数：set @name=值; call sp1(@name); select @name;</p>
</li>
</ul>
</li>
</ul>
<h4 id="三、查看"><a href="#三、查看" class="headerlink" title="三、查看"></a>三、查看</h4><ul>
<li>show create procedure 存储过程名;</li>
</ul>
<h4 id="四、删除"><a href="#四、删除" class="headerlink" title="四、删除"></a>四、删除</h4><ul>
<li>drop procedure 存储过程名;</li>
</ul>
<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="一、创建"><a href="#一、创建" class="headerlink" title="一、创建"></a>一、创建</h4><ul>
<li><p>create function 函数名(参数名 参数类型) returns  返回类型<br>begin</p>
<pre><code>函数体</code></pre>
<p>end</p>
</li>
<li><p>注意：函数体中肯定需要有return语句</p>
</li>
<li><p>实例</p>
<pre><code class="sql">CREATE FUNCTION myf1(name VARCHAR(20)) RETURNS INT
BEGIN
    INSERT into user VALUES(null, &#39;admin&#39;, &#39;admin&#39;, name),(null, &#39;admin1&#39;, &#39;admin1&#39;, &#39;get&#39;);
    RETURN ROW_COUNT();
END;
</code></pre>
</li>
</ul>
<h4 id="二、调用-1"><a href="#二、调用-1" class="headerlink" title="二、调用"></a>二、调用</h4><ul>
<li>select 函数名(实参列表);</li>
</ul>
<h4 id="三、查看-1"><a href="#三、查看-1" class="headerlink" title="三、查看"></a>三、查看</h4><ul>
<li>show create function 函数名;</li>
</ul>
<h4 id="四、删除-1"><a href="#四、删除-1" class="headerlink" title="四、删除"></a>四、删除</h4><ul>
<li>drop function 函数名；</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>base</category>
      </categories>
  </entry>
  <entry>
    <title>流程控制结构</title>
    <url>/2020/11/09/mysql/%E5%9F%BA%E7%A1%80/2020_11_9-%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<ul>
<li>顺序结构：程序从上往下依次执行</li>
<li>分支结构：程序按条件进行选择执行，从两条或多条路径中选择一条执行</li>
<li>循环结构：程序满足一定条件下，重复执行一组语句</li>
</ul>
<h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><h4 id="1、if函数"><a href="#1、if函数" class="headerlink" title="1、if函数"></a>1、if函数</h4><ul>
<li>功能：实现简单双分支</li>
<li>语法：<ul>
<li>if(条件，值1，值2)</li>
</ul>
</li>
<li>位置：<ul>
<li>可以作为表达式放在任何位置</li>
</ul>
</li>
</ul>
<h4 id="2、case结构"><a href="#2、case结构" class="headerlink" title="2、case结构"></a>2、case结构</h4><ul>
<li><p>功能：实现多分支</p>
</li>
<li><p>语法1：</p>
<ul>
<li>case 表达式或字段<br>when 值1 then 语句1;<br>when 值2 then 语句2；<br>..<br>else 语句n;<br>end [case];</li>
</ul>
</li>
<li><p>语法2：</p>
<ul>
<li>case<br>when 条件1 then 语句1;<br>when 条件2 then 语句2；<br>..<br>else 语句n;<br>end [case];</li>
</ul>
</li>
<li><p>位置：</p>
<ul>
<li><p>可以放在任何位置，</p>
<ul>
<li><p>如果放在begin end 外面，作为表达式结合着其他语句使用</p>
<pre><code class="sql">SELECT
case @name2
when &#39;hh&#39; then   (SELECT &#39;这是hh&#39;)
when &#39;xx&#39; then   (SELECT&#39;这是xx&#39;)
when &#39;yy&#39; then   (SELECT &#39;这是yy&#39;)
when &#39;gg&#39; then  (SELECT &#39;这是gg&#39;)
ELSE null
end as name;
--放在begin end 外面时 then 后面如果要跟查询语句就要加上()</code></pre>
</li>
<li><p>如果放在begin end 里面，一般作为独立的语句使用</p>
<pre><code class="sql">CREATE PROCEDURE myp7(in name VARCHAR(20))
BEGIN
    case name
    when &#39;hh&#39; then   SELECT &#39;这是hh&#39;;
    when &#39;xx&#39; then   SELECT&#39;这是xx&#39;;
    when &#39;yy&#39; then   SELECT &#39;这是yy&#39;;
    when &#39;gg&#39; then  SELECT &#39;这是gg&#39;;

    end case;
end;
--或
CREATE PROCEDURE myp8(in name VARCHAR(20))
BEGIN
    case 
    when name = &#39;hh&#39; then   SELECT &#39;这是hh&#39;;
    when name = &#39;xx&#39; then   SELECT &#39;这是xx&#39;;
    when name = &#39;yy&#39; then   SELECT &#39;这是yy&#39;;
    when name = &#39;gg&#39; then   SELECT  &#39;这是gg&#39;;
    end case;
end;
--作为独立语句时，then后面要跟一个语句。</code></pre>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="3、if结构"><a href="#3、if结构" class="headerlink" title="3、if结构"></a>3、if结构</h4><ul>
<li><p>功能：实现多分支</p>
</li>
<li><p>语法：</p>
<ul>
<li><p>if 条件1 then 语句1;<br>elseif 条件2 then 语句2;<br>…<br>else 语句n;<br>end if;</p>
<pre><code class="sql">CREATE PROCEDURE myp1(in num INT)
BEGIN
    if num &lt; 1000 THEN SELECT &#39;穷鬼&#39;;
    ELSEIF num &gt; 5000 THEN SELECT &#39;有钱人&#39;;
    ELSE SELECT &#39;中产阶级&#39;;
    end if;
END;</code></pre>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>位置：</p>
<ul>
<li>只能放在begin end中</li>
</ul>
</li>
</ul>
<h3 id="循环结构"><a href="#循环结构" class="headerlink" title="循环结构"></a>循环结构</h3><ul>
<li><p>位置：</p>
<ul>
<li>只能放在begin end中</li>
</ul>
</li>
<li><p>特点：都能实现循环结构</p>
</li>
<li><p>对比：</p>
<ul>
<li>①这三种循环都可以省略名称，但如果循环中添加了循环控制语句（leave或iterate）则必须添加名称</li>
<li>②loop 一般用于实现简单的死循环<br>while 先判断后执行<br>repeat 先执行后判断，无条件至少执行一次</li>
</ul>
</li>
</ul>
<h4 id="1、while"><a href="#1、while" class="headerlink" title="1、while"></a>1、while</h4><ul>
<li><p>语法：</p>
<ul>
<li><p>【名称:】while 循环条件 do</p>
<pre><code>    循环体</code></pre>
<p>end while【名称】 ;</p>
<pre><code class="sql">CREATE procedure do_while(in num INT)
BEGIN
    DECLARE i INT default 0;
    WHILE i &lt;= num DO
        INSERT into user VALUES(null,&#39;xxx&#39;,&#39;xxxx&#39;,&#39;xxxx&#39;);
        set i = i+1;
    END WHILE;
END;</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="2、loop"><a href="#2、loop" class="headerlink" title="2、loop"></a>2、loop</h4><ul>
<li><p>语法：<br>【名称:】loop</p>
<pre><code>    循环体</code></pre>
<p>end loop 【名称】;</p>
<pre><code class="sql">CREATE PROCEDURE doiterate(p1 INT)
BEGIN
  label1: LOOP
    SET p1 = p1 + 1;
    IF p1 &lt; 10 THEN
      ITERATE label1;
    END IF;
    LEAVE label1;
  END LOOP label1;
  SET @x = p1;
END;</code></pre>
</li>
</ul>
<h4 id="3、repeat"><a href="#3、repeat" class="headerlink" title="3、repeat"></a>3、repeat</h4><ul>
<li><p>语法：</p>
<ul>
<li><p>【名称:】repeat</p>
<pre><code>    循环体</code></pre>
<p>until 结束条件<br>end repeat 【名称】;</p>
<pre><code>CREATE PROCEDURE dorepeat(p1 INT)
       BEGIN
         SET @x = 0;
         REPEAT
           SET @x = @x + 1;
         UNTIL @x &gt; p1 END REPEAT;
       END</code></pre>
</li>
</ul>
</li>
</ul>
<h4 id="循环控制语句"><a href="#循环控制语句" class="headerlink" title="循环控制语句"></a>循环控制语句</h4><ul>
<li>leave：类似于break，用于跳出所在的循环</li>
<li>iterate：类似于continue，用于结束本次循环，继续下一次</li>
<li>这两个要配合【名称】来使用，就是循环结构关键字前的名称</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>base</category>
      </categories>
  </entry>
  <entry>
    <title>视图</title>
    <url>/2020/11/09/mysql/%E5%9F%BA%E7%A1%80/2020_11_9-%E8%A7%86%E5%9B%BE/</url>
    <content><![CDATA[<h4 id="一、含义"><a href="#一、含义" class="headerlink" title="一、含义"></a>一、含义</h4><ul>
<li>mysql5.1版本出现的新特性，本身是一个虚拟表，它的数据来自于表，通过执行时动态生成。<br>好处：</li>
<li>1、简化sql语句</li>
<li>2、提高了sql的重用性</li>
<li>3、保护基表的数据，提高了安全性</li>
</ul>
<h4 id="二、创建"><a href="#二、创建" class="headerlink" title="二、创建"></a>二、创建</h4><ul>
<li>create view 视图名<br>as<br><strong>查询</strong>语句;</li>
</ul>
<h4 id="三、修改"><a href="#三、修改" class="headerlink" title="三、修改"></a>三、修改</h4><ul>
<li>方式一：<ul>
<li>create or replace view 视图名<br>as<br>查询语句;</li>
</ul>
</li>
<li>方式二：<ul>
<li>alter view 视图名<br>as<br>查询语句</li>
</ul>
</li>
</ul>
<h4 id="四、删除"><a href="#四、删除" class="headerlink" title="四、删除"></a>四、删除</h4><ul>
<li>drop view 视图1，视图2,…;</li>
</ul>
<h4 id="五、查看"><a href="#五、查看" class="headerlink" title="五、查看"></a>五、查看</h4><ul>
<li>desc 视图名;<br>show create view 视图名;</li>
</ul>
<h4 id="六、使用"><a href="#六、使用" class="headerlink" title="六、使用"></a>六、使用</h4><ul>
<li><p>1.插入<br>insert<br>2.修改<br>update<br>3.删除<br>delete<br>4.查看<br>select</p>
<pre><code class="sql">CREATE TABLE `actor` (
  `actor_id` smallint(5) NOT NULL AUTO_INCREMENT,
  `first_name` varchar(45) NOT NULL,
  `last_name` varchar(45) NOT NULL,
  `last_update` datetime DEFAULT NULL,
  PRIMARY KEY (`actor_id`),
  UNIQUE KEY `uniq_idx_firstname` (`first_name`),
  KEY `idx_firstname` (`last_name`)
) ENGINE=InnoDB AUTO_INCREMENT=5 DEFAULT CHARSET=utf8;
select `actor`.`first_name` AS `first_name_v`,`actor`.`last_name` AS `last_name_v` from `actor`;
INSERT into actor_name_view VALUES(&#39;hdfh&#39;, &#39;GUINESS&#39;);
select * from actor_name_view;
update actor_name_view set first_name_v = &#39;hdfh&#39; where last_name_v = &#39;GUINESS&#39;;
delete from actor_name_view where first_name_v = &#39;hdfh&#39;;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201123103808028.png" alt="image-20201123103808028" loading="lazy"></p>
</li>
<li><p>注意：视图一般用于查询的，而不是更新的，所以具备以下特点的视图都不允许更新<br>①包含分组函数、group by、distinct、having、union、<br>②join<br>③常量视图<br>④where后的子查询用到了from中的表<br>⑤用到了不可更新的视图</p>
</li>
</ul>
<h4 id="七、视图和表的对比"><a href="#七、视图和表的对比" class="headerlink" title="七、视图和表的对比"></a>七、视图和表的对比</h4><ul>
<li>​        关键字        是否占用物理空间            使用<br>视图    view        占用较小，只保存sql逻辑        一般用于查询<br>表        table        保存实际的数据            增删改查</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>base</category>
      </categories>
  </entry>
  <entry>
    <title>mysql查询流程</title>
    <url>/2020/11/11/mysql/%E9%AB%98%E7%BA%A7/2020_11_11-mysql%E6%9F%A5%E8%AF%A2%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<h3 id="1、MySQL架构"><a href="#1、MySQL架构" class="headerlink" title="1、MySQL架构"></a>1、MySQL架构</h3><p>MySQL是一个典型的C/S架构程序，MySQL Server提供数据库服务，完成客户端的请求和操作，Client负责连接到Server。MySQL和其他关系型数据库不一样的地方在于它的弹性以及可以通过插件形式提供不同种类的存储引擎，MySQL请求处理过程会根据不同的存储引擎发生变化，比如事务性的InnoDB和非事务性的MyISAM，数据的存储和SQL的执行会产生很大的差异。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/v2-4ce9c07e160c6c3e48387bc98d5295e1_r.jpg" alt="preview" loading="lazy"></p>
<h4 id="1-连接层"><a href="#1-连接层" class="headerlink" title="1.连接层"></a>1.连接层</h4><p> 最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
<ul>
<li><p>连接处理</p>
<p>当一个客户端向服务端发送连接请求后，MySQL server会从线程池中分配一个线程来和客户端进行连接，以后该客户端的请求都会被分配到该线程上。MySQL Server为了提高性能，提供了线程池，减少了创建线程和释放线程所花费的时间。</p>
</li>
<li><p>用户鉴权 </p>
<p>当客户端向MySQL服务端发起连接请求后，MySQL server会对发起连接的用户进行鉴权处理，MySQL鉴权依据是: 用户名，客户端主机地址和用户密码</p>
</li>
<li><p>安全管理 </p>
<p>当客户连接到MySQL server后，MySQL server会根据用户的权限来判断用户具体可执行哪些操作</p>
</li>
</ul>
<h4 id="2-服务层"><a href="#2-服务层" class="headerlink" title="2.服务层"></a>2.服务层</h4><ul>
<li><p>Management Serveices &amp; Utilities： 系统管理和控制工具 </p>
</li>
<li><p>SQL Interface: SQL接口</p>
<p>   接受用户的SQL命令，并且返回用户需要查询的结果。</p>
<ul>
<li>Data Manipulation Language (DML).</li>
<li>Data Definition Language (DDL).</li>
<li>存储过程</li>
<li>视图</li>
<li>触发器</li>
</ul>
</li>
<li><p>Parser: 解析器</p>
<p>SQL命令传递到解析器的时候会被解析器验证和解析。 </p>
</li>
<li><p>Optimizer: 查询优化器。</p>
<p>   SQL语句在查询之前会使用查询优化器对查询进行优化。 </p>
<p>   用一个例子就可以理解： select uid,name from user where gender= 1;</p>
<p>   优化器来决定先投影还是先过滤。</p>
</li>
<li><p>Cache和Buffer： 查询缓存。</p>
<p>   如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。</p>
<p>   这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等</p>
</li>
</ul>
<h4 id="3-引擎层"><a href="#3-引擎层" class="headerlink" title="3.引擎层"></a>3.引擎层</h4><p> 存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB</p>
<h4 id="4-存储层"><a href="#4-存储层" class="headerlink" title="4.存储层"></a>4.存储层</h4><p> 数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。</p>
<h3 id="2、MySQL查询流程"><a href="#2、MySQL查询流程" class="headerlink" title="2、MySQL查询流程"></a>2、MySQL查询流程</h3><p><img src="https://raw.githubusercontent.com/soda1/img/main/163a814e084bdc22" alt="查询具体过程" loading="lazy"></p>
<h4 id="查询流程总结"><a href="#查询流程总结" class="headerlink" title="查询流程总结"></a>查询流程总结</h4><ol>
<li>mysql客户端通过协议与mysql服务器建连接，发送查询语句</li>
<li>服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；</li>
<li>服务器端进行sql解析、预处理，再由优化器生成对应的认为最好的执行计划；</li>
<li>mysql根据优化器生成的执行计划，调用存储引擎的api来执行查询；</li>
<li>将结果返回给客户端；</li>
</ol>
<p>mysql默认使用的BTREE索引，并且一个大致方向是:无论怎么折腾sql，至少在目前来说，mysql最多只用到表中的一个索引。</p>
<h4 id="②查询缓存"><a href="#②查询缓存" class="headerlink" title="②查询缓存"></a>②查询缓存</h4><ol>
<li>查询缓存保存查询返回的完整结构；</li>
<li>命中查询缓存时，mysql会立即返回结果，跳过解析、优化和执行阶段；</li>
<li>查询缓存系统会跟踪查询中设计的每个表，如果这些表发生变化，和这个表相关的所有缓存数据都将失效；</li>
<li>判断缓存是否命中时，不会进行解析查询语句，直接使用sql语句和客户端发送过来的其他原始信息，任何字符上的不同，例如空格、注解等，都会导致缓存不命中；</li>
<li>当查询语句有一些不确定的数据时，则不会被缓存；</li>
<li>查询缓存配置参数：<ul>
<li>query_cache_type：是否打开缓存。OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入查询缓存。eg：select sql_cache * from table_name;</li>
<li>query_cache_size：缓存使用的总内存空间大小，单位是字节</li>
<li>query_cache_min_res_unit：分配内存块时的最小单位，较小的该值可以减少碎片导致的内存空间浪费，但会导致更频繁的内存块操作；</li>
<li>query_cache_limit：mysql能够缓存的最大查询结果，如果查询结果大于这个值，则不会被缓存；由于查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后，mysql才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除；</li>
<li>query_cache_wlock_invalidate：如果某个数据表被其他连接锁住，是否仍然从查询缓存中返回结果，默认OFF，表示仍然可以返回；</li>
</ul>
</li>
</ol>
<h4 id="③语法解析器和预处理器"><a href="#③语法解析器和预处理器" class="headerlink" title="③语法解析器和预处理器"></a>③语法解析器和预处理器</h4><ol>
<li>mysql解析器通过关键字将sql语句进行解析，并生成对应的解析树；</li>
<li>mysql解析器将使用mysql语法规则验证和解析查询，eg：验证是否使用错误的关键字、使用关键字的顺序是否正确、验证引号是否前后匹配等；</li>
<li>预处理器根据一些mysql规则进行进一步检查解析树是否合法，eg：检查数据表和数据列是否存在，解析名字和别名是否有歧义；</li>
<li>下一步预处理器验证用户权限，查看用户是否有操作权限，通常很快；</li>
</ol>
<h4 id="④查询优化器"><a href="#④查询优化器" class="headerlink" title="④查询优化器"></a>④查询优化器</h4><ol>
<li><p>优化器的作用就是找到最好的执行计划；</p>
</li>
<li><p>语法树被认为是合法后，优化器将sql语句转换为执行计划，一条查询可以有多种执行方式，最后都返回相同的结果；</p>
</li>
<li><p>生成执行计划过程</p>
</li>
<li><ol>
<li>耗时较多，特别是存在许多可选的执行计划时；</li>
<li>在一条sql语句执行过程中将该语句对应的最终执行计划进行缓存，下一次就可以直接使用已缓存的执行计划，从而提高sql语句的执行速度；</li>
</ol>
</li>
<li><p>mysql使用<strong>基于成本的优化器</strong>（CBO cost-based optimizer），会预测一个查询使用某种执行计划的成本，选择其中成本最小的一个；</p>
</li>
<li><ol>
<li>优化器会根据优化规则对关系表达式进行转换，经过优化规则后会生成另一个关系表达式，原有表达式也会保留；</li>
<li>经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型（cost model）计算每个执行计划的cost，从中挑选cost最小的执行计划；</li>
</ol>
</li>
<li><p>导致mysql优化器选择非最优执行计划的原因</p>
<ol>
<li><p>mysql是根据成本计算得出的最优计划，可能执行时间并不是最短的；</p>
</li>
<li><p>有时候可能无法估算所有可能的执行计划，导致可能错过最优的执行计划；</p>
</li>
<li><p>执行计划成本估算不等同于实际执行的成本，mysql层面无法知道哪些页面在内存中，哪些在磁盘上，实际执行过程中需要多少次物理IO无法得知；</p>
</li>
<li><p>mysql不会考虑不受其控制的操作成本，eg：执行用户自定义函数的成本；</p>
</li>
<li><p>统计信息不准确，mysql依赖存储引擎提供的统计信息（每个表有多少页面、数据行和索引的长度、索引的分布等）来估计成本，InnoDB因为MVCC的架构，并不能维护一个数据表行数的精确统计信息；</p>
</li>
</ol>
</li>
<li><p>mysql可以处理的优化类型</p>
<ol>
<li><p>重新定义关联表的顺序；</p>
</li>
<li><p>使用等价转换原则，eg：移除一些恒成立或恒不成立的判断；</p>
</li>
<li><p>可能的表达式转换为常数表达式；</p>
</li>
<li><p>提前终止查询，使用limit；</p>
</li>
</ol>
</li>
</ol>
<h4 id="⑤查询执行引擎"><a href="#⑤查询执行引擎" class="headerlink" title="⑤查询执行引擎"></a>⑤查询执行引擎</h4><ol>
<li>查询执行引擎根据执行计划来完成整个查询；</li>
<li>执行计划是一个数据结构（指令树），不是和其他关系型数据库那样生成对应的字节码；</li>
<li>mysql根据执行计划给出的指令逐步执行，在执行过程中，有大量的操作需要调用存储引擎实现的接口来完成，这些接口即为“handler API”；</li>
<li>查询中每一个表由一个handler的实例表示。在优化阶段mysql就为每一个表创建了一个handler实例，优化器可以根据这些实例的接口获取表的相关信息，eg：列名、索引、统计信息等；</li>
</ol>
<h4 id="⑥返回客户端结果"><a href="#⑥返回客户端结果" class="headerlink" title="⑥返回客户端结果"></a>⑥返回客户端结果</h4><ol>
<li>如果查询可以被缓存，mysql会在这个阶段将结果存放到查询缓存中；</li>
<li>mysql将结果集返回给客户端是一个增量逐步返回的过程，在查询生成第一条结果时，mysql就可以开始向客户端逐步返回结果了；</li>
<li>增量逐步返回的好处：服务端无须存储太多的结果，不会因为返回太多的结果而消耗太多内存；同时让客户端第一时间获得返回结果；</li>
<li>结果集中的每一行都会以一个满足mysql客户端/服务端通信协议的包发送，再通过tcp协议进行传输，传输过程中，可能对mysql的包进行缓存然后批量传输；</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>存储引擎</title>
    <url>/2020/11/11/mysql/%E9%AB%98%E7%BA%A7/2020_11_11-%E5%AD%98%E5%82%A8%E5%BC%95%E6%93%8E/</url>
    <content><![CDATA[<h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>InnoDB是MySQL的默认事务型引擎，它被设计用来处理大量的短期(short-lived)事务。除非有非常特别的原因需要使用其他的存储引擎，否则应该优先考虑InnoDB引擎。行级锁，适合高并发情况。InnoDB主键索引 为聚簇索引，使用 B+树结构存储索引，在叶子节点存储真实数据，即索引和数据是存储在同一个文件中。</p>
<p>InnoDB还引入了行级锁定和外键约束，在以下场合下，使用InnoDB是最理想的选择：</p>
<ul>
<li>更新密集的表。 InnoDB存储引擎特别适合处理多重并发的更新请求。</li>
<li>事务。 InnoDB存储引擎是支持事务的标准MySQL存储引擎。</li>
<li>自动灾难恢复。 与其它存储引擎不同，InnoDB表能够自动从灾难中恢复。</li>
<li>外键约束。 MySQL支持外键的存储引擎只有InnoDB。</li>
<li>支持自动增加列AUTO_INCREMENT属性。</li>
<li>从5.7开始innodb存储引擎成为默认的存储引擎。</li>
</ul>
<p>一般来说，如果需要事务支持，并且有较高的并发读取频率，InnoDB是不错的选择。</p>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><ul>
<li><p>MyISAM提供了大量的特性，包括全文索引、压缩、空间函数(GIS)等，但MyISAM不支持事务和行级锁(myisam改表时会将整个表全锁住)，有一个毫无疑问的缺陷就是崩溃后无法安全恢复。 MyISAM索引同样使用 b+树结构来存储，和InnoDB不同的是，没有存储数据，只是存储数据的指针。数据存储在另一个文件中</p>
</li>
<li><p>每当我们建立一个MyISAM引擎的表时，就会在本地磁盘上建立三个文件，文件名就是表名。</p>
<p>例如，我建立了一个MyISAM引擎的tb_Demo表，那么就会生成以下三个文件：</p>
<ul>
<li>tb_demo.frm，存储表定义。</li>
<li>tb_demo.MYD，存储数据。</li>
<li>tb_demo.MYI，存储索引。</li>
</ul>
</li>
<li><p>MyISAM表无法处理事务，这就意味着有事务处理需求的表，不能使用MyISAM存储引擎。MyISAM存储引擎特别适合在以下几种情况下使用：</p>
<ul>
<li>选择密集型的表。 MyISAM存储引擎在筛选大量数据时非常迅速，这是它最突出的优点。</li>
<li>插入密集型的表。 MyISAM的并发插入特性允许同时选择和插入数据。</li>
</ul>
</li>
</ul>
<h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><table>
<thead>
<tr>
<th>存储引擎</th>
<th>外键</th>
<th>事务</th>
<th>缓存</th>
<th>行表锁</th>
</tr>
</thead>
<tbody><tr>
<td>MyISAM</td>
<td>不支持</td>
<td>不支持</td>
<td>只缓存索引，不缓存真实数据</td>
<td>表锁，即使操作一条记录也会锁住整个表，不适合高并发的操作</td>
</tr>
<tr>
<td>InnoDB</td>
<td>支持</td>
<td>支持</td>
<td>不仅缓存索引还要缓存真实数据</td>
<td>行锁、表锁,操作时只锁某一行，不对其它行有影响，适合,高并发的操作</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>mysql索引</title>
    <url>/2020/11/12/mysql/%E9%AB%98%E7%BA%A7/2020_11_12-mysql%E7%B4%A2%E5%BC%95/</url>
    <content><![CDATA[<h3 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h3><p>提高查询效率，因为索引是经过排序后的能够快速查找的数据结构</p>
<h3 id="索引原理"><a href="#索引原理" class="headerlink" title="索引原理"></a>索引原理</h3><p>通过不断的缩小想要获得的数据的范围来筛选出想要的结果，数据都是排好序的。数据库操作不只包括等值查询还包括范围查询（between、in、&gt; 、&lt;  、like等)，搜索树可以满足数据库的操作，但是数据库的数据是保存在磁盘中的，所以会发生IO操作，先将数据读取到内存中在进行搜索。IO操作是很比较费时的，数据量过多时，查询很很慢。因此简单搜索树没办法满足。</p>
<h4 id="IO读取"><a href="#IO读取" class="headerlink" title="IO读取"></a>IO读取</h4><p>由于IO读取是高昂的操作，计算机系统对IO进行了一些优化，当一次IO时，不光把当前磁盘地址的数据，而是把相邻的数据也都读取到内存缓冲区内，每一次IO读取的数据我们称之为一页(page)。具体一页有多大数据跟操作系统有关，一般为4k或8k，也就是我们读取一页内的数据时候，实际上才发生了一次IO。</p>
<h4 id="B-树（多路搜索树）"><a href="#B-树（多路搜索树）" class="headerlink" title="B+树（多路搜索树）"></a>B+树（多路搜索树）</h4><p><img src="https://raw.githubusercontent.com/soda1/img/main/7af22798.jpg" alt="b+树" loading="lazy"></p>
<ul>
<li><p>多路表示非叶节点的子节点数&gt;1，且&lt;=M ，且M&gt;=2。图中为3路搜索树</p>
</li>
<li><p>浅蓝色部分是磁盘块，代表的是一次IO读取的数据。</p>
<ul>
<li>蓝色部分是<strong>数据项</strong>（<strong>关键字</strong>）</li>
</ul>
</li>
<li><p>黄色部分是<strong>指针</strong>，指向下一个子节点的磁盘块</p>
</li>
<li><p>所有叶子节点均在同一层,只有叶子节点才会存储真正的数据，包含了<strong>关键字</strong>和<strong>关键字记录的指针</strong>。每个叶子节点都有指向右叶子节点的指针。非叶子节点只存储数据项，如17，35并没有真实存在数据当中。</p>
</li>
<li><p>一次查找过程（查找数据28）</p>
<ul>
<li><p>第一次IO：将磁盘块1读取到内存中，因为数据28在17和35之间，所以读取磁盘块1指针P2指向的磁盘块3</p>
</li>
<li><p>第二次IO：将磁盘块3读取到内存中，因为数据28在26和30之间，所以读取磁盘块3指针P2指向的磁盘块8</p>
</li>
<li><p>第三次IO：将磁盘8读取到内存中，找到数据28</p>
</li>
</ul>
<p>一次查找过程只用了三次IO就能够找到数据。一般3层b+树可以表示百万的数据，也就是查找上百万的数据只要三次IO，提升是巨大的</p>
</li>
<li><p>性质</p>
<ul>
<li>IO次数由树高h决定，假设数据为N，每个磁盘块数据项为m，那么有h=log(m+1)N，当数据N一定的情况下，m越大，则h越小，而m = 磁盘块大小/数据项大小。因为磁盘块大小是固定的，因此存储的数据项越小，存储的数据就越多，树的高度就越低。这就是为什么b+树只在叶子节点存储真实数据。b树是所有节点都保存真实数据</li>
<li>当b+树的数据项是复合的数据结构，比如(name,age,sex)的时候，b+数是按照从左到右的顺序来建立搜索树的，比如当(张三,20,F)这样的数据来检索的时候，b+树会优先比较name来确定下一步的所搜方向，如果name相同再依次比较age和sex，最后得到检索的数据；但当(20,F)这样的没有name的数据来的时候，b+树就不知道下一步该查哪个节点，因为建立搜索树的时候name就是第一个比较因子，必须要先根据name来搜索才能知道下一步去哪里查询。比如当(张三,F)这样的数据来检索时，b+树可以用name来指定搜索方向，但下一个字段age的缺失，所以只能把名字等于张三的数据都找到，然后再匹配性别是F的数据了， 这个是非常重要的性质，即<strong>索引的最左匹配特性</strong></li>
</ul>
</li>
<li><p>b树和b+树区别</p>
<ul>
<li>B树的关键字和记录是放在一起的，叶子节点可以看作外部节点，不包含任何信息；B+树叶子节点中只有关键字和指向下一个节点的索引，记录只放在叶子节点中。(一次查询可能进行两次i/o操作)</li>
</ul>
</li>
</ul>
<ul>
<li><p>为什么说B+树比B树更适合实际应用中操作系统的文件索引和数据库索引？ </p>
<ul>
<li><p>B+树的磁盘读写代价更低 </p>
<p>B+树的内部结点并没有指向关键字具体信息的指针。因此其内部结点相对B 树更小。如果把所有同一内部结点的关键字存放在同一盘块中，那么盘块所能容纳的关键字数量也越多。一次性读入内存中的需要查找的关键字也就越多。相对来说IO读写次数也就降低了。 </p>
</li>
<li><p>B+树的查询效率更加稳定 </p>
<p>由于非终结点并不是最终指向文件内容的结点，而只是叶子结点中关键字的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p>
</li>
</ul>
</li>
</ul>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><ol>
<li><p>从存储结构上来划分：BTree索引（B-Tree或B+Tree索引），Hash索引，full-index全文索引，R-Tree索引。</p>
</li>
<li><p>从应用层次来分：普通索引，唯一索引，复合索引</p>
<ul>
<li><p>普通索引：即一个索引只包含单个列，一个表可以有多个单列索引</p>
</li>
<li><p>唯一索引：索引列的值必须唯一，但允许有空值</p>
</li>
<li><p>复合索引：即一个索引包含多个列</p>
</li>
</ul>
</li>
<li><p>根据中数据的物理顺序与键值的逻辑（索引）顺序关系：聚集索引，非聚集索引。</p>
<p>聚簇索引(聚集索引)：并不是一种单独的索引类型，而是一种数据存储方式。InnoDB的聚簇索引其实就是在同一个结构中保存了索引和数据行。</p>
<p>非聚集索引：和聚簇索引相反，索引和数据是分开的。</p>
</li>
</ol>
<h3 id="建立索引原则"><a href="#建立索引原则" class="headerlink" title="建立索引原则"></a>建立索引原则</h3><p>建立索引虽然可以提高查找效率，但是维护索引仍要花费很大的代价。插入数据时，如果节点数据满了之后，就需要进行分页操作，b+树也有类似于旋转的功能，如果相邻页数据没有满时，会先考虑将数据移到相邻页而不是先分页。因此，索引建立需要一定的原则。</p>
<ol>
<li><p>最左前缀匹配原则，非常重要的原则，mysql会一直向右匹配直到遇到范围查询(&gt;、&lt;、between、like)就停止匹配，比如a = 1 and b = 2 and c &gt; 3 and d = 4 如果建立(a,b,c,d)顺序的索引，d是用不到索引的，如果建立(a,b,d,c)的索引则都可以用到，a,b,d的顺序可以任意调整。</p>
</li>
<li><p>=和in可以乱序，比如a = 1 and b = 2 and c = 3 建立(a,b,c)索引可以任意顺序，mysql的查询优化器会帮你优化成索引可以识别的形式。</p>
</li>
<li><p>尽量选择区分度高的列作为索引，区分度的公式是count(distinct col)/count(*)，表示字段不重复的比例，比例越大我们扫描的记录数越少，唯一键的区分度是1，而一些状态、性别字段可能在大数据面前区分度就是0，那可能有人会问，这个比例有什么经验值吗？使用场景不同，这个值也很难确定，一般需要join的字段我们都要求是0.1以上，即平均1条扫描10条记录。</p>
</li>
<li><p>索引列不能参与计算，保持列“干净”，比如from_unixtime(create_time) = ’2014-05-29’就不能使用到索引，原因很简单，b+树中存的都是数据表中的字段值，但进行检索时，需要把所有元素都应用函数才能比较，显然成本太大。所以语句应该写成create_time = unix_timestamp(’2014-05-29’)。</p>
</li>
<li><p>尽量的扩展索引，不要新建索引。比如表中已经有a的索引，现在要加(a,b)的索引，那就删除原索引（mysql没有修改索引），然后再重建索引。</p>
</li>
</ol>
<h3 id="索引语法"><a href="#索引语法" class="headerlink" title="索引语法"></a>索引语法</h3><ul>
<li><p>创建</p>
<pre><code class="sql">CREATE  [UNIQUE ] INDEX index_name ON table_name(columnname[(length)]) --create 语句  
ALTER TABLE tbl_name ADD PRIMARY KEY (column_list): --该语句添加一个主键，这意味着索引值必须是唯一的，且不能为NULL。
ALTER TABLE tbl_name ADD UNIQUE index_name (column_list): --这条语句创建索引的值必须是唯一的（除了NULL外，NULL可能会出现多次）。
ALTER TABLE tbl_name ADD INDEX index_name (column_list): --添加普通索引，索引值可出现多次。
ALTER TABLE tbl_name ADD FULLTEXT index_name (column_list):--该语句指定了索引为 FULLTEXT ，用于全文索引。
--创建表时建立索引
create table tb_name(
[ UNIQUE | FULLTEXT | SPATIAL ] INDEX | KEY
[ 别名] ( 属性名1 [(长度)] [ ASC | DESC] )
)</code></pre>
</li>
<li><p>删除</p>
<p><code>DROP INDEX [indexName] ON mytable; </code></p>
</li>
<li><p>查看</p>
<p><code>SHOW INDEX FROM table_name</code></p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>explain关键字</title>
    <url>/2020/11/13/mysql/%E9%AB%98%E7%BA%A7/2020_11_13-explain%E5%85%B3%E9%94%AE%E5%AD%97/</url>
    <content><![CDATA[<h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>使用EXPLAIN关键字可以模拟优化器执行SQL查询语句，从而知道MySQL是如何处理你的SQL语句的。分析你的查询语句或是表结构的性能瓶颈</p>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ul>
<li><p>语法</p>
<pre><code>  Explain + SQL语句</code></pre>
<p>  查看优化后的SQL语句</p>
<pre><code>show warnings;</code></pre>
</li>
<li><p>简单例子</p>
<pre><code class="sql">EXPLAIN select * from titles where to_date=&#39;9999-01-01&#39;;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201113172657250.png" alt="image-20201113172657250" loading="lazy"></p>
</li>
</ul>
<h4 id="Explain字段"><a href="#Explain字段" class="headerlink" title="Explain字段"></a>Explain字段</h4><h5 id="id"><a href="#id" class="headerlink" title="id"></a>id</h5><p>select查询的序列号,包含一组数字，表示查询中执行select子句或操作表的顺序</p>
<ul>
<li><p>id相同，执行顺序由上至下</p>
<pre><code class="sql">EXPLAIN select * from t1,t2,t3 where t1.id = t2.id and t2.id = t3.id;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201113223418978.png" alt="image-20201113223418978" loading="lazy"></p>
</li>
<li><p>id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</p>
<pre><code class="sql">explain select t2.id from t2 where t2.id = (select t3.id from t3 where t3.content=&#39;t3_664&#39;);</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201113223754251.png" alt="image-20201113223754251" loading="lazy"></p>
</li>
<li><p>id相同不同，同时存在</p>
<p>id如果相同，可以认为是一组，从上往下顺序执行；<br>在所有组中，id值越大，优先级越高，越先执行</p>
</li>
</ul>
<h5 id="select-type"><a href="#select-type" class="headerlink" title="select_type"></a>select_type</h5><p>查询的类型，主要是用于区别：普通查询、联合查询、子查询等的复杂查询</p>
<ul>
<li><p>SIMPLE</p>
<p>简单的 select 查询,查询中不包含子查询或者UNION</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201113224234083.png" alt="image-20201113224234083" loading="lazy"></p>
</li>
<li><p>PRIMARY</p>
<p>查询中若包含任何复杂的子部分，最外层查询则被标记为Primary</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/EF90801E-0F46-4006-86B0-D00FF9A41BAB.png" alt="image-20201113231321133" loading="lazy"></p>
<ul>
<li><p>DERIVED</p>
<p>在FROM列表中包含的子查询被标记为DERIVED(衍生)</p>
<p>MySQL会递归执行这些子查询, 把结果放在临时表里。</p>
</li>
<li><p>SUBQUERY</p>
<p>在SELECT或WHERE列表中包含了子查询，子查询结果为单值</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201113231321133.png" alt="img" loading="lazy"> </p>
</li>
<li><p>DEPENDENT SUBQUERY</p>
<p>在SELECT或WHERE列表中包含了子查询,子查询基于外层，子查询为多值</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/2F45DD10-6247-4FC7-A7DA-509AE0D9C949.png" alt="img" loading="lazy"> </p>
</li>
<li><p>UNCACHEABLE SUBQUERY</p>
<p>无法被缓存的子查询</p>
</li>
<li><p>UNION</p>
<p>若第二个SELECT出现在UNION之后，则被标记为UNION；</p>
<p>若UNION包含在FROM子句的子查询中,外层SELECT将被标记为：DERIVED</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201113231132956.png" alt="image-20201113231132956" loading="lazy"></p>
</li>
<li><p>UNION RESULT</p>
<p>从UNION表获取结果的SELECT</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201113231242885.png" alt="image-20201113231242885" loading="lazy"></p>
</li>
</ul>
<h5 id="table"><a href="#table" class="headerlink" title="table"></a>table</h5><p>显示这一行的数据是关于哪张表的</p>
<h5 id="partitions"><a href="#partitions" class="headerlink" title="partitions"></a>partitions</h5><h5 id="type"><a href="#type" class="headerlink" title="type"></a>type</h5><p>type显示的是访问类型，是较为重要的一个指标，结果值从最好到最坏依次是： </p>
<p>system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range(尽量保证) &gt; index &gt; ALL </p>
<p>一般来说，得保证查询至少达到range级别，最好能达到ref。</p>
<blockquote>
<p>The <code>type</code> column of <a href="https://dev.mysql.com/doc/refman/8.0/en/explain.html"><code>EXPLAIN</code></a> output describes how tables are joined. In JSON-formatted output, these are found as values of the <code>access_type</code> property. The following list describes the join types, ordered from the best type to the worst:</p>
</blockquote>
<ul>
<li><p><strong>system</strong>：表只有一行记录（等于系统表），这是const类型的特列，平时不会出现，这个也可以忽略不计</p>
</li>
<li><p><strong>const</strong>：表示通过索引一次就找到了,const用于比较primary key或者unique索引。因为只匹配一行数据，所以很快。如将主键置于where列表中，MySQL就能将该查询转换为一个常量</p>
</li>
<li><p><strong>eq_ref</strong>：唯一性索引扫描，对于每个索引键，表中只有一条记录与之匹配。常见于主键或唯一索引扫描</p>
</li>
<li><p><strong>ref</strong>：非唯一性索引扫描，返回匹配某个单独值的所有行.本质上也是一种索引访问，它返回所有匹配某个单独值的行，然而，它可能会找到多个符合条件的行，所以他应该属于查找和扫描的混合体</p>
</li>
<li><p><strong>fulltext</strong>：执行使用全文索引</p>
</li>
<li><p><strong>ref_or_null</strong>：对于某个字段既需要关联条件，也需要null值得情况下。查询优化器会选择用ref_or_null连接查询。</p>
</li>
<li><p><strong>index_merge</strong>：在查询过程中需要多个索引组合使用，通常出现在有 or 的关键字的sql中</p>
</li>
<li><p><strong>unique_subquery</strong>：该联接类型类似于index_subquery。 子查询中的唯一索引</p>
</li>
<li><p><strong>index_subquery</strong>：利用索引来关联子查询，不再全表扫描。</p>
</li>
<li><p><strong>range</strong>：只检索给定范围的行,使用一个索引来选择行。key 列显示使用了哪个索引，一般就是在你的where语句中出现了between、&lt;、&gt;、in等的查询</p>
<p>这种范围扫描索引扫描比全表扫描要好，因为它只需要开始于索引的某一点，而结束语另一点，不用扫描全部索引。</p>
</li>
<li><p><strong>index</strong>：Full Index Scan，index与ALL区别为index类型只遍历索引树。这通常比ALL快，<em>因为索引文件通常比数据文件小</em>。（也就是说虽然all和Index都是读全表，但index是从索引中读取的，而all是从硬盘中读的）</p>
</li>
<li><p><strong>ALL</strong>：Full Table Scan，将遍历全表以找到匹配的行</p>
</li>
</ul>
<h5 id="possible-keys"><a href="#possible-keys" class="headerlink" title="possible_keys"></a>possible_keys</h5><p>显示可能应用在这张表中的索引，一个或多个。查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用</p>
<h5 id="key"><a href="#key" class="headerlink" title="key"></a>key</h5><p>实际使用的索引名。如果为NULL，则没有使用索引</p>
<h5 id="key-len"><a href="#key-len" class="headerlink" title="key_len"></a>key_len</h5><p>表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度。 </p>
<p>key_len字段能够帮你检查是否充分的利用上了索引</p>
<h5 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h5><p>显示索引的哪一列被使用了，如果可能的话，是一个常数。哪个索引列或常量被用来查找值</p>
<h5 id="rows"><a href="#rows" class="headerlink" title="rows"></a>rows</h5><p>rows列显示MySQL认为它执行查询时必须检查的行数。越少越好</p>
<h5 id="filtered"><a href="#filtered" class="headerlink" title="filtered"></a>filtered</h5><blockquote>
<p>The <code>filtered</code> column indicates an estimated percentage of table rows that are filtered by the table condition. The maximum value is 100, which means no filtering of rows occurred. Values decreasing from 100 indicate increasing amounts of filtering. <code>rows</code> shows the estimated number of rows examined and <code>rows</code> × <code>filtered</code> shows the number of rows that are joined with the following table. For example, if <code>rows</code> is 1000 and <code>filtered</code> is 50.00 (50%), the number of rows to be joined with the following table is 1000 × 50% = 500.</p>
</blockquote>
<h5 id="Extra"><a href="#Extra" class="headerlink" title="Extra"></a>Extra</h5><p>包含不适合在其他列中显示但十分重要的额外信息</p>
<ul>
<li><p>Using filesort：说明mysql会对数据使用一个外部的索引排序，而不是按照表内的索引顺序进行读取。MySQL中无法利用索引完成的排序操作称为“文件排序”</p>
</li>
<li><p>Using temporary ：使了用临时表保存中间结果,MySQL在对查询结果排序时使用临时表。常见于排序 order by 和分组查询 group by。</p>
</li>
<li><p>Using index：表示相应的select操作中使用了覆盖索引(Covering Index)，避免访问了表的数据行，效率不错！</p>
<p>如果同时出现using where，表明索引被用来执行索引键值的查找;如果没有同时出现using where，表明索引只是用来读取数据而非利用索引执行查找。</p>
<p>覆盖索引：就是select的字段和查找时用的索引的字段是相同的，这样不用读取数据中查找其他行了。</p>
</li>
<li><p>Using where：使用where过滤</p>
</li>
<li><p>using join buffer：使用连接缓存</p>
</li>
<li><p>impossible where：where子句的值总是false，不能用来获取任何元组</p>
</li>
<li><p>select tables optimized away：在没有GROUPBY子句的情况下，基于索引优化MIN/MAX操作或者对于MyISAM存储引擎优化COUNT(*)操作，不必等到执行阶段再进行计算，查询执行计划生成的阶段即完成优化。</p>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>索引优化技巧</title>
    <url>/2020/11/14/mysql/%E9%AB%98%E7%BA%A7/2020_11_14-%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h3 id="使用组合索引"><a href="#使用组合索引" class="headerlink" title="使用组合索引"></a>使用组合索引</h3><h4 id="建表"><a href="#建表" class="headerlink" title="建表"></a>建表</h4><pre><code class="sql">CREATE TABLE staffs (
  id INT PRIMARY KEY AUTO_INCREMENT,
  NAME VARCHAR (24)  NULL DEFAULT &#39;&#39; COMMENT &#39;姓名&#39;,
  age INT NOT NULL DEFAULT 0 COMMENT &#39;年龄&#39;,
  pos VARCHAR (20) NOT NULL DEFAULT &#39;&#39; COMMENT &#39;职位&#39;,
  add_time TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT &#39;入职时间&#39;
) CHARSET utf8 COMMENT &#39;员工记录表&#39; ;
INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&#39;z3&#39;,22,&#39;manager&#39;,NOW());
INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&#39;July&#39;,23,&#39;dev&#39;,NOW());
INSERT INTO staffs(NAME,age,pos,add_time) VALUES(&#39;2000&#39;,23,&#39;dev&#39;,NOW());
INSERT INTO staffs(NAME,age,pos,add_time) VALUES(null,23,&#39;dev&#39;,NOW());
SELECT * FROM staffs;
ALTER TABLE staffs ADD INDEX idx_staffs_nameAgePos(name, age, pos); --建立组合索引</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201126172806.png" alt="image-20201126172806829" loading="lazy"></p>
<p>组合索引实际上是建了3个索引，相当于Name是一级目录，age是2级目录，pos是三级目录。</p>
<h4 id="组合索引规则"><a href="#组合索引规则" class="headerlink" title="组合索引规则"></a>组合索引规则</h4><h5 id="1、全值匹配最喜欢"><a href="#1、全值匹配最喜欢" class="headerlink" title="1、全值匹配最喜欢"></a>1、全值匹配最喜欢</h5><pre><code class="sql">--索引  idx_staffs_nameAgePos 建立索引时 以 name ， age ，pos 的顺序建立的。全值匹配表示 按顺序匹配的
EXPLAIN SELECT * FROM staffs WHERE NAME = &#39;July&#39;;
EXPLAIN SELECT * FROM staffs WHERE NAME = &#39;July&#39; AND age = 25;
EXPLAIN SELECT * FROM staffs WHERE NAME = &#39;July&#39; AND age = 25 AND pos = &#39;dev&#39;;</code></pre>
<img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115133325639.png" alt="image-20201115133325639"  / loading="lazy">

<p>全值匹配时key_len是最长的</p>
<h5 id="2、最佳左前缀法则"><a href="#2、最佳左前缀法则" class="headerlink" title="2、最佳左前缀法则"></a>2、最佳左前缀法则</h5><p>如果索引了多列，要遵守最左前缀法则。指的是查询从索引的最左前列开始并且不跳过索引中的列</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115143806198.png" alt="image-20201115143806198" loading="lazy"></p>
<p>and 忽略左右关系。即使没有按顺序 ，优化器也会自动优化。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115142725645.png" alt="image-20201115142725645" loading="lazy"></p>
<p><strong>特殊情况</strong>：当使用覆盖索引的方式时，(select name/age/id from staffs where age=10 (后面没有其他没有索引的字段条件))，即使不是以 name 开头，也会使用 idx_nameAgePos 索引。  既 select 后的字段 有索引，where 后的字段也有索引，则无关执行顺序。</p>
<h5 id="3、不在索引列上做任何操作"><a href="#3、不在索引列上做任何操作" class="headerlink" title="3、不在索引列上做任何操作"></a>3、不在索引列上做任何操作</h5><p>在索引列上进行操作（计算、函数、(自动or手动)类型转换），会导致索引失效而转向全表扫描</p>
<img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115145734678.png" alt="image-20201115145734678"  / loading="lazy">

<h5 id="4、存储引擎不能使用索引中范围条件右边的列"><a href="#4、存储引擎不能使用索引中范围条件右边的列" class="headerlink" title="4、存储引擎不能使用索引中范围条件右边的列"></a>4、存储引擎不能使用索引中范围条件右边的列</h5><p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115150214188.png" alt="image-20201115150214188" loading="lazy"></p>
<p>根据索引原理，是根据<code>name，age，pos</code>来依次排序的，类似这样：<code>(&#39;July&#39;, 26, &#39;aaa&#39;)、(&#39;July&#39;, 26, &#39;bbb&#39;)、(&#39;July&#39;, 26, &#39;ccc&#39;)、(&#39;July&#39;, 27, &#39;aaa&#39;)、(&#39;July&#39;, 27, &#39;bbb&#39;)</code>，因此范围查找后后面的列会索引失效</p>
<h5 id="5、尽量使用覆盖索引，减少select"><a href="#5、尽量使用覆盖索引，减少select" class="headerlink" title="5、尽量使用覆盖索引，减少select *"></a>5、尽量使用覆盖索引，减少select *</h5><p>覆盖索引：只访问索引的查询(索引列和查询列一致)</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115150643038.png" alt="image-20201115150643038" loading="lazy"></p>
<p>数据如果过大，如果使用select * 的话，查询的时间有可能比建立索引查询的时间还要少，因为需要回表。使用覆盖索引不会回表，从而减少查询时间。</p>
<h5 id="6、不使用不等于-或者-lt-gt"><a href="#6、不使用不等于-或者-lt-gt" class="headerlink" title="6、不使用不等于(!= 或者&lt;&gt;)"></a>6、不使用不等于(!= 或者&lt;&gt;)</h5><p>会无法使用索引导致全表扫描</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115150950538.png" alt="image-20201115150950538" loading="lazy"></p>
<h5 id="7、is-not-null-也无法使用索引-但是is-null是可以使用索引的"><a href="#7、is-not-null-也无法使用索引-但是is-null是可以使用索引的" class="headerlink" title="7、is not null 也无法使用索引,但是is null是可以使用索引的"></a>7、is not null 也无法使用索引,但是is null是可以使用索引的</h5><p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115151447833.png" alt="image-20201115151447833" loading="lazy"></p>
<h5 id="8、like以通配符开头-‘-abc…’-mysql索引失效会变成全表扫描的操作"><a href="#8、like以通配符开头-‘-abc…’-mysql索引失效会变成全表扫描的操作" class="headerlink" title="8、like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作"></a>8、like以通配符开头(‘%abc…’)mysql索引失效会变成全表扫描的操作</h5><p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115152258583.png" alt="image-20201115152258583" loading="lazy"></p>
<p>需要使用<code>%abc%</code>通配符时，可以使用覆盖索引，这样索引不会失效</p>
<h5 id="9、字符串不加单引号索引失效"><a href="#9、字符串不加单引号索引失效" class="headerlink" title="9、字符串不加单引号索引失效"></a>9、字符串不加单引号索引失效</h5><p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115152934351.png" alt="image-20201115152934351" loading="lazy"></p>
<h5 id="10、少用or-用它来连接时会索引失效"><a href="#10、少用or-用它来连接时会索引失效" class="headerlink" title="10、少用or,用它来连接时会索引失效"></a>10、少用or,用它来连接时会索引失效</h5><p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201115153113960.png" alt="image-20201115153113960" loading="lazy"></p>
<h4 id="一般性建议"><a href="#一般性建议" class="headerlink" title="一般性建议"></a>一般性建议</h4><ol>
<li>对于单键索引，尽量选择针对当前query过滤性更好的索引</li>
<li>在选择组合索引的时候，当前query中过滤性最好的字段在索引字段顺序中，位置越靠前越好。(避免索引过滤性好的索引失效)</li>
<li>在选择组合索引的时候，尽量选择可以能够包含当前query中的where字句中更多字段的索引</li>
<li>尽可能通过分析统计信息和调整query的写法来达到选择合适索引的目的</li>
</ol>
<h3 id="join优化"><a href="#join优化" class="headerlink" title="join优化"></a>join优化</h3><ol>
<li><p>保证被驱动表的join字段已经被索引</p>
</li>
<li><p>left join 时，默认选择左表作为驱动表（right join相反），因此选择小表作为驱动表，大表作为被驱动表。</p>
</li>
<li><p>inner join 时，mysql会自己帮你把小结果集的表选为驱动表。</p>
</li>
<li><p>子查询尽量不要放在被驱动表，有可能使用不到索引。</p>
</li>
</ol>
<h3 id="in-、-exists使用"><a href="#in-、-exists使用" class="headerlink" title="in 、 exists使用"></a>in 、 exists使用</h3><p>in的查询过程类似于下面</p>
<pre><code class="java">$result = [];
$users = &quot;SELECT * FROM `user`&quot;;
$orders = &quot;SELECT user_id FROM `order`&quot;;
for($i = 0;$i &lt; $users.length;$i++)&#123;
    for($j = 0;$j &lt; $orders.length;$j++)&#123;
        // 此过程为内存操作，不涉及数据库查询。
        if($users[$i].id == $orders[$j].user_id)&#123;
            $result[] = $users[$i];
            break;
        &#125;
    &#125;
&#125;</code></pre>
<p>如果in里面的表越大就不建议用in</p>
<p>order的查询过程类似于下面</p>
<pre><code>$result = [];
$users = &quot;SELECT * FROM `user`&quot;;
for($i=0;$i&lt;$users.length;$i++)&#123;
    if(exists($users[$i].id))&#123;// 执行SELECT * FROM `order` WHERE user.id = order.user_id
        $result[] = $users[$i];
    &#125;
&#125;</code></pre>
<p>当order表比user表大很多的时候，使用exists是再恰当不过了，它没有那么多遍历操作,只需要再执行一次查询就行，<strong>exist每次都会去查询数据库</strong>。</p>
<h3 id="order-by关键字优化"><a href="#order-by关键字优化" class="headerlink" title="order by关键字优化"></a>order by关键字优化</h3><p>MySQL支持二种方式的排序，FileSort和Index，Index效率高.它指MySQL扫描索引本身完成排序。FileSort方式效率较低。</p>
<h4 id="使用Index排序"><a href="#使用Index排序" class="headerlink" title="使用Index排序:"></a>使用Index排序:</h4><ul>
<li><p>ORDER BY 语句使用索引最左前列</p>
</li>
<li><p>使用Where子句与Order BY子句条件列组合满足索引最左前列，where子句中如果出现索引的范围查询(即explain中出现range)会导致order by 索引失效。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/10EA75EA-0277-4DAF-AFEF-441F2B07EAA1.png" alt="img" loading="lazy"></p>
<p>第二种中，where a = const and b &gt; const order by b , c 不会出现 using filesort b , c 两个衔接上了。但是：where a = const and b &gt; const order by c 将会出现 using filesort 。因为 b 用了范围索引，断了。而上一个 order by 后的b 用到了索引，所以能衔接上 c </p>
</li>
</ul>
<h4 id="使用filesort排序"><a href="#使用filesort排序" class="headerlink" title="使用filesort排序"></a>使用filesort排序</h4><p>如果不在索引列上，filesort有两种算法：mysql就要启动双路排序和单路排序</p>
<ul>
<li><p>双路排序</p>
<p>MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据</p>
<p>读取行指针和orderby列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出—两次IO 从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。</p>
</li>
<li><p>单路排序</p>
<p>从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。</p>
</li>
<li><p>结论及引申出的问题</p>
<ul>
<li><p>由于单路是后出的，总体而言好过双路</p>
</li>
<li><p>在sort_buffer中，单路排序比双路排序要多占用很多空间，因为单路排序是把所有字段都取出, 所以有可能取出的数据的总大小<strong>超出了sort_buffer的容量</strong>，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。</p>
</li>
</ul>
</li>
<li><p>优化策略</p>
<ul>
<li>增大sort_buffer_size参数的设置</li>
<li>增大max_length_for_sort_data参数的设置</li>
<li>去掉select 后面不需要的字段</li>
</ul>
</li>
</ul>
<h3 id="GROUP-BY关键字优化"><a href="#GROUP-BY关键字优化" class="headerlink" title="GROUP BY关键字优化"></a>GROUP BY关键字优化</h3><ul>
<li>group by实质是先排序后进行分组，遵照索引建的最佳左前缀</li>
<li>当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置</li>
<li>where高于having，能写在where限定的条件就不要去having限定了。</li>
<li>尽量不要使用 distinct 关键字去重</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>慢查询日志查询</title>
    <url>/2020/11/16/mysql/%E9%AB%98%E7%BA%A7/2020_11_16-%E6%9F%A5%E8%AF%A2%E6%88%AA%E5%8F%96%E5%88%86%E6%9E%90/</url>
    <content><![CDATA[<h3 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h3><ul>
<li><p>MySQL的慢查询日志是MySQL提供的一种日志记录，它用来记录在MySQL中响应时间超过阀值的语句</p>
</li>
<li><p>具体指运行时间超过long_query_time值的SQL，则会被记录到慢查询日志中。long_query_time的默认值为10，意思是运行10秒以上的语句。</p>
</li>
<li><p>由他来查看哪些SQL超出了我们的最大忍耐时间值，比如一条sql执行超过5秒钟，我们就算慢SQL，希望能收集超过5秒的sql，结合之前explain进行全面分析。</p>
</li>
<li><p>相关变量</p>
<ul>
<li>slow_query_log： 慢查询日志开启</li>
<li>long_query_time： 日志记录sql语句的时间阈值，sql执行时间<strong>大于</strong>该时间就会记录</li>
<li>slow_query_log_file：日志记录位置</li>
<li>Slow_queries：当前慢查询日志记录的sql语句记录条数</li>
</ul>
<p>可以在配置文件中进行永久配置，也可以在命令端配置</p>
</li>
</ul>
<h3 id="日志分析工具mysqldumpslow"><a href="#日志分析工具mysqldumpslow" class="headerlink" title="日志分析工具mysqldumpslow"></a>日志分析工具mysqldumpslow</h3><ul>
<li><p>命令参数</p>
<ul>
<li>s: 是表示按照何种方式排序</li>
<li>c: 访问次数</li>
<li>l: 锁定时间</li>
<li>r: 返回记录</li>
<li>t: 查询行数</li>
<li>al:平均锁定时间</li>
<li>ar:平均返回记录数</li>
<li>at:平均查询时间</li>
<li>t:即为返回前面多少条的数据</li>
<li>g:后边搭配一个正则匹配模式，大小写不敏感的</li>
</ul>
</li>
<li><p>工作中常用命令</p>
<pre><code class="sql">得到返回记录集最多的10个SQL
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log
得到访问次数最多的10个SQL
mysqldumpslow -s c -t 10 /var/lib/mysql/atguigu-slow.log
得到按照时间排序的前10条里面含有左连接的查询语句
mysqldumpslow -s t -t 10 -g &quot;left join&quot; /var/lib/mysql/atguigu-slow.log
另外建议在使用这些命令时结合 | 和more 使用 ，否则有可能出现爆屏情况
mysqldumpslow -s r -t 10 /var/lib/mysql/atguigu-slow.log | more</code></pre>
</li>
</ul>
<h3 id="Show-Profile"><a href="#Show-Profile" class="headerlink" title="Show Profile"></a>Show Profile</h3><p>mysql提供可以用来分析当前会话中语句执行的资源消耗情况。可以用于SQL的调优的测量</p>
<p>默认情况下，参数处于关闭状态，并保存最近15次的运行结果</p>
<ul>
<li><p>开启</p>
<p><code>set profiling=1;</code></p>
</li>
<li><p>查看记录的sql</p>
<p><code>show profiles;</code></p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201116204847285.png" alt="image-20201116204847285" loading="lazy"></p>
</li>
<li><p>诊断sql</p>
<pre><code class="sql">show profiling [type] for query n; 
-- n 为Query_ID; 
-- type参数：
    -- ALL                        --显示所有的开销信息  
    -- BLOCK IO                   --显示块IO相关开销  
    -- CONTEXT SWITCHES           --上下文切换相关开销  
    -- CPU                        --显示CPU相关开销信息  
    -- IPC                        --显示发送和接收相关开销信息  
    -- MEMORY                     --显示内存相关开销信息  
    -- PAGE FAULTS                --显示页面错误相关开销信息  
    -- SOURCE                     --显示和Source_function，Source_file，Source_line相关的开销信息  
    -- SWAPS                        --显示交换次数相关开销的信息</code></pre>
<img src="https://raw.githubusercontent.com/soda1/img/main/image-20201116204950949.png" style="zoom:80%;" / loading="lazy">



</li>
</ul>
<ul>
<li>日常开发需要注意<code>show profile</code>中的status<ul>
<li><code>converting HEAP to MyISAM</code> 查询结果太大，内存都不够用了往磁盘上搬了。</li>
<li><code>creating tmp table</code> 创建临时表</li>
<li><code>copying to tmp table on disk</code> 把内存中临时表复制到磁盘，危险！！！</li>
<li><code>locked</code></li>
</ul>
</li>
</ul>
<h3 id="全局查询日志"><a href="#全局查询日志" class="headerlink" title="全局查询日志"></a>全局查询日志</h3><p>尽量不要在生产环境开启这个功能</p>
<ul>
<li><p>配置启用</p>
<pre><code class="properties">#在mysql的my.cnf中，设置如下：
#开启
general_log=1  
# 记录日志文件的路径
general_log_file=/path/logfile
#输出格式
log_output=FILE</code></pre>
</li>
<li><p>编码启用</p>
<pre><code class="sql">set global general_log=1;
#全局日志可以存放到日志文件中，也可以存放到Mysql系统表中。存放到日志中性能更好一些，存储到表中
set global log_output=&#39;TABLE&#39;;
此后 ，你所编写的sql语句，将会记录到mysql库里的general_log表，可以用下面的命令查看
select * from mysql.general_log;
</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>InnoDB锁</title>
    <url>/2020/11/17/mysql/%E9%AB%98%E7%BA%A7/2020_11_18-mysql%E9%94%81%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><ul>
<li><p>语法</p>
<p>上锁</p>
<pre><code class="mysql"> lock tables tableName1 (read|write) [,tableName2  (read|write)...];</code></pre>
<p>解锁</p>
<pre><code class="mysql">unlock tables;  -- 释放当前会话所有表级锁</code></pre>
</li>
</ul>
<p>lock tables 语法除了会限制别的线程的读写外，也限定了本线程。例如锁表t1的读锁，那么在此session中它也不能进行写表操作。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230227163207.png" alt="image-20230227163159921" loading="lazy"></p>
<h5 id="元数据锁：-meta-data-lock"><a href="#元数据锁：-meta-data-lock" class="headerlink" title="元数据锁：(meta data lock)"></a>元数据锁：(meta data lock)</h5><p>MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。在 MySQL 5.5 版本中引入了 MDL，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。</p>
<p>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</p>
<p>mysql5.6版本支持online ddl，如果是5.6以下版本做表结构变更时要特别小心，避免因MDL锁而阻塞线上查询更新。</p>
<h4 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h4><h5 id="锁种类"><a href="#锁种类" class="headerlink" title="锁种类"></a>锁种类</h5><ul>
<li><p><strong>Shared Locks（读锁S）</strong>：其他事务可以获取锁，多个读操作可以同时进行而不会互相影响</p>
</li>
<li><p><strong>Exclusive Locks  （写锁X）</strong>：其他事务需要等当前事务释放锁后才能获取，当前操作没完成之前，会阻塞其它写操作（update、insert、delete）</p>
</li>
<li><p><strong>Intention Locks（意向锁）</strong></p>
<p>表级别的锁。先提前声明一个意向，并获取表级别的意向锁（IS或IX），如果获取成功，则稍后将要或正在(才被允许)，对该表的某些行加锁(S或X)了。</p>
<p>意向锁支持多重粒度锁,允许行锁和表锁共存</p>
<ul>
<li>意向共享锁（IS）：在获取共享锁时必须先获取IS锁</li>
<li>意向排他锁（IX）：在获取排他锁时必须先获取IX锁</li>
</ul>
<p>兼容性如下：</p>
<table>
<thead>
<tr>
<th></th>
<th>X</th>
<th>IX</th>
<th>S</th>
<th>IS</th>
</tr>
</thead>
<tbody><tr>
<td>X</td>
<td>Conflict</td>
<td>Conflict</td>
<td>Conflict</td>
<td>Conflict</td>
</tr>
<tr>
<td>IX</td>
<td>Conflict</td>
<td>Compatible</td>
<td>Conflict</td>
<td>Compatible</td>
</tr>
<tr>
<td>S</td>
<td>Conflict</td>
<td>Conflict</td>
<td>Compatible</td>
<td>Compatible</td>
</tr>
<tr>
<td>IS</td>
<td>Conflict</td>
<td>Compatible</td>
<td>Compatible</td>
<td>Compatible</td>
</tr>
</tbody></table>
</li>
<li><p><strong>Record Locks（记录锁）</strong></p>
<p>对查index询条件中<strong>索引字段</strong>命中的行进行上锁，阻止其他事务insert、delete、update该行</p>
<p>record locks 总是会在索引行上加锁。即使一个表并没有设置索引，这种时候InnoDB会创建一个隐式的聚集索引（primary Key）,然后在这个聚集索引上加锁。</p>
<p>==注意：如果查询条件中有不走索引的字段，会锁表，导致其他事务进行insert、delete、update时阻塞==</p>
</li>
<li><p><strong>Gap locks（间隙锁）</strong></p>
<p>间隙锁定是对索引记录之间的间隙的锁定。</p>
<p>假设记录中只有[1,3,4]行，使用范围查找1-4行，这时候会产生间隙锁定，其他事务想要插入索引字段值为2的行会被阻塞</p>
<ul>
<li><p>对于使用唯一索引来搜索唯一行的语句 select a from ，不产生间隙锁定。组合唯一索引除外，即Gap locks不作用于单例唯一索引</p>
<pre><code class="sql">SELECT * FROM t1 WHERE id = 100;
--如果搜索字段不是索引或具有非唯一索引，将会锁定前面的间隙</code></pre>
</li>
<li><p>在重叠的间隙中（或者说重叠的行记录）中允许gap共存</p>
</li>
</ul>
</li>
<li><p><strong>Next-Key Locks</strong>  </p>
<p>Record Locks和Gap Locks的结合</p>
<p>==在隔离级别RR下，Next-Key Locks是默认开启的==</p>
</li>
<li><p><strong>Insert Intention Locks（插入意向锁）</strong></p>
</li>
<li><p><strong>AUTO-INC Locks</strong>  </p>
</li>
</ul>
<h5 id="锁操作"><a href="#锁操作" class="headerlink" title="锁操作"></a>锁操作</h5><ul>
<li><p>隐式上锁</p>
<p>select：不自动加锁</p>
<p>insert|update|delete：自动加写锁</p>
</li>
<li><p>显式上锁</p>
<pre><code class="sql">select * from tableName [lock in share mode|for update]</code></pre>
</li>
<li><p>解锁</p>
<p>提交事务：commit</p>
<p>回滚事务：rollback</p>
<p>kill阻塞进程</p>
</li>
<li><p>查看锁</p>
<pre><code class="sql">show status like &#39;innodb_row_lock%&#39;;
-- Innodb_row_lock_current_waits：当前正在等待锁定的数量；
-- Innodb_row_lock_time：从系统启动到现在锁定总时间长度；
-- Innodb_row_lock_time_avg：每次等待所花平均时间；
-- Innodb_row_lock_time_max：从系统启动到现在等待最常的一次所花的时间；
-- Innodb_row_lock_waits：系统启动后到现在总共等待的次数；</code></pre>
<p><code>information_schema</code>库中table：<code>innodb_lock_waits</code> 、<code>innodb_locks</code> 、<code>innodb_trx</code></p>
</li>
</ul>
<h3 id="事务中的锁"><a href="#事务中的锁" class="headerlink" title="事务中的锁"></a>事务中的锁</h3><h5 id="读未提交（Read-uncommitted）"><a href="#读未提交（Read-uncommitted）" class="headerlink" title="读未提交（Read uncommitted）"></a>读未提交（Read uncommitted）</h5><p>在任何情况下都不会加锁</p>
<h5 id="已提交读（Read-committed）"><a href="#已提交读（Read-committed）" class="headerlink" title="已提交读（Read committed）"></a>已提交读（Read committed）</h5><ul>
<li><p>读</p>
<p>在同一事务通过MVCC实现每次读一致。即每次读都会刷新快照，因此可以读到已提交，不使用锁。</p>
</li>
<li><p>写</p>
<p>对于<code>select...for update/lock in share mode</code>、<code>update</code>、<code>delete</code>等语句，只有record locks，没有gap locks。gap locks 只用在外键约束检查和重复键检查</p>
</li>
</ul>
<h5 id="可重复读（Repeatable-read）"><a href="#可重复读（Repeatable-read）" class="headerlink" title="可重复读（Repeatable read）"></a>可重复读（Repeatable read）</h5><ul>
<li><p>读</p>
<p>在同一事务通过MVCC来实现读一致（重复读），没有加读锁</p>
</li>
<li><p>写</p>
<p>使用<strong>next-key locks</strong>来锁当前读</p>
<p>对于<code>select...for update/lock in share mode</code>、<code>update</code>、<code>delete</code>等语句，使用什么锁取决于语句是只有唯一索引这一个条件还是搜索范围的条件</p>
<ul>
<li>只有一个唯一索引，使用record locks;</li>
<li>其他搜索条件，使用 gap locks 或者 next-key locks</li>
</ul>
</li>
</ul>
<h5 id="可串行化（Serializable"><a href="#可串行化（Serializable" class="headerlink" title="可串行化（Serializable )"></a>可串行化（Serializable )</h5><p>和RR差不多一样，区别就是如果手动commit，InnoDB会显示的对select语句加锁。</p>
<h3 id="加锁规则"><a href="#加锁规则" class="headerlink" title="加锁规则"></a>加锁规则</h3><ol>
<li>原则1：加锁的基本单位是next-key lock。希望你还记得，next-key lock是前开后闭区间。</li>
<li>原则2：查找过程中访问到的对象才会加锁。</li>
<li>优化1：索引上的等值查询，给唯一索引加锁的时候，next-key lock退化为行锁。</li>
<li>优化2：索引上的等值查询，向右遍历时且最后一个值不满足等值条件的时候，next-key lock退化为间隙锁。</li>
<li>一个bug：唯一索引上的范围查询会访问到不满足条件的第一个值为止。</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>mysql权限操作</title>
    <url>/2021/05/25/mysql/%E9%AB%98%E7%BA%A7/2021_05_25-mysql%E6%9D%83%E9%99%90/</url>
    <content><![CDATA[<h3 id="一、MySQL用户认证"><a href="#一、MySQL用户认证" class="headerlink" title="一、MySQL用户认证"></a><strong>一、MySQL用户认证</strong></h3><p>MySQL的用户认证形式是: 用户名+主机。比如<a href="mailto:&#x74;&#101;&#115;&#x74;&#x40;&#x31;&#50;&#x37;&#x2e;&#48;&#x2e;&#x30;&#x2e;&#x31;">&#x74;&#101;&#115;&#x74;&#x40;&#x31;&#50;&#x37;&#x2e;&#48;&#x2e;&#x30;&#x2e;&#x31;</a>和test@192.168.10.10是不一样的用户。就好比现实中的牛家村的张三和马家村的张三是分别两个人一样。MySQL中的权限分配都是分配到用户+主机的实体上。MySQL的主机信息可以是本地(localhost)，某个IP，某个IP段，以及任何地方等，即用户的地址可以限制到某个具体的IP，或者某个IP范围，或者任意地方。MySQL用户分为普通用户和root用户。root用户是超级管理员，拥有所有权限，普通用户只拥有被授予的各种权限。</p>
<h3 id="二、MySQL的权限分类及存储"><a href="#二、MySQL的权限分类及存储" class="headerlink" title="二、MySQL的权限分类及存储"></a><strong>二、MySQL的权限分类及存储</strong></h3><p><strong>1.MySQL用户权限层级</strong></p>
<ul>
<li>全局层级：全局权限适用于一个给定MySQL Server中的所有数据库，这些权限存储在mysql.user表中。</li>
</ul>
<pre><code class="text">GRANT ALL ON *.* TO &#39;user&#39;@&#39;host&#39;;  # *.* 表示数据库库的所有库和表，对应权限存储在mysql.user表中</code></pre>
<ul>
<li>数据库层级：数据库权限适用于一个给定数据库中的所有目标，这些权限存储在mysql.db表中。</li>
</ul>
<pre><code class="text">GRANT ALL ON mydb.* TO &#39;user&#39;@&#39;host&#39;;  #mydb.* 表示mysql数据库下的所有表，对应权限存储在mysql.db表中</code></pre>
<ul>
<li>表层级：表权限适用于一个给定表中的所有列，这些权限存储在mysql.tables_priv表中。</li>
</ul>
<pre><code class="text">GRANT ALL ON mydb.mytable TO &#39;user&#39;@&#39;host&#39;;  #mydb.mytable 表示mysql数据库下的mytable表，对应权限存储在mysql.tables_priv表</code></pre>
<ul>
<li>列层级：列权限使用于一个给定表中的单一列，这些权限存储在mysql.columns_priv表中。</li>
</ul>
<pre><code class="text">GRANT ALL (col1， col2， col3)  ON mydb.mytable TO &#39;user&#39;@&#39;host&#39;; #mydb.mytable 表示mysql数据库下的mytable表， col1, col2,  col3表示mytable表中的列名</code></pre>
<ul>
<li>子程序层级：CREATE ROUTINE、ALTER ROUTINE、EXECUTE和GRANT权限适用于已存储的子程序。这些权限可以被授予为全局层级和数据库层级。而且，除了CREATE ROUTINE外，这些权限可以被授予子程序层级，并存储在mysql.procs_priv表中。</li>
</ul>
<pre><code class="text">GRANT EXECUTE ON PROCEDURE mydb.myproc TO &#39;user&#39;@&#39;host&#39;; #mydb.mytable 表示mysql数据库下的mytable表，PROCEDUR表示存储过程</code></pre>
<p><strong>2. MySQL权限简单分类</strong></p>
<ul>
<li><strong>数据权限</strong>分为：库、表和字段三种级别</li>
<li><strong>管理权限</strong>主要是管理员要使用到的权限，包括：数据库创建，临时表创建、主从部署、进程管理等</li>
<li><strong>程序权限</strong>主要是触发器、存储过程、函数等权限。</li>
</ul>
<p><img src="https://pic4.zhimg.com/80/v2-4cbe51f1e13be60df6450ac0c0e7c7cb_720w.jpg" alt="img" loading="lazy"></p>
<p><strong>2. MySQL权限详情</strong></p>
<p><img src="https://pic4.zhimg.com/80/v2-c728eac606a79231f2d7681b24a03d73_720w.jpg" alt="img" loading="lazy"></p>
<blockquote>
<p>第一列表示可以在grant命令中制定的权限第二列对应着几张权限表(user,db,tables_priv, columns_priv, procs_priv)中的列第三列表示权限的作用范围，其中Global（Server administration）对应 mysql.user 表，Database 对应 mysql.db 表，Tables 对应 mysql.tables_priv 表，Columns 对应 mysql.columns_priv 表，Stored routines 对应 mysql.procs_priv 表。</p>
</blockquote>
<p>MYSQL的权限如何分布，就是针对表可以设置什么权限，针对列可以设置什么权限等等，这个可以从官方文档中的一个表来说明：</p>
<p><strong>权限分布可能设置的权限</strong>表权限Select, Insert, Update, Delete, Create, Drop, Grant, References, Index, Alter列权限Select, Insert, Update, References程序权限Execute, Alter Routine, Grant</p>
<h3 id="三、-MySQL访问控制"><a href="#三、-MySQL访问控制" class="headerlink" title="三、 MySQL访问控制"></a><strong>三、 MySQL访问控制</strong></h3><p>MySQL访问控制分为两个阶段:</p>
<ol>
<li>用户连接检查阶段</li>
<li>执行SQL语句时检查阶段</li>
</ol>
<h4 id="1、用户连接时的检查"><a href="#1、用户连接时的检查" class="headerlink" title="1、用户连接时的检查"></a><strong>1、用户连接时的检查</strong></h4><p>1）当用户连接时，MySQL服务器首先从user表里匹配host, user, password，匹配不到则拒绝该连接2）接着检查user表的max_connections和max_user_connections，如果超过上限则拒绝连接3）检查user表的SSL安全连接，如果有配置SSL，则需确认用户提供的证书是否合法只有上面3个检查都通过后，服务器才建立连接，连接建立后，当用户执行SQL语句时，需要做SQL语句执行检查。</p>
<h4 id="2、执行SQL语句时的检查"><a href="#2、执行SQL语句时的检查" class="headerlink" title="2、执行SQL语句时的检查"></a><strong>2、执行SQL语句时的检查</strong></h4><p>1）从user表里检查max_questions和max_updates，如果超过上限则拒绝执行SQL下面几步是进行权限检查：2）首先检查user表，看是否具有相应的全局性权限，如果有，则执行，没有则继续下一步检查3）接着到db表，看是否具有数据库级别的权限，如果有，则执行，没有则继续下一步检查4）最后到tables_priv, columns_priv, procs_priv表里查看是否具有相应对象的权限从以上的过程我们可以知道，MySQL检查权限是一个比较复杂的过程，所以为了提高性能，MySQL的启动时就会把这5张权限表加载到内存。</p>
<h3 id="四、权限表字段详解"><a href="#四、权限表字段详解" class="headerlink" title="四、权限表字段详解"></a><strong>四、权限表字段详解</strong></h3><p><strong>1.user表</strong>user表的权限是基于服务器范围的所有权限，比如用户拥有服务器中所有数据库的select权限那么在user表中的Select_priv列为Y,如果用户单单只拥有某个一数据库的select权限那么user表中的Select_priv为N,会在DB表中记录一条信息在DB表中的select_priv为Y。</p>
<pre><code class="text">desc mysql.user;</code></pre>
<p><img src="https://pic1.zhimg.com/80/v2-022167c990b41d56219b99ee93df77b8_720w.jpg" alt="img" loading="lazy"></p>
<p><strong>2.db表</strong>如果授予一个用户单独某个数据库的权限，就会在db表中记录一条相关信息。</p>
<pre><code class="text">desc mysql.db;</code></pre>
<p><img src="https://pic2.zhimg.com/80/v2-d0a02a81c598b640a2c0e8020b5d3675_720w.jpg" alt="img" loading="lazy"></p>
<p><strong>3.tables_priv表</strong></p>
<pre><code class="text">desc mysql.tables_priv;</code></pre>
<p><img src="https://pic2.zhimg.com/80/v2-4b97a4573ff306575b3e5f8d07d22949_720w.jpg" alt="img" loading="lazy"></p>
<blockquote>
<p>上面的Column_priv比较奇怪，因为照理说tables_priv只显示表级别的权限，列级别的权限应该在columns_priv里显示才对。后来查了资料才知道，原来这是为了提高权限检查时的性能，试想一下，权限检查时，如果发现tables_priv.Column_priv为空，就不需要再检查columns_priv表了，这种情况在现实中往往占大多数。</p>
</blockquote>
<p><strong>4. columns_priv表</strong></p>
<pre><code class="text">desc mysql.columns_priv;</code></pre>
<p><img src="https://pic1.zhimg.com/80/v2-babb1c33a8a3d64b0b7dfa01635302ac_720w.jpg" alt="img" loading="lazy"></p>
<p><strong>5. procs_priv表</strong></p>
<pre><code class="text">desc mysql.procs_priv;</code></pre>
<p><img src="https://pic4.zhimg.com/80/v2-cf3a2f275c3f680ce89ed21432926eef_720w.jpg" alt="img" loading="lazy"></p>
<h3 id="五、用户管理实践"><a href="#五、用户管理实践" class="headerlink" title="五、用户管理实践"></a><strong>五、用户管理实践</strong></h3><p><strong>1.用户创建</strong></p>
<ul>
<li>通过create user语句创建用户</li>
</ul>
<p>在执行CREATE USER或CRANT语句后，MySQL服务器会修改相应的用户权限表，添加或修改用户及权限。</p>
<pre><code class="text">create user &#39;USERNAME&#39;@&#39;HOST&#39; identified by &#39;PASSWORD&#39;;</code></pre>
<blockquote>
<p>HOST的形式：1. IP地址，如172.16.16.1；2. 主机名，如localhost；3. 网络地址，如172.16.0.04. 通配符，如%：匹配任意字符<em>：匹配任意单个字符如172.16.16.</em>(允许172.16.16.1-172.16.16.9)</p>
</blockquote>
<p>eg:</p>
<pre><code class="text">mysql&gt; CREATE USER &#39;jeffrey&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;mypass&#39;;
Query OK, 0 rows affected (0.00 sec)</code></pre>
<ul>
<li>通过grant语句创建新用户</li>
</ul>
<p>GRANT语句是添加新用户并授权它们访问MySQL对象的首选方法，其语法格式为：</p>
<pre><code class="text">grant all on DB_NAME.TABLE_NAME to &#39;USERNAME&#39;@&#39;HOST&#39; identified by &#39;PASSWORD&#39;;</code></pre>
<blockquote>
<p>HOST的表现形式和create user一样</p>
</blockquote>
<p>eg：</p>
<pre><code class="text"># 用户 testUser对所有的数据有查询和更新权限，并授于对所有数据表的SELECT和UPDATE权限
mysql&gt; GRANT SELECT,UPDATE  ON *.* TO &#39;testUser&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;testpwd&#39;;
Query OK, 0 rows affected (0.00 sec)</code></pre>
<ol>
<li>创建root用户</li>
</ol>
<pre><code class="text">mysql&gt; GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;root&#39; WITH GRANT OPTION;
mysql&gt; flush privileges;</code></pre>
<p>2). 创建一个基本的增删改查用户</p>
<pre><code class="text">mysql&gt; GRANT UPDATE, DELETE, INSERT, SELECT ON *.* TO &#39;test&#39;@&#39;%&#39; identified by &#39;test&#39; WITH MAX_QUERIES_PER_HOUR 0 MAX_CONNECTIONS_PER_HOUR 0 MAX_UPDATES_PER_HOUR 0 MAX_USER_CONNECTIONS 0; 
mysql&gt; flush privileges;
# MAX_QUERIES_PER_HOUR，MAX_CONNECTIONS_PER_HOUR，MAX_UPDATES_PER_HOUR设置为0表示不限制</code></pre>
<p>3). 创建数据库基本的增删改查用户</p>
<pre><code class="text">mysql&gt; GRANT SELECT, INSERT, UPDATE, DELETE, SHOW VIEW, EXECUTE ON `db_name`.* TO &#39;test&#39;@&#39;%&#39; identified by  &#39;test&#39;;
mysql&gt; flush privileges;</code></pre>
<p>4). 授予数据库名以db开头的数据库的权限</p>
<pre><code class="text">mysql&gt; GRANT SELECT, INSERT, UPDATE, DELETE, SHOW VIEW, EXECUTE ON `db%`.* TO &#39;perform&#39;@&#39;%&#39;;
mysql&gt; flush privileges;</code></pre>
<p>5). 创建备份用户权限</p>
<pre><code class="text">mysql&gt; GRANT SELECT,EVENT,SHOW DATABASES,LOCK TABLES,SUPER,REPLICATION CLIENT ON *.* TO &#39;backup&#39;@&#39;localhost&#39; identified by &#39;backup&#39;;
mysql&gt; flush privileges;</code></pre>
<p>6). 备份恢复用户权限</p>
<pre><code class="text">mysql&gt; GRANT INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER,CREATE VIEW, SHOW VIEW, CREATE ROUTINE, ALTER ROUTINE, EVENT, TRIGGER ON *.* TO &#39;restore&#39;@&#39;localhost&#39; identified by &#39;123456&#39;;
mysql&gt; flush privileges;</code></pre>
<p>7). 复制用户权限</p>
<pre><code class="text">mysql&gt; GRANT PROCESS, REPLICATION SLAVE, REPLICATION CLIENT ON *.* TO &#39;repl&#39;@&#39;%&#39; IDENTIFIED BY &#39;123456&#39;;
mysql&gt; flush privileges;</code></pre>
<p><strong>2.用户删除</strong></p>
<pre><code class="text">mysql&gt; drop user &#39;USERNAME&#39;@&#39;HOST&#39;;
# 删除MySQL默认的无用账户;
mysql&gt; drop user &#39;root&#39;@&#39;localhost.localdomain&#39;;

# 删除MySQL默认的无用账户;
mysql&gt; drop user &#39;root&#39;@&#39;127.0.0.1&#39;;</code></pre>
<p><strong>3. 更改用户名</strong></p>
<pre><code class="text">mysql&gt; rename user OLD_NAME to NEW_NAME; </code></pre>
<p><strong>4. 修改用户密码</strong></p>
<ul>
<li>通过mysqladmin工具</li>
</ul>
<pre><code class="text"># 给root@localhost用户登录mysql设置密码为&quot;redhat&quot;;
$ mysqladmin -u root -h localhost password &quot;redhat&quot; 

# 修改root@localhost用户登录mysql数据库的密码;
$ mysqladmin -u root -h localhost password &quot;new passwd&quot; -p &quot;old passwd&quot;</code></pre>
<ul>
<li>通过直接修改mysql.user表的用户记录</li>
</ul>
<pre><code class="text"># MySQL 5.6
mysql&gt; update mysql.user set password=PASSWORD(&#39;redhat&#39;) where user=&#39;root&#39;;
mysql&gt; flush privileges;

# MySQL 5.7
mysql&gt; update mysql.user set authentication_string=PASSWORD(&#39;redhat&#39;) where user=&#39;root&#39;;
mysql&gt; flush privileges;</code></pre>
<ul>
<li>set password语句</li>
</ul>
<pre><code class="text">mysql&gt; set password for &#39;root&#39;@&#39;localhost&#39;=PASSWORD(&#39;redhat&#39;);
mysql&gt; flush privileges;</code></pre>
<ul>
<li>ALTER USER语句(MYSQL5.7版本)</li>
</ul>
<pre><code class="text">mysql&gt; use mysql
mysql&gt; alter user root@&#39;localhost&#39; identified by &#39;123456&#39;;
mysql&gt; flush privileges;</code></pre>
<h3 id="六、MySQL管理员密码找回"><a href="#六、MySQL管理员密码找回" class="headerlink" title="六、MySQL管理员密码找回"></a><strong>六、MySQL管理员密码找回</strong></h3><p><strong>1.修改配置文件，跳过授权表</strong>在配置文件中[mysqld]字段添加skip-grant-tables指令</p>
<pre><code class="text">$ cat /etc/my.cnf 
[mysqld]
skip-grant-tables</code></pre>
<p><strong>2. 重启MySQL Server</strong></p>
<pre><code class="text">service mysqld restart</code></pre>
<p><strong>3. 给root用户登录mysql设置密码为helloWORD并以加密方式</strong></p>
<pre><code class="text">mysql&gt; use mysql;
# MySQL5.6
mysql&gt; update user set password=PASSWORD(&#39;helloWORD&#39;) where user=&#39;root&#39;;
# MySQL5.7
mysql&gt;  update mysql.user set authentication_string=PASSWORD(&#39;helloWORD&#39;) where user=&#39;root&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>4.修改配置文件，注释刚才添加的配置项</strong></p>
<pre><code class="text">$ cat /etc/my.cnf 
[mysqld]
#skip-grant-tables</code></pre>
<p><strong>5.重启MySQL Server</strong></p>
<pre><code class="text">service mysqld restart</code></pre>
<h3 id="七、-MySQL-权限管理实践"><a href="#七、-MySQL-权限管理实践" class="headerlink" title="七、 MySQL 权限管理实践"></a><strong>七、 MySQL 权限管理实践</strong></h3><p>账户权限信息被存储在MySQL数据库的几张权限表中，在MySQL启动时，服务器将这些数据库表中权限信息的内容读入内存。其中GRANT和REVOKE语句所涉及的常用权限大致如下这些：CREATE、DROP、SELECT、INSERT、UPDATE、DELETE、INDEX、ALTER、CREATE、ROUTINE、FILE等，还有一个特殊的proxy权限，是用来赋予某个用户具有给他人赋予权限的权限。<strong>1. grant 所有权限</strong></p>
<pre><code class="text">mysql&gt; grant all privileges on *.* to &#39;USERNAME&#39;@&#39;HOST&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>2. grant super权限在*.*上(super权限可以对全局变量更改)；</strong></p>
<pre><code class="text">mysql&gt; grant super on *.* to &#39;USERNAME&#39;@&#39;HOST&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>3. grant某个库下所有表的所有权限</strong></p>
<pre><code class="text">mysql&gt; grant all privileges on DB_NAME.* to &#39;USERNAME&#39;@&#39;HOST&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>4. grant某个库下所有表的select权限</strong></p>
<pre><code class="text">mysql&gt;grant select on DB_NAME.* to &#39;USERNAME&#39;@&#39;HOST&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>5. grant某个库下某个表的insert权限</strong></p>
<pre><code class="text">mysql&gt; grant insert on  DB_NAME.TABLE_NAME to &#39;USERNAME&#39;@&#39;HOST&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>6. grant某个库下某个表的update权限</strong></p>
<pre><code class="text">mysql&gt;grant update on DB_NAME.TABLE_NAME to &#39;USERNAME&#39;@&#39;HOST&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>7. grant某个库下某个表的某个字段update权限</strong></p>
<pre><code class="text">mysql&gt; grant update(COLUMN_NAME)  on DB_NAME.TABLE_NAME to &#39;USERNAME&#39;@&#39;HOST&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>8.通过GRANT语句中的USAGE权限，可以创建账户而不授予任何权限</strong></p>
<pre><code class="text">mysql&gt; grant usage on *.* to &#39;USERNAME&#39;@&#39;HOST&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>9. grant创建、修改、删除MySQL数据表结构权限</strong></p>
<pre><code class="text">mysql&gt; grant create on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt; grant alter on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt; grant drop on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>10. grant操作MySQL外键权限</strong></p>
<pre><code class="text">mysql&gt; grant references on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>11. grant操作MySQL临时表权限</strong></p>
<pre><code class="text">mysql&gt; grant create temporary tables on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>12. grant操作MySQL索引权限</strong></p>
<pre><code class="text">mysql&gt; grant index on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt;  flush privileges;</code></pre>
<p><strong>13.grant操作MySQL视图、查看视图源代码权限</strong></p>
<pre><code class="text">mysql&gt; grant create view on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt; grant show view on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt; flush privileges;</code></pre>
<p><strong>14. grant操作MySQL存储过程、存储函数权限</strong></p>
<pre><code class="text">mysql&gt; grant create routine on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt; grant alter routine on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt; grant execute on testdb.* to developer@&#39;192.168.0.%&#39;;
mysql&gt; flush privileges;</code></pre>
<p><strong>15.PROXY特殊权限</strong>如果想让某个用户具有给他人赋予权限的能力，那么就需要proxy权限了。当你给一个用户赋予all权限之后，你查看mysql.user表会发现Grant_priv字段还是为N，表示其没有给他人赋予权限的权限。</p>
<p>我们可以查看一下系统默认的超级管理员权限：</p>
<pre><code class="text">mysql&gt; show grants for &#39;root&#39;@&#39;localhost&#39;;
+---------------------------------------------------------------------+
| Grants for root@localhost                                           |
+---------------------------------------------------------------------+
| GRANT ALL PRIVILEGES ON *.* TO &#39;root&#39;@&#39;localhost&#39; WITH GRANT OPTION |
| GRANT PROXY ON &#39;&#39;@&#39;&#39; TO &#39;root&#39;@&#39;localhost&#39; WITH GRANT OPTION        |
+---------------------------------------------------------------------+
2 rows in set (0.00 sec)</code></pre>
<p>可以看到其本身有PROXY权限，并且这个语句跟一般授权语句还不太一样。所以如果想让一个远程用户有给他人赋予权限的能力，就需要给此用户PROXY权限，如下：</p>
<pre><code class="text">mysql&gt; grant all on *.* to &#39;test&#39;@&#39;%&#39; identified by &#39;helloWORD&#39;;
mysql&gt; GRANT PROXY ON &#39;&#39;@&#39;&#39; TO &#39;test&#39;@&#39;%&#39; WITH GRANT OPTION;
mysql&gt; flush privileges;</code></pre>
<p><strong>16. 查看用户的权限</strong></p>
<pre><code class="text">Mysql&gt; show grants for &#39;USERNAME&#39;@&#39;HOST&#39;;</code></pre>
<p><strong>17. 移除用户权限</strong></p>
<pre><code class="text"># 移除tom用户对于db.xsb的权限;
Mysql&gt; revoke all on db.xsb from &#39;tom&#39;@&#39;localhost&#39;;
# 刷新授权表;
Mysql&gt; flush privileges;</code></pre>
<blockquote>
<p>使用REVOKE收回权限之后，用户帐户的记录将从db、host、tables_priv、columns_priv表中删除，但是用户帐号依然在user表中保存。</p>
</blockquote>
<h3 id="八、MySQL-用户和权限管理经验"><a href="#八、MySQL-用户和权限管理经验" class="headerlink" title="八、MySQL 用户和权限管理经验"></a><strong>八、MySQL 用户和权限管理经验</strong></h3><p><strong>1. 用户管理经验</strong></p>
<ul>
<li>1)、尽量使用create user, grant等语句，而不要直接修改权限表。</li>
</ul>
<p>虽然create user, grant等语句底层也是修改权限表，和直接修改权限表的效果是一样的，但是，对于非高手来说，采用封装好的语句肯定不会出错，而如果直接修改权限表，难免会漏掉某些表。而且，修改完权限表之后，还需要执行flush privileges重新加载到内存，否则不会生效。</p>
<ul>
<li>2). 把匿名用户删除掉。</li>
</ul>
<p>匿名用户没有密码，不但不安全，还会产生一些莫名其妙的问题，强烈建议删除。</p>
<p><strong>2. 权限管理经验</strong></p>
<ul>
<li>1)、只授予能满足需要的最小权限，防止用户干坏事。比如用户只是需要查询，那就只给select权限就可以了，不要给用户赋予update、insert或者delete权限。</li>
<li>2)、创建用户的时候限制用户的登录主机，一般是限制成指定IP或者内网IP段。</li>
<li>3)、初始化数据库的时候删除没有密码的用户。安装完数据库的时候会自动创建一些用户，这些用户默认没有密码。</li>
<li>4)、为每个用户设置满足密码复杂度的密码。</li>
<li>5)、定期清理不需要的用户，回收权限或者删除用户。</li>
</ul>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>mysql内部状态查看命令</title>
    <url>/2022/09/07/mysql/%E9%AB%98%E7%BA%A7/2022_09_07-mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%8F%8A%E8%A1%A8/</url>
    <content><![CDATA[<h5 id="查看当前未提交的事务"><a href="#查看当前未提交的事务" class="headerlink" title="查看当前未提交的事务"></a>查看当前未提交的事务</h5><pre><code class="mysql">select * from information_schema.innodb_trx;</code></pre>
<h5 id="查看线程状态"><a href="#查看线程状态" class="headerlink" title="查看线程状态"></a>查看线程状态</h5><pre><code class="mysql">show processlist;</code></pre>
<h5 id="查看表MDL锁状态"><a href="#查看表MDL锁状态" class="headerlink" title="查看表MDL锁状态"></a>查看表MDL锁状态</h5><ol>
<li><p>首先确定Performance Schema.metadata_locks table是开启的，如果没有开启，开启后先前的占用锁是不会记录的</p>
<p>在线开启方式</p>
<pre><code class="mysql">UPDATE performance_schema.setup_instruments
SET ENABLED = &#39;YES&#39;, TIMED = &#39;YES&#39;
WHERE NAME = &#39;wait/lock/metadata/sql/mdl&#39;;</code></pre>
</li>
<li><p>查找锁表的线程</p>
<pre><code class="mysql">select * from sys.schema_table_lock_waits\G;</code></pre>
</li>
</ol>
<h5 id="查看engine状态"><a href="#查看engine状态" class="headerlink" title="查看engine状态"></a>查看engine状态</h5><pre><code class="mysql">show engine innodb status;</code></pre>
<h5 id="查看行锁状态"><a href="#查看行锁状态" class="headerlink" title="查看行锁状态"></a>查看行锁状态</h5><pre><code class="mysql">select * from  sys.innodb_lock_waits where locked_table = &#39;`test`.`t`&#39;\G;</code></pre>
<p>也可以直接看information_schema.innodb_lock_waits表</p>
<h5 id="修改事务隔离级别"><a href="#修改事务隔离级别" class="headerlink" title="修改事务隔离级别"></a>修改事务隔离级别</h5><pre><code class="mysql">SET [GLOBAL | SESSION] TRANSACTION
    transaction_characteristic [, transaction_characteristic] ...

transaction_characteristic: &#123;
    ISOLATION LEVEL level
  | access_mode
&#125;

level: &#123;
     REPEATABLE READ
   | READ COMMITTED
   | READ UNCOMMITTED
   | SERIALIZABLE
&#125;

access_mode: &#123;
     READ WRITE
   | READ ONLY
&#125;
    set session transaction ISOLATION LEVEL READ COMMITTED;
//查看隔离级别
SELECT @@GLOBAL.transaction_isolation, @@GLOBAL.transaction_read_only;
SELECT @@SESSION.transaction_isolation, @@SESSION.transaction_read_only;</code></pre>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>binary log相关操作</title>
    <url>/2022/09/11/mysql/%E9%AB%98%E7%BA%A7/2022_09_11-binary%20log/</url>
    <content><![CDATA[<h5 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h5><p>记录更改数据/数据库的日志，一般用于主从库同步或数据恢复</p>
<h5 id="开启数据日志"><a href="#开启数据日志" class="headerlink" title="开启数据日志"></a>开启数据日志</h5><p>在my.cnf增加配置，有好几种方式，这种比较简单</p>
<pre><code class="shell">#开启binlog日志
log-bin = /usr/local/mysql/mysql-5.7.24/data/mysql-bin
#配置serverid
server-id = 1
#配置日志过期时间
expire_logs_days = 7
#配置每个binlog文件大小
max_binlog_size = 100m
#binlog缓存大小
binlog_cache_size = 4m
#最大binlog缓存大小
max_binlog_cache_size = 40m
</code></pre>
<h5 id="相关变量"><a href="#相关变量" class="headerlink" title="相关变量"></a>相关变量</h5><ol>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_binlog_format"><code>binlog_format</code></a></p>
<table>
<thead>
<tr>
<th align="left">Command-Line Format</th>
<th><code>--binlog-format=format</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">System Variable</td>
<td><code>binlog_format</code></td>
</tr>
<tr>
<td align="left">Scope</td>
<td>Global, Session</td>
</tr>
<tr>
<td align="left">Dynamic</td>
<td>Yes</td>
</tr>
<tr>
<td align="left">Type</td>
<td>Enumeration</td>
</tr>
<tr>
<td align="left">Default Value</td>
<td><code>ROW</code></td>
</tr>
<tr>
<td align="left">Valid Values</td>
<td><code>MIXED``STATEMENT``ROW</code></td>
</tr>
</tbody></table>
<p>binlog记录格式，binlog格式为statement。会出现数据与日志不一致情况，比如sql中用了随机函数（UUID()），那么到从库中数据会出现不一致情况。具体阅读<a href="https://dev.mysql.com/doc/refman/8.0/en/replication-sbr-rbr.html">https://dev.mysql.com/doc/refman/8.0/en/replication-sbr-rbr.html</a></p>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_expire_logs_days"><code>expire_logs_days</code></a></p>
<table>
<thead>
<tr>
<th align="left">Command-Line Format</th>
<th><code>--expire-logs-days=#</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">System Variable</td>
<td><code>expire_logs_days</code></td>
</tr>
<tr>
<td align="left">Scope</td>
<td>Global</td>
</tr>
<tr>
<td align="left">Dynamic</td>
<td>Yes</td>
</tr>
<tr>
<td align="left">Type</td>
<td>Integer</td>
</tr>
<tr>
<td align="left">Default Value</td>
<td><code>0</code></td>
</tr>
<tr>
<td align="left">Minimum Value</td>
<td><code>0</code></td>
</tr>
<tr>
<td align="left">Maximum Value</td>
<td><code>99</code></td>
</tr>
<tr>
<td align="left">Unit</td>
<td>days</td>
</tr>
</tbody></table>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_log_bin"><code>log_bin</code></a></p>
<table>
<thead>
<tr>
<th align="left">System Variable</th>
<th><code>log_bin</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Scope</td>
<td>Global</td>
</tr>
<tr>
<td align="left">Dynamic</td>
<td>No</td>
</tr>
<tr>
<td align="left">Type</td>
<td>Boolean</td>
</tr>
</tbody></table>
</li>
<li><p><a href="https://dev.mysql.com/doc/refman/5.7/en/replication-options-binary-log.html#sysvar_log_bin_basename"><code>log_bin_basename</code></a></p>
<table>
<thead>
<tr>
<th align="left">System Variable</th>
<th><code>log_bin_basename</code></th>
</tr>
</thead>
<tbody><tr>
<td align="left">Scope</td>
<td>Global</td>
</tr>
<tr>
<td align="left">Dynamic</td>
<td>No</td>
</tr>
<tr>
<td align="left">Type</td>
<td>File name</td>
</tr>
</tbody></table>
</li>
</ol>
<h5 id="日志查看"><a href="#日志查看" class="headerlink" title="日志查看"></a>日志查看</h5><ol>
<li><p>mysql查看binlog</p>
<pre><code class="mysql">show binlog events;  #只查看第一个binlog文件的内容
show binlog events in mysql-bin.000002;#查看指定binlog文件的内容
show binary logs; #获取binlog文件列表
show master status； #查看当前正在写入的binlog文件</code></pre>
</li>
<li><p>使用mysqlbinlog工具</p>
<p>一般的<code>statement</code>格式的二进制文件，用下面命令就可以</p>
<pre><code class="shell">mysqlbinlog mysql-bin.000001</code></pre>
<p>如果是<code>row</code>格式，加上<code>-v</code>或者<code>-vv</code>参数就行，如</p>
<pre><code class="shell">mysqlbinlog -vv --start-position=458 mysql-bin.000001</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>join相关算法</title>
    <url>/2022/09/24/mysql/%E9%AB%98%E7%BA%A7/2022_09_24-join/</url>
    <content><![CDATA[<h3 id="join的使用的算法"><a href="#join的使用的算法" class="headerlink" title="join的使用的算法"></a>join的使用的算法</h3><ol>
<li><p>index nested-loop join（NLJ）</p>
<p>join的条件中如果可以走索引，那么就会使用此算法</p>
<p>例子：</p>
<pre><code class="mysql">select * from t1 straight_join t2 on (t1.a = t2.a)</code></pre>
<p>步骤如下</p>
<ol>
<li>从t1中取出一行数据</li>
<li>从这行数据中取出a字段，然后去t2中通过树索引找到匹配的数据</li>
<li>将数据合成一行加入结果集</li>
<li>重复1-3步骤</li>
</ol>
</li>
<li><p>block nested-loop join（BNL）</p>
<p>如果join的条件无法走索引，那么会将驱动表加入join__buffer，然后在去遍历被驱动表</p>
<p>例子</p>
<pre><code class="mysql">select * from t1 straight_join t2 on (t1.a = t2.b) //b没有索引</code></pre>
<p>步骤如下</p>
<ol>
<li>从t1中取出所有的数据加入join_buffer</li>
<li>从t2中取出一行数据R</li>
<li>将R与join_buffer里面的t1数据进行匹配，加入结果集</li>
<li>重复2-3步骤</li>
</ol>
<p>如果join_buffer不能容纳t1中所有的数据，那么就会执行分批放的策略</p>
</li>
</ol>
<h3 id="优化"><a href="#优化" class="headerlink" title="优化"></a>优化</h3><ol>
<li><p>小表驱动大表</p>
<p>无论什么时候都应该用小表去驱动大表，即小数据驱动大数据</p>
</li>
<li><p>转BKA算法</p>
<p>BKA优化开启</p>
<pre><code class="mysql">set optimizer_switch=&#39;mrr=on,mrr_cost_based=off,batched_key_access=on&#39;;</code></pre>
<ol>
<li><p>INJ 转 BKA</p>
<p>只要开启BKA优化即可，通过使用join_buffer来读驱动表数据，然后在通过MRR优化来顺序读取读取数据</p>
</li>
<li><p>BNL转BKA</p>
<p>对于一些冷数据查询，建立索引会显得浪费，那么如果可以通过创建临时表的方法将被驱动表中符合条件的数据放入创建的临时表并创建索引。用临时表作为被驱动表，这样就可以使用BKA优化了</p>
</li>
</ol>
</li>
</ol>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>mysql扩容</title>
    <url>/2023/03/09/mysql/%E9%AB%98%E7%BA%A7/mysql%E6%89%A9%E5%AE%B9/</url>
    <content><![CDATA[<h4 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h4><p>当单表数据量过大时，性能会受到比较大的影响。分库分表指的是将单表的数据通过某种规则平均的分散在多个数据库或多张表中。</p>
<h4 id="水平分"><a href="#水平分" class="headerlink" title="水平分"></a><strong>水平分</strong></h4><h5 id="水平分表"><a href="#水平分表" class="headerlink" title="水平分表"></a><strong>水平分表</strong></h5><p>场景：当单表仅仅是因为数据量过大时，影响SQL查询效率</p>
<p>理论：以字段为依据，按照一定策略（hash、range等），将一个表中的数据以行为单位拆分到多个表中，尽可能的让数据均匀分布</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230310104313.jpg" loading="lazy"></p>
<h5 id="水平分库"><a href="#水平分库" class="headerlink" title="水平分库"></a>水平分库</h5><p>场景：系统绝对并发量上来了，网络IO成为了瓶颈</p>
<p>理论：以字段为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中，从而将网络请求摊分到多个库中</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230310104511.jpg" loading="lazy"></p>
<h4 id="垂直分"><a href="#垂直分" class="headerlink" title="垂直分"></a>垂直分</h4><h5 id="垂直分表"><a href="#垂直分表" class="headerlink" title="垂直分表"></a>垂直分表</h5><p>场景：当表中记录不多时，由于字段比较多，单行存储空间比较大，产生IO瓶颈</p>
<p>理论：以字段为依据，按字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中，一般用主键来将主表和扩展表关联在一起</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230310105634.jpg" loading="lazy"></p>
<h5 id="垂直分库"><a href="#垂直分库" class="headerlink" title="垂直分库"></a>垂直分库</h5><p>场景：系统绝对并发量上来了，并且可以按业务抽象出单独的模块</p>
<p>理论：以表为依据，按业务归属，将不同表划分到不同库中</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230310110314.jpg" loading="lazy"></p>
]]></content>
      <categories>
        <category>mysql</category>
        <category>adv</category>
      </categories>
  </entry>
  <entry>
    <title>Config(Hoxton.SR8)</title>
    <url>/2023/04/04/spring/spring%20cloud/Config/</url>
    <content><![CDATA[<p>随着项目的迭代，微服务的数量不断增多，我们需要高效的管理配置，spring cloud config可以帮我们解决此问题</p>
<p>spring cloud config分为config server和config client两部分，具有以下特点</p>
<ol>
<li>集中管理配置。一个使用微服务架构的应用系统可能会包含成百上千个微服务，因此集中管理配置是非常有必要的；</li>
<li>不同环境，不同配置。例如，数据源配置在不同的环境（开发、测试、预发布、生产等）中是不同的；</li>
<li>运行期间可动态调整。例如，我们可根据各个微服务的负载情况，动态调整数据源连接池大小或熔断阈值，并且在调整配置时不停止微服务；</li>
<li>配置修改后可自动更新。如配置内容发生变化，微服务能够自动更新配置。</li>
</ol>
<h4 id="config-server"><a href="#config-server" class="headerlink" title="config server"></a>config server</h4><p>config server是一个可横向扩展、集中式的配置服务器，它用于集中管理应用程序在不同环境下的配置，默认使用git存储配置内容</p>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><ol>
<li><p>加依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-config-server&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</li>
<li><p>加注解</p>
<pre><code class="java">@SpringBootApplication
@EnableConfigServer
public class ConfigServerApplication &#123;

    public static void main(String[] args) &#123;
    SpringApplication.run(ConfigServerApplication.class, args);
    &#125;

&#125;</code></pre>
</li>
<li><p>写配置</p>
<pre><code class="java">server:
  port: 8094
spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: file://F:\Java\Code\SpringCloud/config-repo # 具体仓库地址</code></pre>
<p>这里配置的是本地仓库，方便测试。如果要配置线上的，需要账户密码</p>
<pre><code class="yml">server:
  port: 8094
spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri:  https://git.xxx/repo.git # 具体仓库地址
          # Git仓库账号
          username:
          # Git仓库密码
          password:    </code></pre>
</li>
</ol>
<h5 id="访问"><a href="#访问" class="headerlink" title="访问"></a>访问</h5><p>config server提供了api，可以用来访问git仓库中的配置文件</p>
<pre><code>/&#123;application&#125;/&#123;profile&#125;[/&#123;label&#125;]
/&#123;application&#125;-&#123;profile&#125;.yml
/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.yml
/&#123;application&#125;-&#123;profile&#125;.properties
/&#123;label&#125;/&#123;application&#125;-&#123;profile&#125;.properties
</code></pre>
<p>其中的占位符表示如下</p>
<ul>
<li>application: 表示微服务名称，即配置的<code>spring.application.name</code></li>
<li>profile: 表示当前的环境，local、feature、dev、test、prod</li>
<li>label: 表示git仓库分支，feature、develop、test、master，当然默认的话是master</li>
</ul>
<h5 id="配置的继承与组合"><a href="#配置的继承与组合" class="headerlink" title="配置的继承与组合"></a>配置的继承与组合</h5><p>假设有一个应用：<code>config-client</code> ，其profile是dev，那么其实Spring Cloud Config会查找如下几个文件：</p>
<ul>
<li><code>config-client-dev.yml</code></li>
<li><code>config-client.yml</code></li>
<li><code>application-dev.yml</code></li>
<li><code>application.yml</code></li>
</ul>
<p>对于相同属性的配置，从上至下优先级逐渐递减；最终获得的配置属性是四个文件的组合。由此，不难分析，可如下规划几个配置文件：</p>
<ul>
<li><code>config-client-dev.yml</code> 作为指定应用在指定profile下的配置文件</li>
<li><code>config-client.yml</code> 作为制定应用在任何profile下都通用的配置文件</li>
<li><code>application-dev.yml</code> 作为所有应用在指定profile下的配置文件</li>
<li><code>application.yml</code> 作为所有应用在任何profile下都通用的配置文件</li>
</ul>
<pre><code class="yml"># config-client-dev.yml
mysql:
  username: eric-dev345
  password: 123-dev
  url: http://localhost:8090-dev</code></pre>
<pre><code class="yml">#config-client.yml
mysql:
  username: eric
  password: 123
  url: http://localhost:8090
  signature: &#39;fafafafa&#39;</code></pre>
<p>访问<code>http://localhost:8094/config-client-dev.yml</code>可以看到<code>config-client-dev.yml</code>并组合<code>config-client.yml</code></p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230404144705.png" alt="image-20230404144658518" loading="lazy"></p>
<h5 id="git仓库配置"><a href="#git仓库配置" class="headerlink" title="git仓库配置"></a>git仓库配置</h5><ul>
<li><p>占位符配置</p>
<pre><code class="yml">server:
  port: 8094
spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: file://F:\Java\Code\SpringCloud/&#123;application&#125; # 具体仓库地址</code></pre>
<p>如我们从<a href="http://localhost:8094/config-client/dev%E5%8E%BB%E8%8E%B7%E5%8F%96%E7%9A%84%E8%AF%9D%EF%BC%8C%E9%82%A3%E4%B9%88%E4%BC%9A%E5%B0%86application%E8%87%AA%E5%8A%A8%E5%8D%A0%E4%BD%8D%E4%B8%BAconfig-client%EF%BC%8C%E5%8D%B3%E5%8E%BB%60file://F:/Java/Code/SpringCloud/config-client%60%E8%BF%99%E4%B8%AA%E4%BB%93%E5%BA%93%E7%9A%84%E6%A0%B9%E7%9B%AE%E5%BD%95%E4%B8%8B%E6%89%BE%60config-client-dev.yml%60%E8%B5%84%E6%BA%90">http://localhost:8094/config-client/dev去获取的话，那么会将application自动占位为config-client，即去`file://F:\Java\Code\SpringCloud/config-client`这个仓库的根目录下找`config-client-dev.yml`资源</a></p>
</li>
<li><p>模式匹配</p>
<pre><code class="yml">server:
  port: 8094
spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: file://F:\Java\Code\SpringCloud/config-repo # 具体仓库地址
          repos:
            config-client:
              pattern: config-client/*
              uri: file://F:\Java\Code\SpringCloud/config-client
</code></pre>
<p> 模式匹配指的是带有通配符的{application}/{profile}名称的列表。比如config-client仓库，它只匹配<a href="http://localhost:8094/config-client/*%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E3%80%82">http://localhost:8094/config-client/*的应用程序配置文件。</a></p>
<p>如果不匹配任何模式，则使用<code>spring.cloud.config.server.git.uri</code>定义的URL</p>
</li>
<li><p>搜索目录</p>
<pre><code class="yml">server:
  port: 8094
spring:
  application:
    name: config-server
  cloud:
    config:
      server:
        git:
          uri: file://F:\Java\Code\SpringCloud/config-repo # 具体仓库地址
          search-path: config-client, foo*</code></pre>
<p>Config Server就会在Git仓库根目录、config-client子目录、以及所有以foo开始的子目录中查找配置文件。</p>
</li>
</ul>
<h5 id="配置属性加密"><a href="#配置属性加密" class="headerlink" title="配置属性加密"></a>配置属性加密</h5><p>对于配置文件中账户密码一般都需要加密存储，config server为配置内容提供了加解密支持</p>
<p><strong>安装JCE</strong></p>
<p>Java 8 JCE的地址：<a href="http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html">http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html</a> 。</p>
<p><strong>加解密端点</strong></p>
<ul>
<li>加密：<code>curl $CONFIG_URL/encrypt -d 想要加密的内容</code></li>
<li>解密：<code>curl $CONFIG_URL/decrypt -d 想要解密的密文</code></li>
</ul>
<p><strong>配置</strong></p>
<p>在config server的<code>bootstrap.yml</code>中添加加密配置</p>
<ul>
<li><p>对称加密</p>
<pre><code class="yml">encrypt:
  key: foo  # 设置对称密钥</code></pre>
<p>启动后输入命令</p>
<pre><code class="bash">curl http://localhost:8094/encrypt -d mysecret</code></pre>
<p>返回<code>7c5fab34141a8b743242f176cf913d56656e99e49db4065f6d2d7534b5a99307</code>加密串</p>
<pre><code class="bash">curl http://localhost:8094/decrypt -d 7c5fab34141a8b743242f176cf913d56656e99e49db4065f6d2d7534b5a99307</code></pre>
<p>返回<code>mysecret</code> ，说明能够正常解密</p>
</li>
</ul>
<h4 id="config-client"><a href="#config-client" class="headerlink" title="config client"></a>config client</h4><h5 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h5><ol>
<li><p>加依赖</p>
<pre><code class="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
  &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</li>
<li><p>加配置</p>
<pre><code class="yml"># application.yml
server:
  port: 8095</code></pre>
<pre><code class="yml"># bootstrap.yml
spring:
  application:
    name: config-client    # 对应config server所获取的配置文件的&#123;application&#125;
  cloud:
    config:
      uri: http://localhost:8094/
      profile: dev            # profile对应config server所获取的配置文件中的&#123;profile&#125; 
      label: master           # 指定Git仓库的分支，对应config server所获取的配置文件的&#123;label&#125;
</code></pre>
</li>
<li><p>测试</p>
<pre><code class="java">@RestController
@RequestMapping(&quot;/properties&quot;)
public class PropertiesController &#123;
  @Value(&quot;$&#123;mysql.username&#125;&quot;)
  private String username;
  @GetMapping(&quot;/username&quot;)
  public String getUsername()&#123;
    return this.username;
  &#125;
  ...
 &#125;</code></pre>
<p>访问<code>http://localhost:8095/properties/username</code>可返回git仓库中的配置属性</p>
</li>
</ol>
<h5 id="配置动态刷新"><a href="#配置动态刷新" class="headerlink" title="配置动态刷新"></a>配置动态刷新</h5><ul>
<li><p>加依赖</p>
<pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre>
</li>
<li><p>配置暴露端点</p>
<pre><code class="yml">management:
  endpoints:
    web:
      exposure:
        include: refresh</code></pre>
</li>
<li><p>在待刷新属性所在类上添加<code>@RefreshScope</code></p>
<pre><code class="java">@RestController
@RefreshScope  //配置动态刷新
@RequestMapping(&quot;/properties&quot;)
public class PropertiesController &#123;
  @Value(&quot;$&#123;mysql.username&#125;&quot;)
  private String username;
    ...
&#125;</code></pre>
</li>
</ul>
<p>在修改username属性后，只需执行如下请求即可刷新该属性</p>
<pre><code class="bash">curl -X POST http://localhost:8095/actuator/refresh</code></pre>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
  </entry>
  <entry>
    <title>Eureka(Hoxton.SR8)</title>
    <url>/2023/03/29/spring/spring%20cloud/Eureka/</url>
    <content><![CDATA[<h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Eureka是Netflix开源的服务发现组件，本身是一个基于REST的服务，包含Server和Client两部分，Spring Cloud将它集成在子项目Spring Cloud Netflix中。</p>
<ul>
<li>Server：提供服务发现能力，各个微服务启动时，会向Eureka Server注册自己的信息（例如IP、端口、微服务名称等），Eureka Server会存储这些信息；</li>
<li>Client：用于简化与Eureka Server的交互，<strong>Eureka Client会缓存服务注册表中的信息</strong>，从而减轻Server的压力</li>
</ul>
<h4 id="交互方式"><a href="#交互方式" class="headerlink" title="交互方式"></a>交互方式</h4><ul>
<li><p>微服务启动后，会周期性（<strong>默认30秒</strong>）地向Eureka Server发送心跳以续约自己的“租期”；</p>
</li>
<li><p>如果Eureka Server在一定时间内没有接收到某个微服务实例的心跳，Eureka Server将会注销该实例（<strong>默认90秒</strong>）；</p>
</li>
<li><p>自我保护模式</p>
<p>默认情况下，如果90秒内没有接收到实例的心跳包，那么Server就会将实例移除。考虑如下情况：实例正常运行，但由于分区发生故障时，短时间内无法于Server通信，如果断然将实例移除，这种行为将是有害的。Eureka采用自我保护模式来解决此问题，从而使集群更加健壮的运行</p>
</li>
</ul>
<p><strong>开启配置</strong></p>
<p>配置<code>eureka.server.enable-self-preservation = true</code>开启</p>
<p><strong>激活条件</strong></p>
<p>在1分钟后<code>Renew(last min) &lt; Renew threshold</code></p>
<ul>
<li><code>Renews threshold</code>：<strong>Eureka Server 期望每分钟收到客户端实例续约的最小值</strong>。</li>
<li><code>Renews (last min)</code>：<strong>Eureka Server 最后 1 分钟收到客户端实例续约的总数</strong>。</li>
</ul>
<p>计算公式</p>
<pre><code>this.expectedNumberOfRenewsPerMin = count * expectedClientRenewalIntervalSeconds / 60;
this.numberOfRenewsPerMinThreshold = (int) (this.expectedNumberOfRenewsPerMin * serverConfig.getRenewalPercentThreshold());</code></pre>
<p><code>count</code>为注册的服务数量，<code>expectedClientRenewalIntervalSeconds</code>是心跳发送间隔，<code>serverConfig.getRenewalPercentThreshold()</code>默认是 0.85（可以通过<code>eureka.server.renewal-percent-threshold</code>配置。</p>
<p>例子：</p>
<p>假设<code>count = 10</code>， <code>expectedClientRenewalIntervalSeconds = 30s</code> ，则<code>Renews threshold = 10 * 2 * 0.85 = 17</code>，如果每分钟收到的实例续约值小于17，就会触发自我保护模式</p>
<h4 id="Eureka集群引入"><a href="#Eureka集群引入" class="headerlink" title="Eureka集群引入"></a>Eureka集群引入</h4><ol>
<li><p>加依赖</p>
<pre><code class="xml">   &lt;dependencies&gt;
       &lt;dependency&gt;
           &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
           &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
       &lt;/dependency&gt;
   &lt;/dependencies&gt;</code></pre>
</li>
<li><p>加注解</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaServer
public class EurekaServerApplication &#123;

   public static void main(String[] args) &#123;
       SpringApplication.run(EurekaServerApplication.class,args);
   &#125;
&#125;</code></pre>
</li>
<li><p>配置</p>
<p>```yml<br>spring:<br> application:<br>   name: microservice-discovery-eureka-ha<br>eureka:<br> client:<br>   registerWithEureka: true<br>   fetchRegistry: false<br>   serviceUrl:</p>
<pre><code> defaultZone: http://peer2:8086/eureka/,http://peer1:8085/eureka/</code></pre>
<p> server:<br>   enable-self-preservation: false #关闭自我保护<br>   eviction-interval-timer-in-ms: 1000</p>
<h1 id="renewal-threshold-update-interval-ms-2000"><a href="#renewal-threshold-update-interval-ms-2000" class="headerlink" title="renewal-threshold-update-interval-ms: 2000"></a>renewal-threshold-update-interval-ms: 2000</h1><p>   expected-client-renewal-interval-seconds: 15 #心跳间隔时间<br>   wait-time-in-ms-when-sync-empty: 60000 #自我保护触发后等待多长时间提示消息</p>
</li>
</ol>
<hr>
<p>  spring:<br>    profiles: peer1<br>  server:<br>    port: 8085<br>  eureka:<br>    instance:<br>      hostname: peer1</p>
<hr>
<p>  spring:<br>    profiles:  peer2<br>  server:<br>    port: 8086<br>  eureka:<br>    instance:<br>      hostname: peer2</p>
<pre><code>
`peer1,peer2`为主机名

#### Eureka客户端引入

1. 加依赖

```xml
    &lt;dependencies&gt;
           &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
            &lt;version&gt;2.2.5.RELEASE&lt;/version&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;</code></pre>
<ol start="2">
<li><p>加注解</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
public class ProviderApplication &#123;

   public static void main(String[] args) &#123;
       SpringApplication.run(ProviderApplication.class);
   &#125;
&#125;
</code></pre>
</li>
<li><p>添加配置</p>
<pre><code class="yml">eureka:
 client:
   service-url:
     defaultZone: http://peer1:8085/eureka/
   register-with-eureka: true</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
  </entry>
  <entry>
    <title>Feign(Hoxton.SR8)</title>
    <url>/2023/03/31/spring/spring%20cloud/Feign/</url>
    <content><![CDATA[<p>Feign是一个声明式的HTTP客户端，相比于RestTemplate，它更加容易维护及使用</p>
<h4 id="引入Feign"><a href="#引入Feign" class="headerlink" title="引入Feign"></a>引入Feign</h4><ol>
<li><p>加依赖</p>
<pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-openfeign&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre>
</li>
<li><p>加注解</p>
<pre><code class="java">@SpringBootApplication
@EnableFeignClients
public class FeignApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(FeignApplication.class);
    &#125;

&#125;</code></pre>
</li>
<li><p>配置</p>
<pre><code class="java">@FeignClient(name = &quot;provider-server&quot;)
public interface ProviderFeign &#123;

</code></pre>
</li>
</ol>
<pre><code>   @RequestMapping(method = RequestMethod.GET, value = &quot;/book/&#123;bookName&#125;&quot;)
   String getBook(@PathVariable(&quot;bookName&quot;) String name);

   @RequestMapping(method = RequestMethod.POST, value = &quot;/book/&quot;, consumes = &quot;application/json&quot;)
   String addBook(@RequestBody String name);

   @RequestMapping(method = RequestMethod.DELETE, value = &quot;/book/&#123;bookName&#125;&quot;)
   String deleteBook(@PathVariable(&quot;bookName&quot;) String name);

   @RequestMapping(method = RequestMethod.GET, value = &quot;/book/list&#125;&quot;)
   Set&lt;String&gt; bookList();</code></pre>
<p>   }</p>
<pre><code>
`@FeignClient`声明这是一个Feign客户端，主要配置参数有

- name：表示服务的实例名称
- configuration：客户端配置类，比如配置Client的Log级别
- fallback：接口调用时触发熔断或错误时的回退处理，此类必须要实现指定的Feign客户端接口

#### 参数构造

- `@PathVariable`表示参数应映射到url路径上

  ```java
@RequestMapping(method = RequestMethod.GET, value = &quot;/book/&#123;bookName&#125;&quot;)
   String getBook(@PathVariable(&quot;bookName&quot;) String name);</code></pre>
<ul>
<li><p><code>@RequestParam</code>表示参数应映射到url的查询参数上</p>
<pre><code class="java">@RequestLine(&quot;GET /users&quot;)
List&lt;User&gt; getUsersByName(@RequestParam(&quot;name&quot;) String name);</code></pre>
</li>
<li><p><code>@RequestBody</code>表示参数应放入请求体</p>
<pre><code class="java">@RequestLine(&quot;POST /users&quot;)
void createUser(@RequestBody User user);</code></pre>
</li>
<li><p><code>@HeaderMap</code>表示Map的head参数应映射到head上</p>
<pre><code class="java">@RequestLine(&quot;GET /users&quot;)
List&lt;User&gt; getUsers(@HeaderMap Map&lt;String, String&gt; headers);</code></pre>
</li>
<li><p><code>@QueryMap</code> 表示Map里面的参数映射到url的查询参数上</p>
<pre><code class="java">@RequestLine(&quot;GET /users&quot;)
List&lt;User&gt; getUsers(@QueryMap Map&lt;String, String&gt; params);</code></pre>
</li>
</ul>
<h4 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h4><ul>
<li><p>yml配置</p>
<p>通过<code>feign.client.config.feignName.属性</code>来对属性进行配置</p>
<pre><code class="yml">feign:
  client:
    config:
      provider-server:
          connectTimeout: 5000  # 相当于Request.Options
        readTimeout: 5000     # 相当于Request.Options
        # 配置Feign的日志级别，相当于代码配置方式中的Logger
        loggerLevel: full
        # Feign的错误解码器，相当于代码配置方式中的ErrorDecoder
        errorDecoder: com.example.SimpleErrorDecoder</code></pre>
<p>如果想配置通用属性，使用<code>feign.client.default-config.属性</code></p>
</li>
<li><p>代码配置</p>
<p>编写一个配置类，并将其配置为<code>@FeignClient</code>的<code>configuration</code>属性的值</p>
<pre><code class="java">@FeignClient(name = &quot;provider-server&quot;, configuration = ProviderFeignConfig.class)
public interface ProviderFeign &#123;

&#125;
class ProviderFeignConfig&#123;
    @Bean
    public Logger.Level  logger()&#123;
        return Logger.Level.FULL;
    &#125;
&#125;</code></pre>
<p>如果要配置通用属性，可以在配置类加上<code>@Configuraiton</code>，使得配置被Spring扫描到，为所有的Feign客户端共享。一般不建议这么做，容易成坑</p>
<p>可配置属性查看<a href="https://docs.spring.io/spring-cloud-openfeign/docs/2.2.5.RELEASE/reference/html/appendix.html">Page</a></p>
</li>
</ul>
<h5 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h5><p>feign可配置的日志级别如下</p>
<ul>
<li>NONE：【性能最佳，适用于生产】不记录任何日志信息，这是默认值。</li>
<li>BASIC：【适用于生产环境追踪问题】仅记录请求的方法，URL以及响应状态码和执行时间</li>
<li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li>
<li>FULL：【比较适用于开发及测试环境定位问题】记录所有请求和响应的明细，包括头信息、请求体、元数据。</li>
</ul>
<p>如何配置</p>
<ol>
<li><p>yml配置feign客户端日志为debug</p>
<pre><code class="yml">logging:
  level:
    com.eric.study.cloud.feign.api.ProviderFeign: debug</code></pre>
</li>
<li><p>配置Feign日志打印级别</p>
<pre><code class="java">@FeignClient(name = &quot;provider-server&quot;, configuration = ProviderFeignConfig.class)
public interface ProviderFeign &#123;

&#125;
class ProviderFeignConfig&#123;
    @Bean
    public Logger.Level  logger()&#123;
        return Logger.Level.FULL;
    &#125;
&#125;</code></pre>
</li>
</ol>
<h5 id="请求压缩"><a href="#请求压缩" class="headerlink" title="请求压缩"></a>请求压缩</h5><p>支持对请求和响应进行GZIP压缩</p>
<ol>
<li><p>压缩开启</p>
<pre><code class="properties">feign.compression.request.enabled=true
feign.compression.response.enabled=true</code></pre>
</li>
<li><p>对要压缩的数据类型及数据大小</p>
<pre><code class="properties">feign.compression.request.enabled=true
feign.compression.request.mime-types=text/xml,application/xml,application/json
feign.compression.request.min-request-size=2048</code></pre>
</li>
</ol>
<h4 id="hystrix配置"><a href="#hystrix配置" class="headerlink" title="hystrix配置"></a>hystrix配置</h4><p>feign已经整合了hystrix，可以通过配置<code>feign.hystrix.enable=true</code>开启，然后</p>
<ol>
<li><p>定义一个实现feign client的类</p>
<pre><code class="java">@Component
public class ProviderFallBack implements ProviderFeign &#123;

</code></pre>
</li>
</ol>
<pre><code>   @Override
   public String getBook(String bookName) &#123;
       return &quot;sever bash&quot;;

   &#125;
   ....</code></pre>
<p>   }</p>
<pre><code>
2. 然后配置`@feignClient`属性`fallback`值

```java
@FeignClient(
    name = &quot;provider-server&quot;,fallback = ProviderFallBack.class)</code></pre>
<p>如果要获取造成fallback的异常，需要如下配置</p>
<ol>
<li><p>定义一个实现FallbackFactory的类</p>
<pre><code class="java">@Component
public class ProviderFeignFallbackFactory implements FallbackFactory&lt;ProviderFeign&gt; &#123;

  @Override
  public ProviderFeign create(Throwable cause) &#123;
    return new ProviderFeign() &#123;
      Logger logger = LoggerFactory.getLogger(ProviderFeign.class);
      @Override
      public String timeout(int sleepTime) &#123;
        logger.error(&quot;error info: &quot; + cause.getMessage());
        System.out.printf(&quot;server unavailable&quot;);
        return &quot;server unavailable&quot;;
      &#125;
    &#125;
  &#125;
&#125;</code></pre>
</li>
<li><p>然后配置<code>@feignClient</code>属性<code>fallbackFactory</code>值</p>
<pre><code class="java">@FeignClient(
    name = &quot;provider-server&quot;,
    configuration = ProviderFeignConfig.class,
    fallbackFactory = ProviderFeignFallbackFactory.class
)</code></pre>
</li>
</ol>
<h4 id="超时配置"><a href="#超时配置" class="headerlink" title="超时配置"></a>超时配置</h4><ul>
<li><p>全局配置</p>
<pre><code class="yml">#hystrix 配置
hystrix:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 6000 ##hystrix 超时配置 ms

#feign 配置
feign:
  hystrix:
    enabled: true  #开启hystrix熔断功能
  client:
   config:
     default:
       connectTimeout: 1000 #ribbon连接超时配置
       readTimeout: 1000 #ribbon响应超时配置

#配置ribbon重试
ribbon:
    MaxAutoRetries: 3
    MaxAutoRetriesNextServer: 0
    OkToRetryOnAllOperations: true</code></pre>
</li>
<li><p>指定配置</p>
<pre><code class="yml">hystrix:
  command:
      #指定某个方法的hystrix配置，格式如下
    &quot;ProviderFeign#timeout(int)&quot;:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 10000  
feign:
  hystrix:
    enabled: true  #开启hystrix熔断功能
  client:
    config:
      #指定客户端名配置
      bookServer: 
        connectTimeout: 1000
        readTimeout: 2000

#配置指定客户端名的ribbon
bookServer:
  ribbon:
    MaxAutoRetries: 3
    MaxAutoRetriesNextServer: 0
    OkToRetryOnAllOperations: true
</code></pre>
</li>
</ul>
<p>tips：</p>
<ul>
<li>hystrix配置的超时时间要比ribbon的（超时*重试次数）的总时间大，否则ribbon重试还没有走完hystrix就会触发超时异常了。</li>
<li>要启动ribbon的重试机制，要导入spring-retry依赖</li>
<li>如果要给每个客户端都分配不同的hystrix配置，参考issue：<a href="https://github.com/spring-cloud/spring-cloud-openfeign/issues/548">can’t set per client hystrix configuration #548</a></li>
</ul>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
  </entry>
  <entry>
    <title>Hystrix(Hoxton.SR8)</title>
    <url>/2023/04/02/spring/spring%20cloud/Hystrix/</url>
    <content><![CDATA[<p>在微服务中，服务间的调用关系非常复杂，如果某个服务不可用或存在高延迟，有可能会发生级联失败。比如A服务需要调用B服务，如果B服务不可用或存在高延迟，A对B的请求可能将会开始排队，这会导致A的资源耗尽，从而导致A也不可用</p>
<p>hystrix是由netflix开源的延迟和容错库，用于隔离访问远程系统/服务，防止出现级联失败，同时也提供了实时测量数据用于诊断问题</p>
<p>主要通过以下几点实现延迟和容错</p>
<ul>
<li><p>线程隔离</p>
<p>hystrix会为每个依赖服务分配一个很小的线程池，如果线程池已满，调用将被立即拒绝，默认不采用排队，从而加速失败判定</p>
</li>
<li><p>跳闸机制</p>
<p>当服务调用错误率超过一定阈值后，hystrix就会自动/手动跳闸，进入断开状态，停止请求服务一段时间</p>
</li>
<li><p>回退机制</p>
<p>当请求失败，超时，被拒绝或断路器打开时，hsytrix会执行回退逻辑</p>
</li>
<li><p>自我修复</p>
<p>断路器打开一段时间后，会自动进入半开状态，允许部分请求通过，如果服务可用就会回到闭合状态，否则又进入断开状态</p>
</li>
<li><p>监控</p>
<p>hystrix提供实时监控功能，可以监控运行指标及配置变化，帮助诊断问题</p>
</li>
</ul>
<h4 id="引入"><a href="#引入" class="headerlink" title="引入"></a>引入</h4><ol>
<li><p>引入依赖</p>
<pre><code class="yml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
        &lt;/dependency&gt;
</code></pre>
</li>
<li><p>开启hystrix</p>
<pre><code class="java">@EnableCircuitBreaker
@SpringBootApplication
public class HystrixApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(HystrixApplication.class);
    &#125;
&#125;</code></pre>
</li>
</ol>
<ol start="3">
<li><p>使用<code>@HystrixConmand</code>注解</p>
<pre><code class="java">    @HystrixCommand(fallbackMethod = &quot;errorFall&quot;)
    @GetMapping(&quot;/error&quot;)
    public String error() &#123;
        String errInfo = restTemplate.getForObject(&quot;http://localhost:8087/hystrix/error&quot;, String.class);
        System.out.printf(errInfo);
        return errInfo;
    &#125;
public String errorFall()&#123;
        return &quot;error fall back&quot;;
    &#125;</code></pre>
<p><code>errorFall</code>方法是回退处理逻辑，<strong>它的参数和返回值要和<code>@HystrixCommand</code>标注的方法一样</strong>，当请求服务不可用时就会返回回退逻辑信息</p>
<p>也可以为一个类指定默认的回退处理逻辑，在类上加上注解<code>@DefaultProperties&quot;</code></p>
<pre><code class="java">@Controller
@RequestMapping(&quot;consumer/user&quot;)
@DefaultProperties(defaultFallback = &quot;fallBackMethod&quot;) // 指定一个类的默认回退逻辑
public class UserController &#123;
    @Autowired
    private RestTemplate restTemplate;

    @GetMapping
    @ResponseBody
    @HystrixCommand //标注加入断路器
    public String queryUserById(@RequestParam(&quot;id&quot;) Long id) &#123;
        String user = this.restTemplate.getForObject(&quot;http://service-provider/user/&quot; + id, String.class);
        return user;
    &#125;
&#125;</code></pre>
</li>
</ol>
<h4 id="属性配置"><a href="#属性配置" class="headerlink" title="属性配置"></a>属性配置</h4><ul>
<li><p>全局配置</p>
<p>使用<code>hystrix.command.default.属性</code>进行全局配置，比如超时配置如下</p>
<pre><code class="yml">hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 6000 # 设置hystrix的超时时间为6000ms</code></pre>
</li>
<li><p>按Command Key配置</p>
<p>使用<code>hystrix.command.comandKey.属性</code>配置单个熔断器属性</p>
<pre><code class="yml">hystrix:
  command:
    timeoutKey:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 1000 # 设置hystrix的超时时间为6000ms</code></pre>
<pre><code class="java">@HystrixCommand(fallbackMethod = &quot;errorFall1&quot;, commandKey = &quot;timeoutKey&quot;)
@GetMapping(&quot;/timeout/&#123;time&#125;&quot;)
public String timeout(@PathVariable(&quot;time&quot;) Integer time) &#123;
    String errInfo = restTemplate.getForObject(&quot;http://localhost:8087/hystrix/timeout/&quot; + time, String.class);
    return errInfo;
&#125;</code></pre>
</li>
</ul>
<h4 id="断路器机制"><a href="#断路器机制" class="headerlink" title="断路器机制"></a>断路器机制</h4><p><img src="https://raw.githubusercontent.com/soda1/img/main/20230403131243.png" loading="lazy"></p>
<p>断路器有三个状态</p>
<ol>
<li>Closed：关闭状态，所有请求正常访问</li>
<li>Open：打开状态，所有请求进行降级处理。hystrix会对请求情况计数，当一定时间内失败请求百分比达到阈值，就会触发熔断，断路器处于打开状态。默认在10s内如果请求数大于等于20次时，有50%的失败请求就会触发熔断</li>
<li>Half Open：半开状态，当断路器处于Open状态时，会进入一段休眠时间（默认5s），随后断路器会自动进入半开状态，部分请求会被通过，如果这些请求都成功了，那么就会闭合断路器，否则会回到断开状态，再次进行休眠</li>
</ol>
<h4 id="hystrix状态查看"><a href="#hystrix状态查看" class="headerlink" title="hystrix状态查看"></a>hystrix状态查看</h4><p>Hystrix可以通过<a href="http://localhost:port/actuator/health来查看状态">http://localhost:port/actuator/health来查看状态</a></p>
<ol>
<li><p>加actuator依赖</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</li>
<li><p>配置组件细节展示</p>
<pre><code class="yml">management:
  endpoint:
    health:
      show-details: always
      show-components: always</code></pre>
</li>
<li><p>查看状态</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210318155023.png" alt="image-20210318155023139" loading="lazy"></p>
</li>
</ol>
<center> 熔断状态<center>

<h4 id="hystrix-dashboard"><a href="#hystrix-dashboard" class="headerlink" title="hystrix dashboard"></a>hystrix dashboard</h4><p>它的作用是将监控数据图表化</p>
<p><strong>使用</strong></p>
<ol>
<li><p>加依赖</p>
<pre><code class="yml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix-dashboard&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</li>
<li><p>加注解</p>
<pre><code class="java">@EnableHystrixDashboard
@SpringBootApplication
public class HystrixDashBoardApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(HystrixDashBoardApplication.class);
    &#125;

&#125;</code></pre>
</li>
<li><p>配置端口</p>
<pre><code class="yml">server:
  port: 8092</code></pre>
</li>
</ol>
<p>启动后在浏览器输入<a href="http://localhost:8092/hystrix/%E5%B0%B1%E5%8F%AF%E4%BB%A5%E7%9C%8B%E5%88%B0%E7%9B%91%E6%8E%A7%E9%A1%B5%E9%9D%A2%E4%BA%86">http://localhost:8092/hystrix/就可以看到监控页面了</a></p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230403153209.png" loading="lazy"></p>
<ol start="4">
<li><p>在要监控的应用加入<code>spring-boot-starter-actuator</code>依赖，然后配置暴露actuator/hystrix.stream路径</p>
<pre><code class="yml">#配置组件暴露细节
management:
  endpoint:
    health:
      show-details: always
      show-components: always
  #暴露actuator/hystrix.stream路径
  endpoints:
    web:
      exposure:
        include: &#39;hystrix.stream&#39;</code></pre>
</li>
<li><p>将<code>http://ip:port/actuator/hystrix.stream</code>在页面输入后并起好标题点击Monitor Stream后即可看到如下监控页面</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230403153929.png" alt="image-20230403153929901" loading="lazy"></p>
</li>
</ol>
]]></content>
  </entry>
  <entry>
    <title>Ribbon(Hoxton.SR8)</title>
    <url>/2023/03/31/spring/spring%20cloud/Ribbon/</url>
    <content><![CDATA[<p>多个相同的微服务实例，当被调用时，如何做到负载均衡呢？Spring Cloud 集成了ribbon，它是一个在客户端侧的负载均衡组件。由Netflix发布。</p>
<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4><p>客户端负载均衡器的实现原理是通过注册中心，如 Eureka，将可用的服务列表拉取到本地（客户端），再通过客户端负载均衡器（设置的负载均衡策略）获取到某个服务器的具体 ip 和端口，然后再通过 Http 框架请求服务并得到结果，其执行流程如下图所示：</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230331123612.png" loading="lazy"></p>
<h4 id="引入Ribbon"><a href="#引入Ribbon" class="headerlink" title="引入Ribbon"></a>引入Ribbon</h4><ol>
<li><p>加入依赖</p>
<p>依赖<code>spring-cloud-starter-netflix-eureka-client</code>即可，它已经包含了<code>spring-cloud-starter-netfilx-ribbon</code></p>
</li>
<li><p>配置</p>
<pre><code class="java">   @Bean
   @LoadBalanced
   public RestTemplate getRestTemplate() &#123;
       return new RestTemplate();
   &#125;</code></pre>
<p>加入<code>@LoadBalanced</code>注解</p>
</li>
<li><p>调用</p>
<pre><code class="java">   @GetMapping(&quot;/admin/&quot;)
   public String loadedBalance() &#123;
       String forObject = restTemplate.getForObject(&quot;http://provider-server/admin/&quot;, String.class);
       return forObject;

   &#125;</code></pre>
</li>
</ol>
<h4 id="内置负载均衡"><a href="#内置负载均衡" class="headerlink" title="内置负载均衡"></a>内置负载均衡</h4><ul>
<li><p><code>RoundRobinRule</code> </p>
<p>轮询策略轮 轮询index，选择index对应位置的Server。它经常被用作默认策略或更高级策略的后备策略</p>
</li>
<li><p><code>WeightedResponseTimeRule</code></p>
<p>根据平均响应时间分配一个 Weight（权重），响应时间越长，Weight 越小。该策略会依靠权重来随机对实例进行选择，权重越低，被选择的可能性越小</p>
</li>
<li><p><code>RandomRule</code></p>
<p>随机策略，随机选择一个实例</p>
</li>
<li><p><code>BestAvailableRule</code></p>
<p>选择一个最小的并发请求的Server，逐个考察Server，如果Server被tripped了，则跳过</p>
</li>
<li><p><code>RetryRule</code></p>
<p>对选定的负载均衡策略提供重试机制</p>
</li>
<li><p><code>AvailabilityFilteringRule</code></p>
<p>过滤一直连接失败的被标记为circuit tripped的服务实例，并过滤掉那些高并发的服务实例</p>
</li>
<li><p><code>ZoneAvoidanceRule</code></p>
<p>基于zone和available来过滤实例，通过组合<code>ZoneAvoidancePredicate</code>和<code>AvailabilityPredicate</code>，过滤掉连接失败的和连接数过多的实例，同时也会过滤不符合zone要求的节点</p>
<pre><code class="java"> public ZoneAvoidanceRule() &#123;
        super();
        ZoneAvoidancePredicate zonePredicate = new ZoneAvoidancePredicate(this);
        AvailabilityPredicate availabilityPredicate = new AvailabilityPredicate(this);
        compositePredicate = createCompositePredicate(zonePredicate, availabilityPredicate);
    &#125;</code></pre>
</li>
</ul>
<h4 id="配置负载均衡策略"><a href="#配置负载均衡策略" class="headerlink" title="配置负载均衡策略"></a>配置负载均衡策略</h4><ol>
<li><p>按实例配置</p>
<p><code>&lt;clientName&gt;.ribbon.</code> 如下属性</p>
<ul>
<li><code>NFLoadBalancerClassName</code>: should implement <code>ILoadBalancer</code></li>
<li><code>NFLoadBalancerRuleClassName</code>: should implement <code>IRule</code></li>
<li><code>NFLoadBalancerPingClassName</code>: should implement <code>IPing</code></li>
<li><code>NIWSServerListClassName</code>: should implement <code>ServerList</code></li>
<li><code>NIWSServerListFilterClassName</code> should implement <code>ServerListFilter</code></li>
</ul>
<pre><code class="yaml">provider-server:
  ribbon:
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule</code></pre>
</li>
<li><p>全局配置</p>
<pre><code class="java">@RibbonClients(defaultConfiguration = DefaultRibbonConfig.class)
public class RibbonClientDefaultConfigurationTestsConfig &#123;

&#125;

@Configuration
class DefaultRibbonConfig &#123;
  @Bean
  public IRule ribbonRule() &#123;
    return new RandomRule();
  &#125;
&#125;</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
  </entry>
  <entry>
    <title>Zuul(Hoxton.SR8)</title>
    <url>/2023/04/03/spring/spring%20cloud/Zuul/</url>
    <content><![CDATA[<p>当外部完成一个功能时，可能需要调用多个微服务接口，存在以下问题</p>
<ul>
<li>鉴权问题，每一个服务都要实现鉴权逻辑或调用鉴权服务</li>
<li>客户端需要请求不同的微服务，增加了复杂性</li>
<li>存在跨域请求</li>
</ul>
<p>服务网关可以解决上述问题，通过服务网关统一向外系统提供REST API的过程中，除了具备<code>服务路由</code>、<code>均衡负载</code>功能之外，它还具备了<code>权限控制</code>等功能。</p>
<h4 id="Zuul简介"><a href="#Zuul简介" class="headerlink" title="Zuul简介"></a>Zuul简介</h4><p>Zuul是Netflix开源的微服务网关，它可以和Eureka、Ribbon、Hystrix等组件配合使用。Zuul的核心是一系列的过滤器，这些过滤器帮助我们完成以下功能：</p>
<ul>
<li>身份认证与安全：识别每个资源的验证要求，并拒绝那些与要求不符的请求；</li>
<li>审查与监控：在边缘位置追踪有意义的数据和统计结果，从而为我们带来精确的生产视图；</li>
<li>动态路由：动态地将请求路由到不同的后端集群；</li>
<li>压力测试：逐渐增加指向集群的流量，以了解性能；</li>
<li>负载分配：为每一种负载类型分配对应容量，并弃用超出限定值的请求；</li>
<li>静态响应处理：在边缘位置直接建立部分响应，从而避免其转发到内部集群；</li>
<li>多区域弹性：跨越AWS Region进行请求路由，旨在实现ELB（Elastic Load Balancing）使用的多样化；以及让系统的边缘更贴近系统的使用者。</li>
</ul>
<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><ol>
<li><p>加依赖</p>
<pre><code class="xml">&lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-zuul&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre>
</li>
<li><p>加注解</p>
<pre><code class="java">@SpringBootApplication
@EnableZuulProxy
public class ZuulApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(ZuulApplication.class);
    &#125;

&#125;</code></pre>
</li>
<li><p>配置</p>
<pre><code class="yml">zuul:
  routes:
    provider:
      path: /provider-server/** # **：表示可以匹配多层路径 *：表示只能匹配一层
      url: http://localhost:8087</code></pre>
<p>测试</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20230403200851.png" alt="image-20230403200851299" loading="lazy"></p>
</li>
</ol>
<h4 id="搭配服务发现组件"><a href="#搭配服务发现组件" class="headerlink" title="搭配服务发现组件"></a>搭配服务发现组件</h4><ol>
<li><p>引入eureka</p>
<pre><code class="xml"> &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre>
</li>
<li><p>开启Eureka发现功能</p>
<pre><code class="java">@SpringBootApplication
@EnableEurekaClient
@EnableZuulProxy
public class ZuulApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(ZuulApplication.class);
    &#125;

&#125;</code></pre>
</li>
<li><p>配置Eureka及修改路由</p>
<pre><code class="yml">zuul:
  routes:
    provider:
      path: /provider-server/**
      service-id: provider-server
eureka:
  client:
    service-url:
      defaultZone: http://peer1:8085/eureka/,http://peer2:8086/eureka/
    register-with-eureka: true
    instance:
      lease-renewal-interval-in-seconds: 30
</code></pre>
<p>路由可以简化如下</p>
<pre><code class="yml">zuul:
  routes:
    service-provider: /service-provider/** # 这里是映射路径</code></pre>
</li>
</ol>
<h4 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h4><ul>
<li><p><code>zuul.prefix</code>：配置url前缀</p>
<pre><code class="yml">zuul:
  prefix: /api
  routes:
    service-provider: /service-provider/**</code></pre>
<p>访问<code>/api/service-provider/book/list</code>会被转发到<code>/service-provider/book/list</code></p>
</li>
<li><p><code>zuul.ignored-services</code>：忽略要代理的服务，多个用,隔开。*表示忽略所有，除了routes下的配置</p>
<pre><code class="yml">zuul:
  ignored-services: &#39;*&#39;   # 使用&#39;*&#39;可忽略所有微服务
  routes:
    provider-server: /service-provider/**
#只代理provider-server</code></pre>
<pre><code class="yml">zuul:
  ignored-services: provider-server</code></pre>
<p>忽略provider-server</p>
</li>
</ul>
<h4 id="过滤器ZuulFilter"><a href="#过滤器ZuulFilter" class="headerlink" title="过滤器ZuulFilter"></a>过滤器ZuulFilter</h4><p>ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：</p>
<pre><code class="java">public abstract ZuulFilter implements IZuulFilter&#123;

    abstract public String filterType();

    abstract public int filterOrder();

    boolean shouldFilter();// 来自IZuulFilter

    Object run() throws ZuulException;// IZuulFilter
&#125;</code></pre>
<ul>
<li><code>shouldFilter</code>：返回一个<code>Boolean</code>值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</li>
<li><code>run</code>：过滤器的具体业务逻辑。</li>
<li><code>filterType</code>：返回字符串，代表过滤器的类型。包含以下4种：<ul>
<li><code>pre</code>：请求在被路由之前执行</li>
<li><code>route</code>：在路由请求时调用</li>
<li><code>post</code>：在route和errror过滤器之后调用</li>
<li><code>error</code>：处理请求时发生错误调用</li>
</ul>
</li>
<li><code>filterOrder</code>：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</li>
</ul>
<h5 id="过滤器执行生命周期"><a href="#过滤器执行生命周期" class="headerlink" title="过滤器执行生命周期"></a>过滤器执行生命周期</h5><p>这张是Zuul官网提供的请求生命周期图，清晰的表现了一个请求在各个过滤器的执行顺序。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210317104851.png" alt="1543054221479" loading="lazy"></p>
<p>正常流程：</p>
<ul>
<li>请求到达首先会经过pre类型过滤器，而后到达route类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。</li>
</ul>
<p>异常流程：</p>
<ul>
<li>整个过程中，pre或者route过滤器出现异常，都会直接进入error过滤器，在error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</li>
<li>如果是error过滤器自己出现异常，最终也会进入POST过滤器，将最终结果返回给请求客户端。</li>
<li>如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和route不同的是，请求不会再到达POST过滤器了。</li>
</ul>
<h5 id="自定义过滤器"><a href="#自定义过滤器" class="headerlink" title="自定义过滤器"></a>自定义过滤器</h5><p>定义一个验证过滤器，如果请求中有access-token参数，则认为请求有效，放行。</p>
<pre><code class="java">@Component
public class LoginFilter extends ZuulFilter &#123;
    /**
     * 过滤器类型，前置过滤器
     * @return
     */
    @Override
    public String filterType() &#123;
        return &quot;pre&quot;;
    &#125;

    /**
     * 过滤器的执行顺序
     * @return
     */
    @Override
    public int filterOrder() &#123;
        return 1;
    &#125;

    /**
     * 该过滤器是否生效
     * @return
     */
    @Override
    public boolean shouldFilter() &#123;
        return true;
    &#125;

    /**
     * 登陆校验逻辑
     * @return
     * @throws ZuulException
     */
    @Override
    public Object run() throws ZuulException &#123;
        // 获取zuul提供的上下文对象
        RequestContext context = RequestContext.getCurrentContext();
        // 从上下文对象中获取请求对象
        HttpServletRequest request = context.getRequest();
        // 获取token信息
        String token = request.getParameter(&quot;access-token&quot;);
        // 判断
        if (StringUtils.isBlank(token)) &#123;
           //过滤请求,设置为false表示请求不会进入后台路由，但是还是会走其他的filter
            context.setSendZuulResponse(false);
            // 设置响应状态码，401
            context.setResponseStatusCode(HttpStatus.SC_UNAUTHORIZED);
            // 设置响应内容，会覆盖后台路由传出来的内容
            context.setResponseBody(&quot;&#123;\&quot;status\&quot;:\&quot;401\&quot;, \&quot;text\&quot;:\&quot;request error!\&quot;&#125;&quot;);
        &#125;
        // 校验通过，把登陆信息放入上下文信息，继续向后执行
        context.set(&quot;token&quot;, token);
        return null;
    &#125;
&#125;</code></pre>
<h4 id="负载均衡和熔断"><a href="#负载均衡和熔断" class="headerlink" title="负载均衡和熔断"></a>负载均衡和熔断</h4><p>Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：</p>
<pre><code class="yaml">hystrix:
  command:
    default:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000 # 设置hystrix的超时时间为6000ms</code></pre>
<p>指定服务超时</p>
<pre><code class="yml">hystrix:
  command:
    &lt;server-name&gt;:
      execution:
        isolation:
          thread:
            timeoutInMilliseconds: 2000 # 设置hystrix的超时时间为6000ms</code></pre>
<h4 id="Zuul超时"><a href="#Zuul超时" class="headerlink" title="Zuul超时"></a>Zuul超时</h4><p>由于Zuul是集成Ribbon和Hystrix的，在使用Zuul时可以配置Hystrix和Ribbon的参数来调整路由各种超时时间等配置。</p>
<ul>
<li><p>url方式去配置路由</p>
<pre><code class="yml">#使用zuul超时设置配置套接字超时和读取超时
zuul:
    host:
        connect-timeout-millis：1000
        socket-timeout-millis：1000</code></pre>
</li>
<li><p>serviceId方式配置路由</p>
<pre><code class="yml">#全局配置套接字超时和读取超时
ribbon:
    ReadTimeout: 1000 #该参数用来设置路由转发请求的超时时间
    ConnectTimeout: 1000 #该参数用来设置路由转发请求的时候，创建请求连接超时时间
#配置指定服务的超时时间
&lt;client&gt;:
    ribbon:
        ReadTimeout: 1000 #该参数用来设置路由转发请求的超时时间
        ConnectTimeout: 1000 #该参数用来设置路由转发请求的时候，创建请求连接超时时间
</code></pre>
</li>
</ul>
<h4 id="定义fallback"><a href="#定义fallback" class="headerlink" title="定义fallback"></a>定义fallback</h4><p>在zuul中，定义hystrix的fallback要实现FallbackProvider接口</p>
<pre><code class="java">@Component
public class ProviderFallBack implements FallbackProvider &#123;

    /**
     * 指定fallback 服务, 返回 */null 表示default fallback
     * @return
     */
    @Override
    public String getRoute() &#123;
        return &quot;*&quot;;
    &#125;

    /**
     * 实现fallback返回
     * @param route
     * @param cause
     * @return
     */
    @Override
    public ClientHttpResponse fallbackResponse(String route, Throwable cause) &#123;
        ClientHttpResponse fallback = fallback(HttpStatus.SERVICE_UNAVAILABLE, &quot;服务出错啦&quot;);
        return fallback;
    &#125;

    private ClientHttpResponse fallback(HttpStatus status,  String body) &#123;

       return new ClientHttpResponse()&#123;

           //除了close，其他方法都实现，否则可能报错
            @Override
            public HttpHeaders getHeaders() &#123;
                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                return headers;
            &#125;

           @Override
           public InputStream getBody() throws IOException &#123;;
               return new ByteArrayInputStream(body.getBytes(&quot;utf-8&quot;));
           &#125;

            @Override
            public HttpStatus getStatusCode() throws IOException &#123;
                return status;
            &#125;

            @Override
            public int getRawStatusCode() throws IOException &#123;
                return status.value();
            &#125;

            @Override
            public String getStatusText() throws IOException &#123;
                return status.getReasonPhrase();
            &#125;

            @Override
            public void close() &#123;

            &#125;
        &#125;;
    &#125;
&#125;</code></pre>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
  </entry>
  <entry>
    <title>开篇</title>
    <url>/2023/03/29/spring/spring%20cloud/%E5%BC%80%E7%AF%87/</url>
    <content><![CDATA[<h4 id="微服务概念"><a href="#微服务概念" class="headerlink" title="微服务概念"></a>微服务概念</h4><p>微服务是以业务为维度将单体应用拆分为多个应用，每个应用独立运行，它们之间通过HTTP或RPC进行通信。从而使得开发变得灵活</p>
<p>微服务的特点：</p>
<ul>
<li>单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责</li>
<li>微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</li>
<li>面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。</li>
<li>自治：自治是说服务间互相独立，互不干扰</li>
</ul>
<h4 id="Spring-Cloud"><a href="#Spring-Cloud" class="headerlink" title="Spring Cloud"></a>Spring Cloud</h4><p>Spring Cloud是基于Spring Boot实现的微服务开发工具集，它提供了包括服务发现、负载均衡、配置管理、断路器等功能。为微服务开发提供的整套解决方案</p>
<h5 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h5><p><img src="https://raw.githubusercontent.com/soda1/img/main/20230329180517.png" loading="lazy"></p>
<p>以<strong>伦敦的地铁名+  小版本</strong>的命名方式，RC（Release Candidate）表示接近准备发正式版的版本，SR（Service Release）表示主版本。Spring Cloud是一个综合项目，它包含很多的子项目，每个子项目下维护着自己的版本号，采用这种方式可以避免和子项目版本混淆</p>
<h5 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h5><ol>
<li><p><strong>对于懒人，可使用Spring Initilizr</strong>（IDEA、Spring Tool Suite等IDE上均有集成，也可在<a href="http://start.spring.io/">http://start.spring.io</a> 使用网页版）创建应用，它会给你生成项目的依赖以及项目的骨架。</p>
</li>
<li><p>创建Maven工程，在POM文件中使用如下配置</p>
<pre><code class="xml">&lt;properties&gt;
    &lt;spring.cloud-version&gt;Hoxton.SR8&lt;/spring.cloud-version&gt;
&lt;/properties&gt;
&lt;dependencyManagement&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
            &lt;version&gt;$&#123;spring.cloud-version&#125;&lt;/version&gt;
            &lt;type&gt;pom&lt;/type&gt;
            &lt;scope&gt;import&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/dependencyManagement&gt;</code></pre>
<p>至此可以可以使用你要使用的组件了，比如依赖Eureka</p>
<pre><code class="xml">&lt;dependencies&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>spring cloud</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot自动配置原理</title>
    <url>/2020/10/30/spring/spring-boot/2020-10-30-spring-boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-1/</url>
    <content><![CDATA[<p>基本SpringBoot主程序代码如下：</p>
<pre><code>@SpringBootApplication
public class HelloWorldMainApplication &#123;

    public static void main(String[] args) &#123;

        // Spring应用启动起来
        SpringApplication.run(HelloWorldMainApplication.class,args);
    &#125;
&#125;</code></pre>
<p>主程序中只有@<strong>SpringBootApplication</strong>一个注解，直接从此注解入手</p>
<h3 id="SpringBootApplication"><a href="#SpringBootApplication" class="headerlink" title="@SpringBootApplication"></a>@SpringBootApplication</h3><pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = &#123;
      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)
public @interface SpringBootApplication &#123;</code></pre>
<p>进入此注解类可以看到有三个比较重要的注解，一一来了解这三个注解分别起到了什么作用</p>
<pre><code class="java">@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
        @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;)</code></pre>
<h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>这个注解在Spring中我们是经常用到的，它默认扫描当前类下的包，用于扫描@Controller、@Service、@Component等注解。</p>
<h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@<strong>SpringBootConfiguration</strong></h4><p>标注在某个类上，表示这是一个Spring Boot的配置类；</p>
<pre><code>@Target(&#123;ElementType.TYPE&#125;)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Configuration
public @interface SpringBootConfiguration &#123;    </code></pre>
<p>进入此类可以看到有个@<strong>Configuration</strong>，此注解是用于配置类上的，表明这个类是一个配置类。</p>
<p>配置类也是容器中的一个组件；@Component</p>
<h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@<strong>EnableAutoConfiguration</strong></h4><p>@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能,帮我们配置需要配置的东西。</p>
<pre><code class="java">@AutoConfigurationPackage
@Import(EnableAutoConfigurationImportSelector.class) //导入资源
public @interface EnableAutoConfiguration &#123;</code></pre>
<p>进入此类可以看到有2个注解</p>
<ul>
<li><p>@<strong>AutoConfigurationPackage</strong>：</p>
<pre><code class="java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@Import(AutoConfigurationPackages.Registrar.class)
public @interface AutoConfigurationPackage &#123;

&#125;</code></pre>
<p>可以看到有个import注解，导入AutoConfigurationPackages.Registrar.class，进入Registrar可以看到有这个一个方法</p>
<pre><code class="java">        @Override
        public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123;
            register(registry, new PackageImport(metadata).getPackageName());
        &#125;</code></pre>
<p>设置断点后可以看到它也是扫描主配置类下的包，这和ComponentScan好像有点重叠了。SpringBoot给出的解释是</p>
<blockquote>
<p>it will be used when scanning for code @Entity classes.<br>It is generally recommended that you place EnableAutoConfiguration (if you’re<br>not using @SpringBootApplication) in a root package so that all sub-packages<br>and classes can be searched.</p>
</blockquote>
<p>因此可以得出这个是用来扫描@Entitiy注解的类。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201030141547014.png" alt="image-20201030141547014" loading="lazy"></p>
</li>
<li><p>@<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)</p>
<p><strong>EnableAutoConfigurationImportSelector</strong>的作用就是将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中</p>
<p>在SpringBoot 1.x版本中 是通过selectImports()来获取组件的全类名并返回</p>
<pre><code class="java">public String[] selectImports(AnnotationMetadata annotationMetadata) &#123;
        if (!this.isEnabled(annotationMetadata)) &#123;
            return NO_IMPORTS;
        &#125; else &#123;
            try &#123;
                AutoConfigurationMetadata autoConfigurationMetadata = AutoConfigurationMetadataLoader.loadMetadata(this.beanClassLoader);
                AnnotationAttributes attributes = this.getAttributes(annotationMetadata);
                List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);
                configurations = this.removeDuplicates(configurations);
                configurations = this.sort(configurations, autoConfigurationMetadata);
                Set&lt;String&gt; exclusions = this.getExclusions(annotationMetadata, attributes);
                this.checkExcludedClasses(configurations, exclusions);
                configurations.removeAll(exclusions);
                configurations = this.filter(configurations, autoConfigurationMetadata);
                this.fireAutoConfigurationImportEvents(configurations, exclusions);
                return (String[])configurations.toArray(new String[configurations.size()]);
            &#125; catch (IOException var6) &#123;
                throw new IllegalStateException(var6);
            &#125;
        &#125;
    &#125;</code></pre>
<p><code>List&lt;String&gt; configurations = this.getCandidateConfigurations(annotationMetadata, attributes);</code>这条语句就是获取组件的全类名</p>
<p>2.x版本对代码进行了重构，它是通过EnableAutoConfigurationImportSelector类下的静态类AutoConfigurationGroup的process来获取组件全类名的</p>
<pre><code class="java">public void process(AnnotationMetadata annotationMetadata, DeferredImportSelector deferredImportSelector) &#123;
   Assert.state(deferredImportSelector instanceof AutoConfigurationImportSelector,
         () -&gt; String.format(&quot;Only %s implementations are supported, got %s&quot;,
               AutoConfigurationImportSelector.class.getSimpleName(),
               deferredImportSelector.getClass().getName()));
   AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)
         .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata);
   this.autoConfigurationEntries.add(autoConfigurationEntry);
   for (String importClassName : autoConfigurationEntry.getConfigurations()) &#123;
      this.entries.putIfAbsent(importClassName, annotationMetadata);
   &#125;
&#125;</code></pre>
<p>`AutoConfigurationEntry autoConfigurationEntry = ((AutoConfigurationImportSelector) deferredImportSelector)</p>
<pre><code>     .getAutoConfigurationEntry(getAutoConfigurationMetadata(), annotationMetadata);`这条语句是用来获取全类名的</code></pre>
<pre><code class="java">protected AutoConfigurationEntry getAutoConfigurationEntry(AutoConfigurationMetadata autoConfigurationMetadata,
      AnnotationMetadata annotationMetadata) &#123;
   if (!isEnabled(annotationMetadata)) &#123;
      return EMPTY_ENTRY;
   &#125;
   AnnotationAttributes attributes = getAttributes(annotationMetadata);
   List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); //获取可能需要加载的组件全类名
   configurations = removeDuplicates(configurations);
   Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);
   checkExcludedClasses(configurations, exclusions);
   configurations.removeAll(exclusions);
   configurations = filter(configurations, autoConfigurationMetadata);//过滤得到需要加载的组件全类名
   fireAutoConfigurationImportEvents(configurations, exclusions);
   return new AutoConfigurationEntry(configurations, exclusions);
&#125;</code></pre>
<p>进入<code>getAutoConfigurationEntry()</code>方法后可以看得出来和selectImport代码是差不多，都是获取需要加载的组件全类名然后进行返回。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201031122305778.png" alt="image-20201031122305778" loading="lazy"></p>
<p><code>configurations </code>获取的元素都是以XXXAutoConfiguration形式的类名</p>
<p>进入<code> getCandidateConfigurations(annotationMetadata, attributes)</code>继续往下看它是如何找到组件的全类名的</p>
<pre><code class="java">protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123;
   List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(),
         getBeanClassLoader());
   Assert.notEmpty(configurations, &quot;No auto configuration classes found in META-INF/spring.factories. If you &quot;
         + &quot;are using a custom packaging, make sure that file is correct.&quot;);
   return configurations;
&#125;</code></pre>
<p>继续进入<code>loadFactoryNames()</code>方法</p>
<pre><code class="java">public static List&lt;String&gt; loadFactoryNames(Class&lt;?&gt; factoryClass, @Nullable ClassLoader classLoader) &#123;
    String factoryClassName = factoryClass.getName(); //org.springframework.boot.autoconfigure.EnableAutoConfiguration
    return (List)loadSpringFactories(classLoader).getOrDefault(factoryClassName, Collections.emptyList());
    //以List形式返回key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值
&#125;</code></pre>
<p>进入<code>loadSpringFactories(classLoader)</code></p>
<pre><code class="java">private static Map&lt;String, List&lt;String&gt;&gt; loadSpringFactories(@Nullable ClassLoader classLoader) &#123;
    MultiValueMap&lt;String, String&gt; result = (MultiValueMap)cache.get(classLoader);
    if (result != null) &#123;
        return result;
    &#125; else &#123;
        try &#123;
            Enumeration&lt;URL&gt; urls = classLoader != null ? classLoader.getResources(&quot;META-INF/spring.factories&quot;) : ClassLoader.getSystemResources(&quot;META-INF/spring.factories&quot;); 
            LinkedMultiValueMap result = new LinkedMultiValueMap();

            while(urls.hasMoreElements()) &#123;
                URL url = (URL)urls.nextElement();
                UrlResource resource = new UrlResource(url);
                Properties properties = PropertiesLoaderUtils.loadProperties(resource);
                Iterator var6 = properties.entrySet().iterator();

                while(var6.hasNext()) &#123;
                    Entry&lt;?, ?&gt; entry = (Entry)var6.next();
                    String factoryClassName = ((String)entry.getKey()).trim();
                    String[] var9 = StringUtils.commaDelimitedListToStringArray((String)entry.getValue());
                    int var10 = var9.length;

                    for(int var11 = 0; var11 &lt; var10; ++var11) &#123;
                        String factoryName = var9[var11];
                        result.add(factoryClassName, factoryName.trim());
                    &#125;
                &#125;
            &#125;

            cache.put(classLoader, result);
            return result;
        &#125; catch (IOException var13) &#123;
            throw new IllegalArgumentException(&quot;Unable to load factories from location [META-INF/spring.factories]&quot;, var13);
        &#125;
    &#125;</code></pre>
<ol>
<li><p><code>loadSpringFactories</code>通过<code>getResources</code>来扫描整个Java的类包、获取含有<strong>META-INF/spring.factories</strong>的jar路径</p>
<pre><code class="java">public Enumeration&lt;URL&gt; getResources(String name) throws IOException &#123;
    @SuppressWarnings(&quot;unchecked&quot;)
    Enumeration&lt;URL&gt;[] tmp = (Enumeration&lt;URL&gt;[]) new Enumeration&lt;?&gt;[2];su
    if (parent != null) &#123;
        tmp[0] = parent.getResources(name);  //搜索ExtendsionClassLoader加载的包
    &#125; else &#123;
        tmp[0] = getBootstrapResources(name); //搜索BootStrapClassLoader加载的包
    &#125;
    tmp[1] = findResources(name);          //搜索AppClassLoader加载的包

    return new CompoundEnumeration&lt;&gt;(tmp);
&#125;
/*
这个方法类似于双亲加载机制，先让父加载器去搜索包下的文件，但是它并不是说父加载器搜索到了文件子加载器就不搜索了
这个方法会搜索类加载器及其父类下的所有文件
*/</code></pre>
</li>
<li><p>以Properties的形式读取urls下<strong>spring.factories</strong>，然后转换成Map结构的数据</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201031142651690.png" alt="image-20201031142651690" loading="lazy"></p>
<center>spring.factories文件内容

</li>
</ol>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>由此可以知道大致流程就是：SpringBoot是通过<code>SpringFactoriesLoader.loadFactoryNames()</code>读取所有类包的META-INF/spring.factories文件，然后以List的形式返回key为org.springframework.boot.autoconfigure.EnableAutoConfiguration的值给<code>getAutoConfigurationEntry()</code>，最后过滤得到需要加载的组件全类名以Entry形式返回。</p>
<p>有了这些自动配置类组件后，我们才不用自己去手动编写配置</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>SpringBoot自动配置例子</title>
    <url>/2020/10/31/spring/spring-boot/2020-10-31-spring-boot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE-2/</url>
    <content><![CDATA[<h3 id="HttpEncodeAutoConfiguration"><a href="#HttpEncodeAutoConfiguration" class="headerlink" title="HttpEncodeAutoConfiguration"></a>HttpEncodeAutoConfiguration</h3><p>以<code>HttpEncodeAutoConfiguration</code>为例</p>
<pre><code>@Configuration
@EnableConfigurationProperties(HttpProperties.class)
@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)
@ConditionalOnClass(CharacterEncodingFilter.class)
@ConditionalOnProperty(prefix = &quot;spring.http.encoding&quot;, value = &quot;enabled&quot;, matchIfMissing = true)
public class HttpEncodingAutoConfiguration &#123;

   private final HttpProperties.Encoding properties;

   public HttpEncodingAutoConfiguration(HttpProperties properties) &#123;
      this.properties = properties.getEncoding();
   &#125;

   @Bean
   @ConditionalOnMissingBean
   public CharacterEncodingFilter characterEncodingFilter() &#123;
      CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
      filter.setEncoding(this.properties.getCharset().name());
      filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
      filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
      return filter;
   &#125;...</code></pre>
<p>一一解释注解</p>
<ul>
<li><p>@Configuration</p>
<p>声明该类是一个配置类</p>
</li>
<li><p>@EnableConfigurationProperties(HttpProperties.class)</p>
<blockquote>
<p>Enable support for <a href="https://docs.spring.io/spring-boot/docs/current/api/org/springframework/boot/context/properties/ConfigurationProperties.html"><code>@ConfigurationProperties</code></a> annotated beans. <code>@ConfigurationProperties</code> beans can be registered in the standard way (for example using <a href="https://docs.spring.io/spring-framework/docs/5.2.10.RELEASE/javadoc-api/org/springframework/context/annotation/Bean.html?is-external=true"><code>@Bean</code></a> methods) or, for convenience, can be specified directly on this annotation.</p>
</blockquote>
<p>从官方解释中可以知道此注解是用来支持<code>@ConfigurationProperties</code>注解bean的，因此唯一的构造方法会把这个bean给注入<code>HttpEncodingAutoConfiguration</code>中，因此可以在此类中使用<code>HttpProperties</code>对象的属性。</p>
<pre><code class="java">@ConfigurationProperties(prefix = &quot;spring.http&quot;)
public class HttpHProperties &#123;

   /**
    * Whether logging of (potentially sensitive) request details at DEBUG and TRACE level
    * is allowed.
    */
   private boolean logRequestDetails;

   /**
    * HTTP encoding properties.
    */
   private final Encoding encoding = new Encoding();

   public boolean isLogRequestDetails() &#123;
      return this.logRequestDetails;
   &#125;

   public void setLogRequestDetails(boolean logRequestDetails) &#123;
      this.logRequestDetails = logRequestDetails;
   &#125;</code></pre>
<p>在<code>HttpProperties</code>中使用<code>ConfigurationProperties</code>注解来声明此类是一个注解bean，通过set方法可以将yml配置中的以<code>spring.http</code>前缀开头的属性注入到对象中。</p>
</li>
<li><p>@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</p>
<p>声明该配置只有在是Web应用时才进行配置</p>
</li>
<li><p>@ConditionalOnClass(CharacterEncodingFilter.class)</p>
<p>声明该配置必须要在<code>CharacterEncodingFilter</code>存在的时候才进行配置</p>
</li>
<li><p>@ConditionalOnProperty(prefix = “spring.http.encoding”, value = “enabled”, matchIfMissing = true)</p>
<p>声明该配置需要有<code>spring.http.encoding</code>，且属性值为<code>enabled</code>，如果没有设置属性则默认为true</p>
</li>
</ul>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>每一个<code>XXXAutoConfiguration</code>类都需要在一定的条件才会进行配置，可能都会伴随一个<code>XXXProperties</code>的注解bean来配置属性，<code>XXXProperties</code>中被注入的属性可以在<code>application.yml</code>中配置。</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot自定义starter</title>
    <url>/2020/10/31/spring/spring-boot/2020-10-31-spring-boot%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    <content><![CDATA[<h3 id="自定义starter步骤"><a href="#自定义starter步骤" class="headerlink" title="自定义starter步骤"></a>自定义starter步骤</h3><ol>
<li><p>首先创建一个Maven用来写starter<img src="https://raw.githubusercontent.com/soda1/img/main/image-20201031181144000.png" alt="image-20201031181144000" loading="lazy"></p>
</li>
<li><p>添加<code>spring-boot-autoconfigure</code>依赖</p>
<pre><code>&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-autoconfigure&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</li>
<li><p>创建一个属性类，用于配置类中</p>
<pre><code class="java">@ConfigurationProperties(prefix = &quot;soda&quot;)
public class HelloProperties &#123;
    public final static String DEFAULT_NAME = &quot;Soda&quot;;
    public final static String WORD_TO_SAY = &quot;Hello&quot;;

    private String name = DEFAULT_NAME;
    private String say = WORD_TO_SAY;

    //set 方法
    ...
    ...
&#125;</code></pre>
</li>
<li><p>创建一个Service</p>
<pre><code class="java">public class HelloService &#123;

    private String name;

    private String say;

    public HelloService(String name, String say) &#123;
        this.name = name;
        this.say = say;
    &#125;

    public void sayHello() &#123;
        System.out.println(this.name + &quot; say: &quot; + this.say);
    &#125;

    public void eatApple() &#123;
        System.out.println(this.name + &quot;eating apple&quot;);
    &#125;

    public String playGame(String gameName) &#123;
        return this.name + &quot; play &quot; + gameName;
    &#125;

&#125;</code></pre>
</li>
<li><p>创建一个自动配置类</p>
<pre><code class="java">@Configuration
@EnableConfigurationProperties(HelloProperties.class)
public class HelloAutoConfiguration &#123;

    private final HelloProperties properties;

    public HelloAutoConfiguration(HelloProperties properties) &#123;
        this.properties = properties;
    &#125;

    @Bean
    @ConditionalOnClass(HelloService.class)
    public HelloService getHelloService() &#123;
        return new HelloService(properties.getName(), properties.getSay());
    &#125;

</code></pre>
</li>
</ol>
<p>   }</p>
<pre><code>
5. 在类包下创建一个`META-INF/spring.factories`, 这样才能被SpringBoot扫描到

```properties
org.springframework.boot.autoconfigure.EnableAutoConfiguration=\
com.soda.autoconfigure.HelloAutoConfiguration</code></pre>
<p>这样就可以自定义好一个starter了，程序在添加这个starter依赖后启动主程序就会自动的将一个<code>Service</code>实例添加到容器中。</p>
<h3 id="使用starter"><a href="#使用starter" class="headerlink" title="使用starter"></a>使用starter</h3><ol>
<li><p>创建一个maven并添加下面依赖</p>
<pre><code class="xml">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.soda&lt;/groupId&gt;
        &lt;artifactId&gt;com.soda.mystarter&lt;/artifactId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/dependency&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;</code></pre>
</li>
<li><p>创建application.properties</p>
<pre><code>server:
  port: 8081

soda:
  name: libin
  say: fuck</code></pre>
</li>
<li><p>创建主程序</p>
<pre><code class="java">@SpringBootApplication
public class MyStarterApplication &#123;

    public static void main(String[] args) &#123;

        SpringApplication.run(MyStarterApplication.class);
    &#125;
&#125;</code></pre>
</li>
<li><p>创建一个Controller</p>
<pre><code class="java">@RestController
public class HelloController &#123;

    @Autowired
    private HelloService helloService;

    @RequestMapping(&quot;/hello/game/&#123;do&#125;&quot;)
    public String doSomething(@PathVariable(&quot;do&quot;)String todo ) &#123;
        return helloService.playGame(todo);
    &#125;
&#125;</code></pre>
</li>
</ol>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring MVC原理</title>
    <url>/2020/11/03/spring/spring-boot/2020-11-3-spring-MVC%E5%8E%9F%E7%90%86/</url>
    <content><![CDATA[<h3 id="运行流程"><a href="#运行流程" class="headerlink" title="运行流程"></a>运行流程</h3><p>SpringMVC通过前端控制器<code>DispatchServlet</code>来接收请求，然后通过调用目标方法，返回一个<code>ModelAndView</code>给视图解析器进行渲染，最后返回给浏览器</p>
<img src="https://raw.githubusercontent.com/soda1/img/main/image-20201103150647095.png" alt="image-20201103152057120"  / loading="lazy">

<h4 id="1、Http请求"><a href="#1、Http请求" class="headerlink" title="1、Http请求"></a>1、Http请求</h4><p><code>DispatcherServlet</code>作为前端控制器，它是一个Servlet，拦截所有的请求。然后执行方法<code>doDispatch()</code></p>
<h4 id="2、寻找处理器："><a href="#2、寻找处理器：" class="headerlink" title="2、寻找处理器："></a>2、寻找处理器：</h4><p>请求进入<code>DispatcherServlet</code>控制器后，查询一个或多个<code>HandlerMapping</code>，找到对应的<code>handler</code>。</p>
<p> <code>handler</code>是一个可执行链，主要包括目标方法及拦截器</p>
<pre><code class="java">mappedHandler = getHandler(processedRequest);</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201103152057120.png" alt="image-20201103150647095" loading="lazy"></p>
<h4 id="3、获取处理器适配器（Controller"><a href="#3、获取处理器适配器（Controller" class="headerlink" title="3、获取处理器适配器（Controller)"></a>3、获取处理器适配器（Controller)</h4><p>通过<code>handler</code>来获取<code>handlerAdapter</code>（Controller)，用于执行目标方法</p>
<pre><code class="java">HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());</code></pre>
<h4 id="4、执行拦截器preHandler-方法"><a href="#4、执行拦截器preHandler-方法" class="headerlink" title="4、执行拦截器preHandler()方法"></a>4、执行拦截器preHandler()方法</h4><pre><code class="java">if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;
   return;
&#125;</code></pre>
<h4 id="5、执行目标方法"><a href="#5、执行目标方法" class="headerlink" title="5、执行目标方法"></a>5、执行目标方法</h4><p>执行目标方法后会得到一个<code>ModelAndView</code>对象，用于视图解析器</p>
<pre><code class="java">mv = ha.handle(processedRequest, response, mappedHandler.getHandler());</code></pre>
<h4 id="6、执行拦截器postHandler-方法"><a href="#6、执行拦截器postHandler-方法" class="headerlink" title="6、执行拦截器postHandler()方法"></a>6、执行拦截器postHandler()方法</h4><pre><code class="java"> mappedHandler.applyPostHandle(processedRequest, response, mv);    </code></pre>
<h4 id="7、使用视图解析器解析视图"><a href="#7、使用视图解析器解析视图" class="headerlink" title="7、使用视图解析器解析视图"></a>7、使用视图解析器解析视图</h4><p><code>DispatcherServlet</code>会遍历多个<code>ViewResolvers</code>来为<code>ModelAndView</code>找到合适的View</p>
<pre><code class="java">processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);</code></pre>
<pre><code class="java">@Nullable
protected View resolveViewName(String viewName, @Nullable Map&lt;String, Object&gt; model,
      Locale locale, HttpServletRequest request) throws Exception &#123;

   if (this.viewResolvers != null) &#123;
      for (ViewResolver viewResolver : this.viewResolvers) &#123;
         View view = viewResolver.resolveViewName(viewName, locale);
         if (view != null) &#123;
            return view;
         &#125;
      &#125;
   &#125;
   return null;
&#125;</code></pre>
<h4 id="8、渲染视图"><a href="#8、渲染视图" class="headerlink" title="8、渲染视图"></a>8、渲染视图</h4><pre><code class="java">protected void render(ModelAndView mv, HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
   // Determine locale for request and apply it to the response.
   Locale locale =
         (this.localeResolver != null ? this.localeResolver.resolveLocale(request) : request.getLocale());
   response.setLocale(locale);

   View view;
   String viewName = mv.getViewName();
   if (viewName != null) &#123;
      // We need to resolve the view name.
      view = resolveViewName(viewName, mv.getModelInternal(), locale, request); //从Resolvers获取合适的View
      if (view == null) &#123;
         throw new ServletException(&quot;Could not resolve view with name &#39;&quot; + mv.getViewName() +
               &quot;&#39; in servlet with name &#39;&quot; + getServletName() + &quot;&#39;&quot;);
      &#125;
 .....略</code></pre>
<h4 id="9、执行拦截器afterCompletion"><a href="#9、执行拦截器afterCompletion" class="headerlink" title="9、执行拦截器afterCompletion()"></a>9、执行拦截器afterCompletion()</h4><pre><code class="java">private void processDispatchResult(HttpServletRequest request, HttpServletResponse response,
      @Nullable HandlerExecutionChain mappedHandler, @Nullable ModelAndView mv,
      @Nullable Exception exception) throws Exception &#123;

   boolean errorView = false;

  .....略

   // Did the handler return a view to render?
   if (mv != null &amp;&amp; !mv.wasCleared()) &#123;
      render(mv, request, response);    //通过Resolvers选择合适的View进行视图渲染
      if (errorView) &#123;
         WebUtils.clearErrorRequestAttributes(request);
      &#125;
   &#125;
   else &#123;
      if (logger.isTraceEnabled()) &#123;
         logger.trace(&quot;No view rendering, null ModelAndView returned.&quot;);
      &#125;
   &#125;

   if (WebAsyncUtils.getAsyncManager(request).isConcurrentHandlingStarted()) &#123;
      // Concurrent handling started during a forward
      return;
   &#125;

   if (mappedHandler != null) &#123;
      mappedHandler.triggerAfterCompletion(request, response, null); //拦截器afterCompletion()
   &#125;
&#125;</code></pre>
<p><code>doDispatch()</code>方法</p>
<pre><code class="java">protected void doDispatch(HttpServletRequest request, HttpServletResponse response) throws Exception &#123;
   HttpServletRequest processedRequest = request;
   HandlerExecutionChain mappedHandler = null;
   boolean multipartRequestParsed = false;

   WebAsyncManager asyncManager = WebAsyncUtils.getAsyncManager(request);

   try &#123;
      ModelAndView mv = null;
      Exception dispatchException = null;

      try &#123;
         processedRequest = checkMultipart(request);
         multipartRequestParsed = (processedRequest != request);

         // Determine handler for the current request.
         mappedHandler = getHandler(processedRequest);
         if (mappedHandler == null) &#123;
            noHandlerFound(processedRequest, response);
            return;
         &#125;

         // Determine handler adapter for the current request.
         HandlerAdapter ha = getHandlerAdapter(mappedHandler.getHandler());

         // Process last-modified header, if supported by the handler.
         String method = request.getMethod();
         boolean isGet = &quot;GET&quot;.equals(method);
         if (isGet || &quot;HEAD&quot;.equals(method)) &#123;
            long lastModified = ha.getLastModified(request, mappedHandler.getHandler());
            if (new ServletWebRequest(request, response).checkNotModified(lastModified) &amp;&amp; isGet) &#123;
               return;
            &#125;
         &#125;

         if (!mappedHandler.applyPreHandle(processedRequest, response)) &#123;
            return;
         &#125;

         // Actually invoke the handler.
         mv = ha.handle(processedRequest, response, mappedHandler.getHandler());

         if (asyncManager.isConcurrentHandlingStarted()) &#123;
            return;
         &#125;

         applyDefaultViewName(processedRequest, mv);
         mappedHandler.applyPostHandle(processedRequest, response, mv);
      &#125;
      catch (Exception ex) &#123;
         dispatchException = ex;
      &#125;
      catch (Throwable err) &#123;
         // As of 4.3, we&#39;re processing Errors thrown from handler methods as well,
         // making them available for @ExceptionHandler methods and other scenarios.
         dispatchException = new NestedServletException(&quot;Handler dispatch failed&quot;, err);
      &#125;
      processDispatchResult(processedRequest, response, mappedHandler, mv, dispatchException);
   &#125;
   catch (Exception ex) &#123;
      triggerAfterCompletion(processedRequest, response, mappedHandler, ex);
   &#125;
   catch (Throwable err) &#123;
      triggerAfterCompletion(processedRequest, response, mappedHandler,
            new NestedServletException(&quot;Handler processing failed&quot;, err));
   &#125;
   finally &#123;
      if (asyncManager.isConcurrentHandlingStarted()) &#123;
         // Instead of postHandle and afterCompletion
         if (mappedHandler != null) &#123;
            mappedHandler.applyAfterConcurrentHandlingStarted(processedRequest, response);
         &#125;
      &#125;
      else &#123;
         // Clean up any resources used by a multipart request.
         if (multipartRequestParsed) &#123;
            cleanupMultipart(processedRequest);
         &#125;
      &#125;
   &#125;
&#125;</code></pre>
<h3 id="SpringMVC接口解释"><a href="#SpringMVC接口解释" class="headerlink" title="SpringMVC接口解释"></a>SpringMVC接口解释</h3><h4 id="DispatcherServlet接口"><a href="#DispatcherServlet接口" class="headerlink" title="DispatcherServlet接口"></a>DispatcherServlet接口</h4><p>Spring提供的前端控制器，所有的请求都有经过它来统一分发。在DispatcherServlet将请求分发给Spring Controller之前，需要借助于Spring提供的HandlerMapping定位到具体的Controller。</p>
<h4 id="HandlerMapping接口"><a href="#HandlerMapping接口" class="headerlink" title="HandlerMapping接口"></a>HandlerMapping接口</h4><p>能够完成客户请求到Controller映射。</p>
<h4 id="Controller接口"><a href="#Controller接口" class="headerlink" title="Controller接口"></a>Controller接口</h4><p>需要为并发用户处理上述请求，因此实现Controller接口时，必须保证线程安全并且可重用。<br>Controller将处理用户请求，这和Struts Action扮演的角色是一致的。一旦Controller处理完用户请求，则返回ModelAndView对象给DispatcherServlet前端控制器，ModelAndView中包含了模型（Model）和视图（View）。<br>从宏观角度考虑，DispatcherServlet是整个Web应用的控制器；从微观考虑，Controller是单个Http请求处理过程中的控制器，而ModelAndView是Http请求过程中返回的模型（Model）和视图（View）。</p>
<h4 id="ViewResolver接口"><a href="#ViewResolver接口" class="headerlink" title="ViewResolver接口"></a>ViewResolver接口</h4><p>Spring提供的视图解析器（ViewResolver）在Web应用中查找View对象，从而将相应结果渲染给客户。</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot配置Servlet容器</title>
    <url>/2020/11/03/spring/spring-boot/2020-11-3-spring-boot%E5%AE%9A%E5%88%B6%E5%8C%96%E5%AE%B9%E5%99%A8/</url>
    <content><![CDATA[<h3 id="配置嵌入式Servlet容器"><a href="#配置嵌入式Servlet容器" class="headerlink" title="配置嵌入式Servlet容器"></a>配置嵌入式Servlet容器</h3><p>SpringBoot默认使用Tomcat作为嵌入式的Servlet容器；</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180301142915.png" alt=" " loading="lazy"></p>
<h4 id="如何定制和修改Servlet容器的相关配置；"><a href="#如何定制和修改Servlet容器的相关配置；" class="headerlink" title="如何定制和修改Servlet容器的相关配置；"></a>如何定制和修改Servlet容器的相关配置；</h4><ol>
<li><p>修改和server有关的配置（ServerProperties【也是EmbeddedServletContainerCustomizer】）；</p>
<pre><code class="properties">server.port=8081
server.context-path=/crud

server.tomcat.uri-encoding=UTF-8

//通用的Servlet容器设置
server.xxx
//Tomcat的设置
server.tomcat.xxx</code></pre>
</li>
<li><p>编写一个<code>WebServerFactoryCustomizer</code>嵌入式的Servlet容器的定制器来修改Servlet容器的配置</p>
<pre><code class="java">    @Bean
    public WebServerFactoryCustomizer myWebServerFactoryCustomizer() &#123;
        return (WebServerFactoryCustomizer&lt;ConfigurableTomcatWebServerFactory&gt;) factory -&gt; factory.setPort(8083);
    &#125;</code></pre>
<p>这里有一个问题就是SpringBoot是怎么使用我定制化的Tomcat容器的，因为在<code>EmbeddedWebServerFactoryCustomizerAutoConfiguration</code>已经定义了一个了</p>
<pre><code class="java">@Bean
public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment,
      ServerProperties serverProperties) &#123;
   return new TomcatWebServerFactoryCustomizer(environment, serverProperties);
&#125;</code></pre>
</li>
</ol>
<h3 id="注册Servlet三大组件【Servlet、Filter、Listener】"><a href="#注册Servlet三大组件【Servlet、Filter、Listener】" class="headerlink" title="注册Servlet三大组件【Servlet、Filter、Listener】"></a>注册Servlet三大组件【Servlet、Filter、Listener】</h3><p>由于SpringBoot默认是以jar包的方式启动嵌入式的Servlet容器来启动SpringBoot的web应用，没有web.xml文件。</p>
<p>注册三大组件用以下方式</p>
<h4 id="ServletRegistrationBean"><a href="#ServletRegistrationBean" class="headerlink" title="ServletRegistrationBean"></a>ServletRegistrationBean</h4><pre><code class="java">//注册三大组件
@Bean
public ServletRegistrationBean myServlet()&#123;
    ServletRegistrationBean registrationBean = new ServletRegistrationBean(new MyServlet(),&quot;/myServlet&quot;);
    return registrationBean;
&#125;
</code></pre>
<h4 id="FilterRegistrationBean"><a href="#FilterRegistrationBean" class="headerlink" title="FilterRegistrationBean"></a>FilterRegistrationBean</h4><pre><code class="java">@Bean
public FilterRegistrationBean myFilter()&#123;
    FilterRegistrationBean registrationBean = new FilterRegistrationBean();
    registrationBean.setFilter(new MyFilter());
    registrationBean.setUrlPatterns(Arrays.asList(&quot;/hello&quot;,&quot;/myServlet&quot;));
    return registrationBean;
&#125;</code></pre>
<h4 id="ServletListenerRegistrationBean"><a href="#ServletListenerRegistrationBean" class="headerlink" title="ServletListenerRegistrationBean"></a>ServletListenerRegistrationBean</h4><pre><code class="java">@Bean
public ServletListenerRegistrationBean myListener()&#123;
    ServletListenerRegistrationBean&lt;MyListener&gt; registrationBean = new ServletListenerRegistrationBean&lt;&gt;(new MyListener());
    return registrationBean;
&#125;</code></pre>
<p>SpringBoot帮我们自动SpringMVC的时候，自动的注册SpringMVC的前端控制器；<code>DIspatcherServlet</code>；</p>
<p><code>DispatcherServletAutoConfiguration</code>中：</p>
<pre><code class="java">@Bean(name = DEFAULT_DISPATCHER_SERVLET_REGISTRATION_BEAN_NAME)
@ConditionalOnBean(value = DispatcherServlet.class, name = DEFAULT_DISPATCHER_SERVLET_BEAN_NAME)
public ServletRegistrationBean dispatcherServletRegistration(
      DispatcherServlet dispatcherServlet) &#123;
   ServletRegistrationBean registration = new ServletRegistrationBean(
         dispatcherServlet, this.serverProperties.getServletMapping());
    //默认拦截： /  所有请求；包静态资源，但是不拦截jsp请求；   /*会拦截jsp
    //可以通过server.servletPath来修改SpringMVC前端控制器默认拦截的请求路径

   registration.setName(DEFAULT_DISPATCHER_SERVLET_BEAN_NAME);
   registration.setLoadOnStartup(
         this.webMvcProperties.getServlet().getLoadOnStartup());
   if (this.multipartConfig != null) &#123;
      registration.setMultipartConfig(this.multipartConfig);
   &#125;
   return registration;
&#125;
</code></pre>
<h3 id="替换为其他嵌入式Servlet容器"><a href="#替换为其他嵌入式Servlet容器" class="headerlink" title="替换为其他嵌入式Servlet容器"></a>替换为其他嵌入式Servlet容器</h3><p><img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302144835.png" loading="lazy"></p>
<p>默认支持：</p>
<p>Tomcat（默认使用）</p>
<pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
   引入web模块默认就是使用嵌入式的Tomcat作为Servlet容器；
&lt;/dependency&gt;</code></pre>
<p>Jetty</p>
<pre><code class="xml">&lt;!-- 引入web模块 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;!--将内置Tomcat去掉--&gt;
   &lt;exclusions&gt;
      &lt;exclusion&gt;
         &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;
&lt;!--引入其他的Servlet容器--&gt;
&lt;dependency&gt;
   &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;/dependency&gt;</code></pre>
<p>Undertow</p>
<pre><code class="xml">&lt;!-- 引入web模块 --&gt;
&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;

   &lt;exclusions&gt;
      &lt;exclusion&gt;
         &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
         &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
      &lt;/exclusion&gt;
   &lt;/exclusions&gt;
&lt;/dependency&gt;

&lt;!--引入其他的Servlet容器--&gt;
&lt;dependency&gt;
   &lt;artifactId&gt;spring-boot-starter-undertow&lt;/artifactId&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
&lt;/dependency&gt;</code></pre>
<h3 id="嵌入式Servlet容器自动配置原理"><a href="#嵌入式Servlet容器自动配置原理" class="headerlink" title="嵌入式Servlet容器自动配置原理"></a>嵌入式Servlet容器自动配置原理</h3><p><code>EmbeddedWebServerFactoryCustomizerAutoConfiguration</code>：嵌入式的Servlet容器自动配置</p>
<pre><code class="java">@Configuration
@ConditionalOnWebApplication
@EnableConfigurationProperties(ServerProperties.class)
public class EmbeddedWebServerFactoryCustomizerAutoConfiguration &#123;

   /**
    * Nested configuration if Tomcat is being used.
    */
   @Configuration
   @ConditionalOnClass(&#123; Tomcat.class, UpgradeProtocol.class &#125;)
   public static class TomcatWebServerFactoryCustomizerConfiguration &#123;

      @Bean
      public TomcatWebServerFactoryCustomizer tomcatWebServerFactoryCustomizer(Environment environment,
            ServerProperties serverProperties) &#123;
         return new TomcatWebServerFactoryCustomizer(environment, serverProperties);
      &#125;

   &#125;

   /**
    * Nested configuration if Jetty is being used.
    */
   @Configuration
   @ConditionalOnClass(&#123; Server.class, Loader.class, WebAppContext.class &#125;)
   public static class JettyWebServerFactoryCustomizerConfiguration &#123;

      @Bean
      public JettyWebServerFactoryCustomizer jettyWebServerFactoryCustomizer(Environment environment,
            ServerProperties serverProperties) &#123;
         return new JettyWebServerFactoryCustomizer(environment, serverProperties);
      &#125;

   &#125;

   /**
    * Nested configuration if Undertow is being used.
    */
   @Configuration
   @ConditionalOnClass(&#123; Undertow.class, SslClientAuthMode.class &#125;)
   public static class UndertowWebServerFactoryCustomizerConfiguration &#123;

      @Bean
      public UndertowWebServerFactoryCustomizer undertowWebServerFactoryCustomizer(Environment environment,
            ServerProperties serverProperties) &#123;
         return new UndertowWebServerFactoryCustomizer(environment, serverProperties);
      &#125;

   &#125;

   /**
    * Nested configuration if Netty is being used.
    */
   @Configuration
   @ConditionalOnClass(HttpServer.class)
   public static class NettyWebServerFactoryCustomizerConfiguration &#123;

      @Bean
      public NettyWebServerFactoryCustomizer nettyWebServerFactoryCustomizer(Environment environment,
            ServerProperties serverProperties) &#123;
         return new NettyWebServerFactoryCustomizer(environment, serverProperties);
      &#125;

   &#125;

&#125;</code></pre>
<pre><code class="java">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)
@Configuration
@ConditionalOnWebApplication
@Import(BeanPostProcessorsRegistrar.class)
//导入BeanPostProcessorsRegistrar：Spring注解版；给容器中导入一些组件
//导入了EmbeddedServletContainerCustomizerBeanPostProcessor：
//后置处理器：bean初始化前后（创建完对象，还没赋值赋值）执行初始化工作
public class EmbeddedServletContainerAutoConfiguration &#123;

    @Configuration
    @ConditionalOnClass(&#123; Servlet.class, Tomcat.class &#125;)//判断当前是否引入了Tomcat依赖；
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)//判断当前容器没有用户自己定义EmbeddedServletContainerFactory：嵌入式的Servlet容器工厂；作用：创建嵌入式的Servlet容器
    public static class EmbeddedTomcat &#123;

        @Bean
        public TomcatEmbeddedServletContainerFactory tomcatEmbeddedServletContainerFactory() &#123;
            return new TomcatEmbeddedServletContainerFactory();
        &#125;

    &#125;

    /**
     * Nested configuration if Jetty is being used.
     */
    @Configuration
    @ConditionalOnClass(&#123; Servlet.class, Server.class, Loader.class,
            WebAppContext.class &#125;)
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
    public static class EmbeddedJetty &#123;

        @Bean
        public JettyEmbeddedServletContainerFactory jettyEmbeddedServletContainerFactory() &#123;
            return new JettyEmbeddedServletContainerFactory();
        &#125;

    &#125;

    /**
     * Nested configuration if Undertow is being used.
     */
    @Configuration
    @ConditionalOnClass(&#123; Servlet.class, Undertow.class, SslClientAuthMode.class &#125;)
    @ConditionalOnMissingBean(value = EmbeddedServletContainerFactory.class, search = SearchStrategy.CURRENT)
    public static class EmbeddedUndertow &#123;

        @Bean
        public UndertowEmbeddedServletContainerFactory undertowEmbeddedServletContainerFactory() &#123;
            return new UndertowEmbeddedServletContainerFactory();
        &#125;

    &#125;</code></pre>
<p>1）、EmbeddedServletContainerFactory（嵌入式Servlet容器工厂）</p>
<pre><code class="java">public interface EmbeddedServletContainerFactory &#123;

   //获取嵌入式的Servlet容器
   EmbeddedServletContainer getEmbeddedServletContainer(
         ServletContextInitializer... initializers);

&#125;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302114401.png" loading="lazy"></p>
<p>2）、EmbeddedServletContainer：（嵌入式的Servlet容器）</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302144910.png" loading="lazy"></p>
<p>3）、以<strong>TomcatEmbeddedServletContainerFactory</strong>为例</p>
<pre><code class="java">@Override
public EmbeddedServletContainer getEmbeddedServletContainer(
      ServletContextInitializer... initializers) &#123;
    //创建一个Tomcat
   Tomcat tomcat = new Tomcat();

    //配置Tomcat的基本环节
   File baseDir = (this.baseDirectory != null ? this.baseDirectory
         : createTempDir(&quot;tomcat&quot;));
   tomcat.setBaseDir(baseDir.getAbsolutePath());
   Connector connector = new Connector(this.protocol);
   tomcat.getService().addConnector(connector);
   customizeConnector(connector);
   tomcat.setConnector(connector);
   tomcat.getHost().setAutoDeploy(false);
   configureEngine(tomcat.getEngine());
   for (Connector additionalConnector : this.additionalTomcatConnectors) &#123;
      tomcat.getService().addConnector(additionalConnector);
   &#125;
   prepareContext(tomcat.getHost(), initializers);

    //将配置好的Tomcat传入进去，返回一个EmbeddedServletContainer；并且启动Tomcat服务器
   return getTomcatEmbeddedServletContainer(tomcat);
&#125;</code></pre>
<p>4）、我们对嵌入式容器的配置修改是怎么生效？</p>
<pre><code>ServerProperties、EmbeddedServletContainerCustomizer</code></pre>
<p><strong>EmbeddedServletContainerCustomizer</strong>：定制器帮我们修改了Servlet容器的配置？</p>
<p>怎么修改的原理？</p>
<p>5）、容器中导入了<strong>EmbeddedServletContainerCustomizerBeanPostProcessor</strong></p>
<pre><code class="java">//初始化之前
@Override
public Object postProcessBeforeInitialization(Object bean, String beanName)
      throws BeansException &#123;
    //如果当前初始化的是一个ConfigurableEmbeddedServletContainer类型的组件
   if (bean instanceof ConfigurableEmbeddedServletContainer) &#123;
       //
      postProcessBeforeInitialization((ConfigurableEmbeddedServletContainer) bean);
   &#125;
   return bean;
&#125;

private void postProcessBeforeInitialization(
            ConfigurableEmbeddedServletContainer bean) &#123;
    //获取所有的定制器，调用每一个定制器的customize方法来给Servlet容器进行属性赋值；
    for (EmbeddedServletContainerCustomizer customizer : getCustomizers()) &#123;
        customizer.customize(bean);
    &#125;
&#125;

private Collection&lt;EmbeddedServletContainerCustomizer&gt; getCustomizers() &#123;
    if (this.customizers == null) &#123;
        // Look up does not include the parent context
        this.customizers = new ArrayList&lt;EmbeddedServletContainerCustomizer&gt;(
            this.beanFactory
            //从容器中获取所有这葛类型的组件：EmbeddedServletContainerCustomizer
            //定制Servlet容器，给容器中可以添加一个EmbeddedServletContainerCustomizer类型的组件
            .getBeansOfType(EmbeddedServletContainerCustomizer.class,
                            false, false)
            .values());
        Collections.sort(this.customizers, AnnotationAwareOrderComparator.INSTANCE);
        this.customizers = Collections.unmodifiableList(this.customizers);
    &#125;
    return this.customizers;
&#125;

ServerProperties也是定制器</code></pre>
<p>步骤：</p>
<p>1）、SpringBoot根据导入的依赖情况，给容器中添加相应的EmbeddedServletContainerFactory【TomcatEmbeddedServletContainerFactory】</p>
<p>2）、容器中某个组件要创建对象就会惊动后置处理器；EmbeddedServletContainerCustomizerBeanPostProcessor；</p>
<p>只要是嵌入式的Servlet容器工厂，后置处理器就工作；</p>
<p>3）、后置处理器，从容器中获取所有的<strong>EmbeddedServletContainerCustomizer</strong>，调用定制器的定制方法</p>
<p>###5）、嵌入式Servlet容器启动原理；</p>
<p>什么时候创建嵌入式的Servlet容器工厂？什么时候获取嵌入式的Servlet容器并启动Tomcat；</p>
<p>获取嵌入式的Servlet容器工厂：</p>
<p>1）、SpringBoot应用启动运行run方法</p>
<p>2）、refreshContext(context);SpringBoot刷新IOC容器【创建IOC容器对象，并初始化容器，创建容器中的每一个组件】；如果是web应用创建<strong>AnnotationConfigEmbeddedWebApplicationContext</strong>，否则：<strong>AnnotationConfigApplicationContext</strong></p>
<p>3）、refresh(context);<strong>刷新刚才创建好的ioc容器；</strong></p>
<pre><code class="java">public void refresh() throws BeansException, IllegalStateException &#123;
   synchronized (this.startupShutdownMonitor) &#123;
      // Prepare this context for refreshing.
      prepareRefresh();

      // Tell the subclass to refresh the internal bean factory.
      ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();

      // Prepare the bean factory for use in this context.
      prepareBeanFactory(beanFactory);

      try &#123;
         // Allows post-processing of the bean factory in context subclasses.
         postProcessBeanFactory(beanFactory);

         // Invoke factory processors registered as beans in the context.
         invokeBeanFactoryPostProcessors(beanFactory);

         // Register bean processors that intercept bean creation.
         registerBeanPostProcessors(beanFactory);

         // Initialize message source for this context.
         initMessageSource();

         // Initialize event multicaster for this context.
         initApplicationEventMulticaster();

         // Initialize other special beans in specific context subclasses.
         onRefresh();

         // Check for listener beans and register them.
         registerListeners();

         // Instantiate all remaining (non-lazy-init) singletons.
         finishBeanFactoryInitialization(beanFactory);

         // Last step: publish corresponding event.
         finishRefresh();
      &#125;

      catch (BeansException ex) &#123;
         if (logger.isWarnEnabled()) &#123;
            logger.warn(&quot;Exception encountered during context initialization - &quot; +
                  &quot;cancelling refresh attempt: &quot; + ex);
         &#125;

         // Destroy already created singletons to avoid dangling resources.
         destroyBeans();

         // Reset &#39;active&#39; flag.
         cancelRefresh(ex);

         // Propagate exception to caller.
         throw ex;
      &#125;

      finally &#123;
         // Reset common introspection caches in Spring&#39;s core, since we
         // might not ever need metadata for singleton beans anymore...
         resetCommonCaches();
      &#125;
   &#125;
&#125;</code></pre>
<p>4）、  onRefresh(); web的ioc容器重写了onRefresh方法</p>
<p>5）、webioc容器会创建嵌入式的Servlet容器；<strong>createEmbeddedServletContainer</strong>();</p>
<p><strong>6）、获取嵌入式的Servlet容器工厂：</strong></p>
<p>EmbeddedServletContainerFactory containerFactory = getEmbeddedServletContainerFactory();</p>
<p>​    从ioc容器中获取EmbeddedServletContainerFactory 组件；<strong>TomcatEmbeddedServletContainerFactory</strong>创建对象，后置处理器一看是这个对象，就获取所有的定制器来先定制Servlet容器的相关配置；</p>
<p>7）、<strong>使用容器工厂获取嵌入式的Servlet容器</strong>：this.embeddedServletContainer = containerFactory      .getEmbeddedServletContainer(getSelfInitializer());</p>
<p>8）、嵌入式的Servlet容器创建对象并启动Servlet容器；</p>
<p><strong>先启动嵌入式的Servlet容器，再将ioc容器中剩下没有创建出的对象获取出来；</strong></p>
<p><strong>==IOC容器启动创建嵌入式的Servlet容器==</strong></p>
<h2 id="9、使用外置的Servlet容器"><a href="#9、使用外置的Servlet容器" class="headerlink" title="9、使用外置的Servlet容器"></a>9、使用外置的Servlet容器</h2><p>嵌入式Servlet容器：应用打成可执行的jar</p>
<p>​        优点：简单、便携；</p>
<p>​        缺点：默认不支持JSP、优化定制比较复杂（使用定制器【ServerProperties、自定义EmbeddedServletContainerCustomizer】，自己编写嵌入式Servlet容器的创建工厂【EmbeddedServletContainerFactory】）；</p>
<p>外置的Servlet容器：外面安装Tomcat—应用war包的方式打包；</p>
<h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>1）、必须创建一个war项目；（利用idea创建好目录结构）</p>
<p>2）、将嵌入式的Tomcat指定为provided；</p>
<pre><code class="xml">&lt;dependency&gt;
   &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
   &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;
   &lt;scope&gt;provided&lt;/scope&gt;
&lt;/dependency&gt;</code></pre>
<p>3）、必须编写一个<strong>SpringBootServletInitializer</strong>的子类，并调用configure方法</p>
<pre><code class="java">public class ServletInitializer extends SpringBootServletInitializer &#123;

   @Override
   protected SpringApplicationBuilder configure(SpringApplicationBuilder application) &#123;
       //传入SpringBoot应用的主程序
      return application.sources(SpringBoot04WebJspApplication.class);
   &#125;

&#125;</code></pre>
<p>4）、启动服务器就可以使用；</p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>jar包：执行SpringBoot主类的main方法，启动ioc容器，创建嵌入式的Servlet容器；</p>
<p>war包：启动服务器，<strong>服务器启动SpringBoot应用</strong>【SpringBootServletInitializer】，启动ioc容器；</p>
<p>servlet3.0（Spring注解版）：</p>
<p>8.2.4 Shared libraries / runtimes pluggability：</p>
<p>规则：</p>
<p>​    1）、服务器启动（web应用启动）会创建当前web应用里面每一个jar包里面ServletContainerInitializer实例：</p>
<p>​    2）、ServletContainerInitializer的实现放在jar包的META-INF/services文件夹下，有一个名为javax.servlet.ServletContainerInitializer的文件，内容就是ServletContainerInitializer的实现类的全类名</p>
<p>​    3）、还可以使用@HandlesTypes，在应用启动的时候加载我们感兴趣的类；</p>
<p>流程：</p>
<p>1）、启动Tomcat</p>
<p>2）、org\springframework\spring-web\4.3.14.RELEASE\spring-web-4.3.14.RELEASE.jar!\META-INF\services\javax.servlet.ServletContainerInitializer：</p>
<p>Spring的web模块里面有这个文件：<strong>org.springframework.web.SpringServletContainerInitializer</strong></p>
<p>3）、SpringServletContainerInitializer将@HandlesTypes(WebApplicationInitializer.class)标注的所有这个类型的类都传入到onStartup方法的Set&lt;Class&lt;?&gt;&gt;；为这些WebApplicationInitializer类型的类创建实例；</p>
<p>4）、每一个WebApplicationInitializer都调用自己的onStartup；</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180302221835.png" loading="lazy"></p>
<p>5）、相当于我们的SpringBootServletInitializer的类会被创建对象，并执行onStartup方法</p>
<p>6）、SpringBootServletInitializer实例执行onStartup的时候会createRootApplicationContext；创建容器</p>
<pre><code class="java">protected WebApplicationContext createRootApplicationContext(
      ServletContext servletContext) &#123;
    //1、创建SpringApplicationBuilder
   SpringApplicationBuilder builder = createSpringApplicationBuilder();
   StandardServletEnvironment environment = new StandardServletEnvironment();
   environment.initPropertySources(servletContext, null);
   builder.environment(environment);
   builder.main(getClass());
   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);
   if (parent != null) &#123;
      this.logger.info(&quot;Root context already created (using as parent).&quot;);
      servletContext.setAttribute(
            WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, null);
      builder.initializers(new ParentContextApplicationContextInitializer(parent));
   &#125;
   builder.initializers(
         new ServletContextApplicationContextInitializer(servletContext));
   builder.contextClass(AnnotationConfigEmbeddedWebApplicationContext.class);

    //调用configure方法，子类重写了这个方法，将SpringBoot的主程序类传入了进来
   builder = configure(builder);

    //使用builder创建一个Spring应用
   SpringApplication application = builder.build();
   if (application.getSources().isEmpty() &amp;&amp; AnnotationUtils
         .findAnnotation(getClass(), Configuration.class) != null) &#123;
      application.getSources().add(getClass());
   &#125;
   Assert.state(!application.getSources().isEmpty(),
         &quot;No SpringApplication sources have been defined. Either override the &quot;
               + &quot;configure method or add an @Configuration annotation&quot;);
   // Ensure error pages are registered
   if (this.registerErrorPageFilter) &#123;
      application.getSources().add(ErrorPageFilterConfiguration.class);
   &#125;
    //启动Spring应用
   return run(application);
&#125;</code></pre>
<p>7）、Spring的应用就启动并且创建IOC容器</p>
<pre><code class="java">public ConfigurableApplicationContext run(String... args) &#123;
   StopWatch stopWatch = new StopWatch();
   stopWatch.start();
   ConfigurableApplicationContext context = null;
   FailureAnalyzers analyzers = null;
   configureHeadlessProperty();
   SpringApplicationRunListeners listeners = getRunListeners(args);
   listeners.starting();
   try &#123;
      ApplicationArguments applicationArguments = new DefaultApplicationArguments(
            args);
      ConfigurableEnvironment environment = prepareEnvironment(listeners,
            applicationArguments);
      Banner printedBanner = printBanner(environment);
      context = createApplicationContext();
      analyzers = new FailureAnalyzers(context);
      prepareContext(context, environment, listeners, applicationArguments,
            printedBanner);

       //刷新IOC容器
      refreshContext(context);
      afterRefresh(context, applicationArguments);
      listeners.finished(context, null);
      stopWatch.stop();
      if (this.logStartupInfo) &#123;
         new StartupInfoLogger(this.mainApplicationClass)
               .logStarted(getApplicationLog(), stopWatch);
      &#125;
      return context;
   &#125;
   catch (Throwable ex) &#123;
      handleRunFailure(context, listeners, analyzers, ex);
      throw new IllegalStateException(ex);
   &#125;
&#125;</code></pre>
<p><strong>==启动Servlet容器，再启动SpringBoot应用==</strong></p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot错误处理机制</title>
    <url>/2020/11/03/spring/spring-boot/2020-11-3-spring-boot%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</url>
    <content><![CDATA[<h3 id="默认效果"><a href="#默认效果" class="headerlink" title="默认效果"></a>默认效果</h3><ul>
<li><p>浏览器，返回一个默认的错误页面</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226173408.png" loading="lazy"></p>
<p>浏览器发送请求的请求头：</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226180347.png" loading="lazy"></p>
</li>
<li><p>如果是其他客户端，默认响应一个json数据</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226173527.png" loading="lazy"></p>
</li>
</ul>
<p>​        客户端发送的请求头：</p>
<p>​        <img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180226180504.png" loading="lazy"></p>
<h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>从<code>ErrorMvcAutoConfiguration</code>入手</p>
<p> 该配置类给容器中添加了以下组件</p>
<h4 id="DefaultErrorAttributes"><a href="#DefaultErrorAttributes" class="headerlink" title="DefaultErrorAttributes"></a>DefaultErrorAttributes</h4><pre><code class="java">@Bean
@ConditionalOnMissingBean(value = ErrorAttributes.class, search = SearchStrategy.CURRENT) //我们也可以自己定义一个ErrorAttributes
public DefaultErrorAttributes errorAttributes() &#123;
   return new DefaultErrorAttributes(this.serverProperties.getError().isIncludeException());
&#125;</code></pre>
<pre><code class="java">public class DefaultErrorAttributes implements ErrorAttributes, HandlerExceptionResolver, Ordered &#123;
    //该方法帮我们在页面共享信息，也就是WhtieLable Page的一些属性展示
    @Override
    public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123;
       Map&lt;String, Object&gt; errorAttributes = new LinkedHashMap&lt;&gt;();
       errorAttributes.put(&quot;timestamp&quot;, new Date());
       addStatus(errorAttributes, webRequest);
       addErrorDetails(errorAttributes, webRequest, includeStackTrace);
       addPath(errorAttributes, webRequest);
       return errorAttributes;
    &#125;
&#125;</code></pre>
<h4 id="BasicErrorController"><a href="#BasicErrorController" class="headerlink" title="BasicErrorController"></a>BasicErrorController</h4><p>处理默认/error请求</p>
<pre><code class="java">@Bean
@ConditionalOnMissingBean(value = ErrorController.class, search = SearchStrategy.CURRENT)
public BasicErrorController basicErrorController(ErrorAttributes errorAttributes) &#123;
   return new BasicErrorController(errorAttributes, this.serverProperties.getError(), this.errorViewResolvers);
&#125;</code></pre>
<pre><code class="java">@Controller
@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)
public class BasicErrorController extends AbstractErrorController &#123;

    //处理浏览器请求，用于返回html数据
      @RequestMapping(produces = MediaType.TEXT_HTML_VALUE) 
    public ModelAndView errorHtml(HttpServletRequest request, HttpServletResponse response) &#123;
        HttpStatus status = getStatus(request);
        Map&lt;String, Object&gt; model = Collections
                .unmodifiableMap(getErrorAttributes(request, isIncludeStackTrace(request, MediaType.TEXT_HTML)));
        response.setStatus(status.value());
        ModelAndView modelAndView = resolveErrorView(request, response, status, model); //通过调用DefaultErrorViewResolver来获取ModelAndView
        return (modelAndView != null) ? modelAndView : new ModelAndView(&quot;error&quot;, model);//如果没有定制页面就使用静态错误页面(StaticView)
    &#125;

    //处理其他客户请求，返回Json数据
    @RequestMapping 
    public ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;
        Map&lt;String, Object&gt; body = getErrorAttributes(request, isIncludeStackTrace(request, MediaType.ALL));
        HttpStatus status = getStatus(request);
        return new ResponseEntity&lt;&gt;(body, status);
    &#125;
&#125;</code></pre>
<h4 id="ErrorPageCustomizer"><a href="#ErrorPageCustomizer" class="headerlink" title="ErrorPageCustomizer"></a>ErrorPageCustomizer</h4><p>错误页面定制</p>
<pre><code class="java">@Bean
public ErrorPageCustomizer errorPageCustomizer() &#123;
   return new ErrorPageCustomizer(this.serverProperties, this.dispatcherServletPath);
&#125;</code></pre>
<pre><code class="java">private static class ErrorPageCustomizer implements ErrorPageRegistrar, Ordered &#123;

   private final ServerProperties properties;

   private final DispatcherServletPath dispatcherServletPath;

   protected ErrorPageCustomizer(ServerProperties properties, DispatcherServletPath dispatcherServletPath) &#123;
      this.properties = properties;
      this.dispatcherServletPath = dispatcherServletPath;
   &#125;

   @Override
   public void registerErrorPages(ErrorPageRegistry errorPageRegistry) &#123;

      ErrorPage errorPage = new ErrorPage(
            this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath()));

      errorPageRegistry.addErrorPages(errorPage);
   &#125;

   @Override
   public int getOrder() &#123;
      return 0;
   &#125;

&#125;</code></pre>
<p><code>this.dispatcherServletPath.getRelativePath(this.properties.getError().getPath())</code> 通过 <code>ErrorProperties</code>获取</p>
<pre><code class="java">public class ErrorProperties &#123;

   /**
    * Path of the error controller.
    */
   @Value(&quot;$&#123;error.path:/error&#125;&quot;)
   private String path = &quot;/error&quot;;
&#125;</code></pre>
<h4 id="DefaultErrorViewResolver"><a href="#DefaultErrorViewResolver" class="headerlink" title="DefaultErrorViewResolver"></a>DefaultErrorViewResolver</h4><p>默认错误视图解析器</p>
<pre><code class="java">@Bean
@ConditionalOnBean(DispatcherServlet.class)
@ConditionalOnMissingBean
public DefaultErrorViewResolver conventionErrorViewResolver() &#123;
   return new DefaultErrorViewResolver(this.applicationContext, this.resourceProperties);
&#125;</code></pre>
<pre><code class="java">public class DefaultErrorViewResolver implements ErrorViewResolver, Ordered &#123;

    //ViewName Map
    private static final Map&lt;Series, String&gt; SERIES_VIEWS;

    static &#123;
        Map&lt;Series, String&gt; views = new EnumMap&lt;&gt;(Series.class);
        views.put(Series.CLIENT_ERROR, &quot;4xx&quot;);
        views.put(Series.SERVER_ERROR, &quot;5xx&quot;);
        SERIES_VIEWS = Collections.unmodifiableMap(views);
    &#125;

    //解析视图
    @Override
    public ModelAndView resolveErrorView(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model) &#123;
       //先找寻具体状态码的html
        ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);
        //如果找不到就去找4xx.html/5xx.html
       if (modelAndView == null &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;
          modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);
       &#125;
       return modelAndView;
    &#125;

    private ModelAndView resolve(String viewName, Map&lt;String, Object&gt; model) &#123;
        //视图名
       String errorViewName = &quot;error/&quot; + viewName;
        //模板引擎是否可以解析这个页面地址
       TemplateAvailabilityProvider provider = this.templateAvailabilityProviders.getProvider(errorViewName,
             this.applicationContext);
        //如果可以解析就直接返回
       if (provider != null) &#123;
          return new ModelAndView(errorViewName, model);
       &#125;
        //模板引擎不可用就去静态资源文件夹下找errorViewName对应页面 error/404.html
       return resolveResource(errorViewName, model);
    &#125;
&#125;</code></pre>
<h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol>
<li><p>系统出现4xx或者5xx之类的错误；<code>ErrorPageCustomizer</code>就会生效（定制错误的响应规则）</p>
</li>
<li><p>来到/error请求，就会被<code>BasicErrorController</code>处理；</p>
</li>
<li><p>获取响应响应页面,<code>BasicErrorController</code>通过调用<code>resolveErrorView()</code>方法来解析得到页面</p>
<pre><code class="java">protected ModelAndView resolveErrorView(HttpServletRequest request,
      HttpServletResponse response, HttpStatus status, Map&lt;String, Object&gt; model) &#123;
    //所有的ErrorViewResolver得到ModelAndView
   for (ErrorViewResolver resolver : this.errorViewResolvers) &#123;
      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);
      if (modelAndView != null) &#123;
         return modelAndView;
      &#125;
   &#125;
   return null;
&#125;</code></pre>
</li>
</ol>
<h3 id="定制错误响应："><a href="#定制错误响应：" class="headerlink" title="定制错误响应："></a>定制错误响应：</h3><h4 id="定制错误的页面"><a href="#定制错误的页面" class="headerlink" title="定制错误的页面"></a>定制错误的页面</h4><ol>
<li><p>由<code>DefaultErrorViewResolver</code>的<code>resolveErrorView()</code>可以知道页码查找顺序如下：</p>
<p>模板引擎状态码.html-&gt;静态资源状态码.html-&gt;模板引擎4xx.html-&gt;静态资源4xx.html-&gt;默认静态页面</p>
</li>
<li><p>页面能获取的信息<code>DefaultErrorAttributes</code>；</p>
<ul>
<li>timestamp：时间戳</li>
<li>status：状态码</li>
<li>error：错误提示</li>
<li>exception：异常对象</li>
<li>message：异常消息</li>
<li>errors：JSR303数据校验的错误都在这里</li>
</ul>
</li>
</ol>
<h4 id="如何定制错误的json数据"><a href="#如何定制错误的json数据" class="headerlink" title="如何定制错误的json数据"></a>如何定制错误的json数据</h4><ol>
<li><p>自定义异常处理&amp;返回定制json数据；</p>
<pre><code class="java">@ControllerAdvice
public class MyExceptionHandler &#123;

    @ResponseBody
    @ExceptionHandler(UserNotExistException.class)
    public Map&lt;String,Object&gt; handleException(Exception e)&#123;
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        map.put(&quot;code&quot;,&quot;user.notexist&quot;);
        map.put(&quot;message&quot;,e.getMessage());
        return map;
    &#125;
&#125;
//没有自适应效果...</code></pre>
</li>
<li><p>转发到/error进行自适应响应效果处理</p>
<pre><code class="java"> @ExceptionHandler(UserNotExistException.class)
    public String handleException(Exception e, HttpServletRequest request)&#123;
        Map&lt;String,Object&gt; map = new HashMap&lt;&gt;();
        //传入我们自己的错误状态码  4xx 5xx，否则就不会进入定制错误页面的解析流程
        /**
         * Integer statusCode = (Integer) request
         .getAttribute(&quot;javax.servlet.error.status_code&quot;);
         */
        request.setAttribute(&quot;javax.servlet.error.status_code&quot;,500);
        map.put(&quot;code&quot;,&quot;user.notexist&quot;);
        map.put(&quot;message&quot;,e.getMessage());
        //转发到/error
        return &quot;forward:/error&quot;;
    &#125;</code></pre>
</li>
</ol>
<h4 id="将我们的定制数据携带出去；"><a href="#将我们的定制数据携带出去；" class="headerlink" title="将我们的定制数据携带出去；"></a>将我们的定制数据携带出去；</h4><p>出现错误以后，会来到/error请求，会被BasicErrorController处理，响应出去可以获取的数据是由<code>getErrorAttributes()</code>得到的（是AbstractErrorController（ErrorController）规定的方法）</p>
<ol>
<li>完全来编写一个ErrorController的实现类【或者是编写AbstractErrorController的子类】，放在容器中；</li>
</ol>
<ol start="2">
<li><p>页面上能用的数据或者是json返回能用的数据都是通过<code>errorAttributes.getErrorAttributes()</code>得到,也就是<code>DefaultErrorAttributes.getErrorAttributes()</code>。因此可以自定义一个<code>DefaultErrorAttributes</code>重写<code>getErrorAttributes()</code></p>
<pre><code class="java">//给容器中加入我们自己定义的ErrorAttributes
@Component
public class MyDefaultErrorAttributes extends DefaultErrorAttributes &#123;
    public MyDefaultErrorAttributes() &#123;
        super();
    &#125;

    public MyDefaultErrorAttributes(boolean includeException) &#123;
        super(includeException);
    &#125;
    @Override
    public Map&lt;String, Object&gt; getErrorAttributes(WebRequest webRequest, boolean includeStackTrace) &#123;
        Map&lt;String, Object&gt; errorAttributes = super.getErrorAttributes(webRequest, includeStackTrace);
        errorAttributes.put(&quot;name&quot;, &quot;libin&quot;);
        errorAttributes.put(&quot;age&quot;, 18);
        errorAttributes.put(&quot;score&quot;, 98);
        return errorAttributes;
    &#125;
&#125;</code></pre>
<p>最终的效果：响应是自适应的，可以通过定制ErrorAttributes改变需要返回的内容，</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201103184333717.png" alt="image-20201103184333717" loading="lazy"></p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring MVC自动配置类</title>
    <url>/2020/11/02/spring/spring-boot/2020-11-4-spring-MVC%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h3 id="1-Spring-MVC-auto-configuration"><a href="#1-Spring-MVC-auto-configuration" class="headerlink" title="1. Spring MVC auto-configuration"></a>1. Spring MVC auto-configuration</h3><p><a href="https://docs.spring.io/spring-boot/docs/2.1.18.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-auto-configuration">https://docs.spring.io/spring-boot/docs/2.1.18.RELEASE/reference/html/boot-features-developing-web-applications.html#boot-features-spring-mvc-auto-configuration</a></p>
<p>Spring Boot 自动配置好了SpringMVC</p>
<p>以下是SpringBoot对SpringMVC的默认配置:**==（WebMvcAutoConfiguration）== **</p>
<ul>
<li><p>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</p>
<ul>
<li><p>自动配置了ViewResolver（视图解析器：根据方法的返回值得到视图对象（View），视图对象决定如何渲染（转发？重定向？））</p>
</li>
<li><p>ContentNegotiatingViewResolver：组合所有的视图解析器的；</p>
<pre><code class="java">protected void initServletContext(ServletContext servletContext) &#123;
   Collection&lt;ViewResolver&gt; matchingBeans =
         BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values();
   if (this.viewResolvers == null) &#123;
      this.viewResolvers = new ArrayList&lt;&gt;(matchingBeans.size());
      for (ViewResolver viewResolver : matchingBeans) &#123;
         if (this != viewResolver) &#123;
            this.viewResolvers.add(viewResolver);
         &#125;
      &#125;
   &#125;
   else &#123;
      for (int i = 0; i &lt; this.viewResolvers.size(); i++) &#123;
         ViewResolver vr = this.viewResolvers.get(i);
         if (matchingBeans.contains(vr)) &#123;
            continue;
         &#125;
         String name = vr.getClass().getName() + i;
         obtainApplicationContext().getAutowireCapableBeanFactory().initializeBean(vr, name);
      &#125;

   &#125;
   AnnotationAwareOrderComparator.sort(this.viewResolvers);
   this.cnmFactoryBean.setServletContext(servletContext);
&#125;</code></pre>
<p><code> BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values();</code>直接从容器中获取所有的视图解析器</p>
</li>
<li><p>==如何定制：我们可以自己给容器中添加一个视图解析器；自动的将其组合进来；==</p>
<pre><code class="java">public class MyResolver implements ViewResolver &#123;
    @Override
    public View resolveViewName(String viewName, Locale locale) throws Exception &#123;
        return null;
    &#125;
&#125;</code></pre>
<p>在DispatcherServlet中就可以看到视图解析器已经添加成功了</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201103140205412.png" alt="image-20201103140205412" loading="lazy"></p>
</li>
</ul>
</li>
<li><p>Support for serving static resources, including support for WebJars (see below).静态资源文件夹路径,webjars</p>
</li>
<li><p>Static <code>index.html</code> support. 静态首页访问</p>
</li>
<li><p>Custom <code>Favicon</code> support (see below).  favicon.ico</p>
</li>
</ul>
<ul>
<li><p>自动注册了 of <code>Converter</code>, <code>GenericConverter</code>, <code>Formatter</code> beans.</p>
<ul>
<li><p>Converter：转换器；  public String hello(User user)：类型转换使用Converter</p>
</li>
<li><p><code>Formatter</code>  格式化器；  2017.12.17===Date；</p>
<pre><code class="java">@Bean
    @ConditionalOnProperty(prefix = &quot;spring.mvc&quot;, name = &quot;date-format&quot;)//在文件中配置日期格式化的规则
    public Formatter&lt;Date&gt; dateFormatter() &#123;
        return new DateFormatter(this.mvcProperties.getDateFormat());//日期格式化组件
    &#125;</code></pre>
</li>
</ul>
<pre><code class="java">@Override
public void addFormatters(FormatterRegistry registry) &#123;
   for (Converter&lt;?, ?&gt; converter : getBeansOfType(Converter.class)) &#123;
      registry.addConverter(converter);
   &#125;//遍历容器中的Converter来添加
   for (GenericConverter converter : getBeansOfType(GenericConverter.class)) &#123;
      registry.addConverter(converter);
   &#125;
   for (Formatter&lt;?&gt; formatter : getBeansOfType(Formatter.class)) &#123;
      registry.addFormatter(formatter);
   &#125;
&#125;

private &lt;T&gt; Collection&lt;T&gt; getBeansOfType(Class&lt;T&gt; type) &#123;
   return this.beanFactory.getBeansOfType(type).values();
&#125;</code></pre>
</li>
</ul>
<p>​    ==因此如果自己想要添加格式化器转换器，我们只需要放在容器中即可==</p>
<ul>
<li><p>Support for <code>HttpMessageConverters</code> (see below).</p>
<ul>
<li><p><code>HttpMessageConverter</code>：SpringMVC用来转换Http请求和响应的；User—Json；</p>
</li>
<li><p><code>WebMvcAutoConfigurationAdapter</code>只有一个有参构造器，说明<code>HttpMessageConverters</code> 是从容器中确定，</p>
<pre><code class="java">public WebMvcAutoConfigurationAdapter(ResourceProperties resourceProperties, WebMvcProperties mvcProperties,
      ListableBeanFactory beanFactory, ObjectProvider&lt;HttpMessageConverters&gt; messageConvertersProvider,
      ObjectProvider&lt;ResourceHandlerRegistrationCustomizer&gt; resourceHandlerRegistrationCustomizerProvider) &#123;
   this.resourceProperties = resourceProperties;
   this.mvcProperties = mvcProperties;
   this.beanFactory = beanFactory;
   this.messageConvertersProvider = messageConvertersProvider;
   this.resourceHandlerRegistrationCustomizer = resourceHandlerRegistrationCustomizerProvider.getIfAvailable();
&#125;</code></pre>
<pre><code>public HttpMessageConverters(HttpMessageConverter&lt;?&gt;... additionalConverters) &#123;
   this(Arrays.asList(additionalConverters));
&#125;

/**
 * Create a new &#123;@link HttpMessageConverters&#125; instance with the specified additional
 * converters.
 * @param additionalConverters additional converters to be added. Items are added just
 * before any default converter of the same type (or at the front of the list if no
 * default converter is found) The &#123;@link #postProcessConverters(List)&#125; method can be
 * used for further converter manipulation.
 */
public HttpMessageConverters(Collection&lt;HttpMessageConverter&lt;?&gt;&gt; additionalConverters) &#123;
   this(true, additionalConverters);
&#125;</code></pre>
<p>==<code>HttpMessageConverters</code> 也只有有参构造器，说明是从容器中获取所有的HttpMessageConverter；因此要给给容器中添加<code>HttpMessageConverter</code>，只需要将自己的组件注册容器中（@Bean,@Component）==</p>
</li>
</ul>
</li>
</ul>
<ul>
<li><p>Automatic registration of <code>MessageCodesResolver</code> (see below).定义错误代码生成规则</p>
</li>
<li><p>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean (see below).</p>
<p>==我们可以配置一个ConfigurableWebBindingInitializer来替换默认的；（添加到容器）==</p>
<pre><code>初始化WebDataBinder；
将请求数据转换为JavaBean；</code></pre>
<pre><code class="java">
        @Override
        protected ConfigurableWebBindingInitializer getConfigurableWebBindingInitializer() &#123;
            try &#123;
                return this.beanFactory.getBean(ConfigurableWebBindingInitializer.class);
            &#125;
            catch (NoSuchBeanDefinitionException ex) &#123;
                return super.getConfigurableWebBindingInitializer();
            &#125;
        &#125;
</code></pre>
</li>
</ul>
<p><strong>org.springframework.boot.autoconfigure.web：web的所有自动场景；</strong></p>
<p>If you want to keep Spring Boot MVC features and you want to add additional <a href="https://docs.spring.io/spring/docs/5.1.19.RELEASE/spring-framework-reference/web.html#mvc">MVC configuration</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, you can declare a <code>WebMvcRegistrationsAdapter</code> instance to provide such components.</p>
<p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p>
<h3 id="2、扩展SpringMVC"><a href="#2、扩展SpringMVC" class="headerlink" title="2、扩展SpringMVC"></a>2、扩展SpringMVC</h3><pre><code class="xml">    &lt;mvc:view-controller path=&quot;/hello&quot; view-name=&quot;success&quot;/&gt;
    &lt;mvc:interceptors&gt;
        &lt;mvc:interceptor&gt;
            &lt;mvc:mapping path=&quot;/hello&quot;/&gt;
            &lt;bean&gt;&lt;/bean&gt;
        &lt;/mvc:interceptor&gt;
    &lt;/mvc:interceptors&gt;</code></pre>
<p><strong>==编写一个配置类（@Configuration），是WebMvcConfigurerAdapter类型；不能标注@EnableWebMvc==</strong>;</p>
<p><strong>==SpringBoot 2.0 后，该类被标记为@Deprecated。因此我们只能靠实现WebMvcConfigurer接口来实现==</strong></p>
<p>既保留了所有的自动配置，也能用我们扩展的配置；</p>
<pre><code class="java">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能
@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter &#123;

    @Override
    public void addViewControllers(ViewControllerRegistry registry) &#123;
       // super.addViewControllers(registry);
        //浏览器发送 /atguigu 请求来到 success
        registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;);
    &#125;
&#125;</code></pre>
<p>原理：</p>
<ol>
<li>WebMvcAutoConfiguration是SpringMVC的自动配置类</li>
</ol>
<ol start="2">
<li><p>在做其他自动配置时会导入；@Import(<strong>EnableWebMvcConfiguration</strong>.class)</p>
<pre><code class="java"> @Configuration
    public static class EnableWebMvcConfiguration extends DelegatingWebMvcConfiguration &#123;

    &#125;</code></pre>
</li>
<li><p>父类<code>DelegatingWebMvcConfiguration</code>中有一个<code>setConfigurers()</code>方法，这样会将容器中所有的WebMvcConfigure都一起添加进去。</p>
<pre><code class="java">@Configuration
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;

    private final WebMvcConfigurerComposite configurers = new WebMvcConfigurerComposite();

    @Autowired(required = false)
    public void setConfigurers(List&lt;WebMvcConfigurer&gt; configurers) &#123;
        if (!CollectionUtils.isEmpty(configurers)) &#123;
            this.configurers.addWebMvcConfigurers(configurers);
        &#125;
    &#125;</code></pre>
</li>
<li><p>我们的配置类也会被调用；</p>
</li>
</ol>
<p>​    效果：SpringMVC的自动配置和我们的扩展配置都会起作用；</p>
<h3 id="3、全面接管SpringMVC；"><a href="#3、全面接管SpringMVC；" class="headerlink" title="3、全面接管SpringMVC；"></a>3、全面接管SpringMVC；</h3><p>SpringBoot对SpringMVC的自动配置不需要了，所有都是我们自己配置；所有的SpringMVC的自动配置都失效了</p>
<p><strong>我们需要在配置类中添加@EnableWebMvc即可；</strong></p>
<pre><code class="java">//使用WebMvcConfigurerAdapter可以来扩展SpringMVC的功能
@EnableWebMvc
@Configuration
public class MyMvcConfig extends WebMvcConfigurerAdapter &#123;

    @Override
    public void addViewControllers(ViewControllerRegistry registry) &#123;
       // super.addViewControllers(registry);
        //浏览器发送 /atguigu 请求来到 success
        registry.addViewController(&quot;/atguigu&quot;).setViewName(&quot;success&quot;);
    &#125;
&#125;</code></pre>
<p>原理：</p>
<p>为什么@EnableWebMvc自动配置就失效了；</p>
<p>1）@EnableWebMvc的核心</p>
<pre><code class="java">@Import(DelegatingWebMvcConfiguration.class)
public @interface EnableWebMvc &#123;</code></pre>
<p>2）、</p>
<pre><code class="java">@Configuration
public class DelegatingWebMvcConfiguration extends WebMvcConfigurationSupport &#123;</code></pre>
<p>3）、</p>
<pre><code class="java">@Configuration
@ConditionalOnWebApplication
@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class,
        WebMvcConfigurerAdapter.class &#125;)
//容器中没有这个组件的时候，这个自动配置类才生效
@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)
@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)
@AutoConfigureAfter(&#123; DispatcherServletAutoConfiguration.class,
        ValidationAutoConfiguration.class &#125;)
public class WebMvcAutoConfiguration &#123;</code></pre>
<p>4）、@EnableWebMvc将WebMvcConfigurationSupport组件导入进来；</p>
<p>5）、导入的WebMvcConfigurationSupport只是SpringMVC最基本的功能；</p>
<h3 id="4、如何修改SpringBoot的默认配置"><a href="#4、如何修改SpringBoot的默认配置" class="headerlink" title="4、如何修改SpringBoot的默认配置"></a>4、如何修改SpringBoot的默认配置</h3><p>模式：</p>
<p>​    1）、SpringBoot在自动配置很多组件的时候，先看容器中有没有用户自己配置的（@Bean、@Component）如果有就用用户配置的，如果没有，才自动配置；如果有些组件可以有多个（ViewResolver）将用户配置的和自己默认的组合起来；</p>
<p>​    2）、在SpringBoot中会有非常多的xxxConfigurer帮助我们进行扩展配置</p>
<p>​    3）、在SpringBoot中会有很多的xxxCustomizer帮助我们进行定制配置</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot cache</title>
    <url>/2020/11/04/spring/spring-boot/2020-11-4-spring-boot-cache/</url>
    <content><![CDATA[<h3 id="JSR107"><a href="#JSR107" class="headerlink" title="JSR107"></a>JSR107</h3><p>JSR是Java Specification Requests的缩写，意思是Java 规范提案。2012年10月26日JSR规范委员会发布了JSR 107（JCache API的首个早期草案）。JCache 规范定义了一种对Java对象临时在内存中进行缓存的方法，包括对象的创建、共享访问、假脱机（spooling）、失效、各JVM的一致性等，可被用于缓存JSP内最经常读取的数据。</p>
<p>Java Caching定义了5个核心接口，分别是<strong>CachingProvider</strong>, <strong>CacheManager</strong>, <strong>Cache</strong>, <strong>Entry</strong> 和 <strong>Expiry</strong>。</p>
<ul>
<li><p><strong>CachingProvider</strong>定义了创建、配置、获取、管理和控制多个<strong>CacheManager</strong>。一个应用可以在运行期访问多个CachingProvider。</p>
</li>
<li><p><strong>CacheManager</strong>定义了创建、配置、获取、管理和控制多个唯一命名的<strong>Cache</strong>，这些Cache存在于CacheManager的上下文中。一个CacheManager仅被一个CachingProvider所拥有。</p>
</li>
<li><p><strong>Cache</strong>是一个类似Map的数据结构并临时存储以Key为索引的值。一个Cache仅被一个CacheManager所拥有。</p>
</li>
<li><p><strong>Entry</strong>是一个存储在Cache中的key-value对。</p>
</li>
<li><p><strong>Expiry</strong> 每一个存储在Cache中的条目有一个定义的有效期。一旦超过这个时间，条目为过期的状态。一旦过期，条目将不可访问、更新和删除。缓存有效期可以通过ExpiryPolicy设置。</p>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201104233229140.png" alt="image-20201104233229140" loading="lazy"></p>
<h3 id="Spring缓存抽象"><a href="#Spring缓存抽象" class="headerlink" title="Spring缓存抽象"></a>Spring缓存抽象</h3><p>Spring从3.1开始定义了<code>org.springframework.cache.Cache</code>和<code>org.springframework.cache.CacheManager</code>接口来统一不同的缓存技术.并支持使用JCache（JSR-107）注解简化我们开发</p>
<ul>
<li><p>Cache接口为缓存的组件规范定义，包含缓存的各种操作集合；</p>
</li>
<li><p>Cache接口下Spring提供了各种xxxCache的实现；如<code>RedisCache</code>，<code>EhCacheCache</code> , <code>ConcurrentMapCache</code>等；</p>
</li>
<li><p>每次调用需要缓存功能的方法时，Spring会检查检查指定参数的指定的目标方法是否已经被调用过；如果有就直接从缓存中获取方法调用后的结果，如果没有就调用方法并缓存结果后返回给用户。下次调用直接从缓存中获取。</p>
</li>
<li><p>使用Spring缓存抽象时我们需要关注以下两点；</p>
<ol>
<li>确定方法需要被缓存以及他们的缓存策略</li>
<li>从缓存中读取之前缓存存储的数据</li>
</ol>
</li>
</ul>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201104233659653.png" alt="image-20201104233659653" loading="lazy"></p>
<h3 id="几个重要概念-amp-缓存注解"><a href="#几个重要概念-amp-缓存注解" class="headerlink" title="几个重要概念&amp;缓存注解"></a>几个重要概念&amp;缓存注解</h3><table>
<thead>
<tr>
<th><strong>Cache</strong></th>
<th>缓存接口，定义缓存操作。实现有：<code>RedisCache</code>、<code>EhCacheCache</code>、<code>ConcurrentMapCache</code>等</th>
</tr>
</thead>
<tbody><tr>
<td><strong>CacheManager</strong></td>
<td><strong>缓存管理器，管理各种缓存（Cache）组件</strong></td>
</tr>
<tr>
<td><strong>@Cacheable</strong></td>
<td><strong>主要针对方法配置，能够根据方法的请求参数对其结果进行缓存</strong></td>
</tr>
<tr>
<td><strong>@CacheEvict</strong></td>
<td><strong>清空缓存</strong></td>
</tr>
<tr>
<td><strong>@CachePut</strong></td>
<td><strong>保证方法被调用，又希望结果被缓存。</strong></td>
</tr>
<tr>
<td><strong>@EnableCaching</strong></td>
<td><strong>开启基于注解的缓存</strong></td>
</tr>
<tr>
<td><strong>keyGenerator</strong></td>
<td><strong>缓存数据时key生成策略</strong></td>
</tr>
<tr>
<td><strong>serialize</strong></td>
<td><strong>缓存数据时value序列化策略</strong></td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th><code>@Cacheable</code>/<code>@CachePut</code>/<code>@CacheEvict</code> <strong>主要的参数</strong></th>
<th>解释</th>
<th>例子</th>
</tr>
</thead>
<tbody><tr>
<td>value</td>
<td>缓存的名称，在  spring 配置文件中定义，必须指定至少一个</td>
<td><code>@Cacheable(value=”mycache”)</code> 或者      <code>@Cacheable(value=&#123;”cache1”,”cache2”&#125;</code></td>
</tr>
<tr>
<td>key</td>
<td>缓存的  key，可以为空，如果指定要按照  SpEL 表达式编写，如果不指定，则缺省按照方法的所有参数进行组合</td>
<td><code>@Cacheable(value=”testcache”,key=”#userName”)</code></td>
</tr>
<tr>
<td>condition</td>
<td>缓存的条件，可以为空，使用  SpEL 编写，返回  true 或者 false，只有为  true 才进行缓存/清除缓存，在调用方法之前之后都能判断</td>
<td><code>@Cacheable(value=”testcache”,condition=”#userName.length()&gt;2”)</code></td>
</tr>
<tr>
<td>allEntries  (<strong>@CacheEvict</strong>  )</td>
<td>是否清空所有缓存内容，缺省为  false，如果指定为 true，则方法调用后将立即清空所有缓存</td>
<td><code>@CachEvict(value=”testcache”,allEntries=true)</code></td>
</tr>
<tr>
<td>beforeInvocation  <strong>(@CacheEvict)</strong></td>
<td>是否在方法执行前就清空，缺省为  false，如果指定为 true，则在方法还没有执行的时候就清空缓存，缺省情况下，如果方法执行抛出异常，则不会清空缓存</td>
<td><code>@CachEvict(value=”testcache”，beforeInvocation=true)</code></td>
</tr>
<tr>
<td>unless  <strong>(@CachePut)</strong>  <strong>(@Cacheable)</strong></td>
<td>用于否决缓存的，不像condition，该表达式只在方法执行之后判断，此时可以拿到返回值result进行判断。条件为true不会缓存，fasle才缓存</td>
<td><code>@Cacheable(value=”testcache”,unless=”#result  == null”)</code></td>
</tr>
</tbody></table>
<p><strong>Cache</strong> <strong>SpEL</strong> <strong>available metadata</strong></p>
<table>
<thead>
<tr>
<th><strong>名字</strong></th>
<th><strong>位置</strong></th>
<th><strong>描述</strong></th>
<th><strong>示例</strong></th>
</tr>
</thead>
<tbody><tr>
<td>methodName</td>
<td>root object</td>
<td>当前被调用的方法名</td>
<td>#root.methodName</td>
</tr>
<tr>
<td>method</td>
<td>root object</td>
<td>当前被调用的方法</td>
<td>#root.method.name</td>
</tr>
<tr>
<td>target</td>
<td>root object</td>
<td>当前被调用的目标对象</td>
<td>#root.target</td>
</tr>
<tr>
<td>targetClass</td>
<td>root object</td>
<td>当前被调用的目标对象类</td>
<td>#root.targetClass</td>
</tr>
<tr>
<td>args</td>
<td>root object</td>
<td>当前被调用的方法的参数列表</td>
<td>#root.args[0]</td>
</tr>
<tr>
<td>caches</td>
<td>root object</td>
<td>当前方法调用使用的缓存列表（如@Cacheable(value={“cache1”,  “cache2”})），则有两个cache</td>
<td>#root.caches[0].name</td>
</tr>
<tr>
<td><em>argument name</em></td>
<td>evaluation context</td>
<td>方法参数的名字. 可以直接 #参数名 ，也可以使用 #p0或#a0 的形式，0代表参数的索引；</td>
<td>#iban 、 #a0 、 #p0</td>
</tr>
<tr>
<td>result</td>
<td>evaluation context</td>
<td>方法执行后的返回值（仅当方法执行之后的判断有效，如‘unless’，’cache put’的表达式 ’cache evict’的表达式beforeInvocation=false）</td>
<td>#result</td>
</tr>
</tbody></table>
<h3 id="缓存使用"><a href="#缓存使用" class="headerlink" title="缓存使用"></a>缓存使用</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><ol>
<li><p>引入<code>spring-boot-starter-cache</code>模块</p>
<pre><code class="xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-cache&lt;/artifactId&gt;
&lt;/dependency&gt;</code></pre>
</li>
<li><p><code>@EnableCaching</code>开启缓存</p>
<pre><code class="java">@SpringBootApplication
@MapperScan(&quot;com.soda.mapper&quot;)
@EnableCaching
public class CacheDemoApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(CacheDemoApplication.class, args);
    &#125;

&#125;</code></pre>
</li>
<li><p>使用缓存注解<code>@Cacheable</code></p>
<pre><code class="java">    //在第一次查询时会先去缓存看有没有这个key,没有就调用目标方法,最后存在缓存中
    @Cacheable(cacheNames = &quot;emp&quot;, key = &quot;#id&quot;)
    public Account findById(Integer id) &#123;
        System.out.println(&quot;查询&quot; + id + &quot;号账户&quot;);
        return accountMapper.findById(id);
    &#125;

    //在调用目标方法后更新缓存
    @CachePut(value = &quot;emp&quot;, key = &quot;#result.id&quot;)
    public Account updateAccount(Float money, Integer id) &#123;
        accountMapper.updateAccount(money, id);
        return accountMapper.findById(id);

    &#125;
    //调用目标方法后删除缓存
    @CacheEvict(value = &#123;&quot;emp&quot;&#125;, key = &quot;#id&quot;)
    public Integer delEmp(Integer id)&#123;
        System.out.println(&quot;删除员工：&quot;+id);
        employeeMapper.delEmp(id);
        return id;
    &#125;

</code></pre>
</li>
</ol>
<pre><code>
#### 自定义KeyGenerator

可以自定义**key**的生成策略,只需要实现一个`KeyGenerator`将其注入进容器中

```java
@Configuration
public class MyCacheConfig &#123;
 @Bean(&quot;myKeyGenerator&quot;)
 public KeyGenerator myKeyGenerator() &#123;
     return new KeyGenerator()&#123;
        /**
          * @param target 添加注解方法所在类的对象
          * @param method 添加注解的方法
          * @param params 添加注解方法的参数
          * @return
          */
         @Override
         public Object generate(Object target, Method method, Object... params) &#123;
             return method.getName()+&quot;[&quot;+ Arrays.asList(params).toString()+&quot;----&quot;+target+&quot;]&quot;;
         &#125;
     &#125;;
 &#125;
&#125;</code></pre>
<p>在方法上指定<strong>keyGenerator</strong></p>
<pre><code class="java">
   @Cacheable(cacheNames = &quot;emp&quot;,keyGenerator = &quot;myKeyGenerator&quot;)
    public Account findById(Integer id) &#123;
        System.out.println(&quot;查询&quot; + id + &quot;号账户&quot;);
        return accountMapper.findById(id);
    &#125;
</code></pre>
<h4 id="CacheConfig"><a href="#CacheConfig" class="headerlink" title="@CacheConfig"></a><strong>@CacheConfig</strong></h4><p>标注在类上，用于抽取@Cacheable的公共属性</p>
<p>由于一个类中可能会使用多次@Cacheable等注解，所以各项属性可以抽取到@CacheConfig</p>
<pre><code class="java">@CacheConfig(cacheNames = &quot;emp&quot;) //可以在类上标注好公共属性,类方法就可以不用写了</code></pre>
<h4 id="Caching"><a href="#Caching" class="headerlink" title="@Caching"></a><strong>@Caching</strong></h4><p>组合使用<code>@Cacheable</code>、<code>@CachePut</code>、<code>@CacheEvict</code></p>
<pre><code class="java">    @Caching(
            cacheable = &#123;@Cacheable(value = &quot;emp&quot;, key = &quot;#name&quot;)&#125;,
            put = &#123;@CachePut(cacheNames = &quot;emp&quot;, key = &quot;#result.id&quot;)&#125; //调用目标方法后会将保存key:id value:Account的键值对
    )
    public Account findByName(String name) &#123;
        System.out.println(&quot;查询名字为&quot; + name + &quot;的账户&quot;);
        return accountMapper.findByName(name);
    &#125;
</code></pre>
<p>经历过一次查询后，通过<strong>id</strong>查询的时候不会调用<code>findById()</code>方法。由于<code>@CachePut</code>是每次调用方法后执行的，所以<code>findByName()</code>每次调用都会执行</p>
<h3 id="Redis缓存整合"><a href="#Redis缓存整合" class="headerlink" title="Redis缓存整合"></a>Redis缓存整合</h3><h4 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h4><p>导入依赖</p>
<pre><code>       &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;
        &lt;/dependency&gt;</code></pre>
<p>在主配置中指定<strong>Redis</strong>服务器地址（如果不指定就默认为localhost:6739)</p>
<pre><code>#redis服务器主机地址
spring.redis.host=127.0.0.1</code></pre>
<h4 id="2-RedisTemplate"><a href="#2-RedisTemplate" class="headerlink" title="2. RedisTemplate"></a>2. RedisTemplate</h4><p><code>RedisAutoConfiguration</code>向容器中导入了两个bean：<code>RedisTemplate&lt;Object, Object&gt;</code>和<code>StringRedisTemplate</code>，分别操作k-v都为对象和k-v都为字符串的值</p>
<p><strong>Redis常见的五大数据类型</strong></p>
<p>String（字符串）、List（列表）、Set（集合）、Hash（散列）、ZSet（有序集合）</p>
<pre><code class="java"> stringRedisTemplate.opsForValue()[String（字符串）]

 stringRedisTemplate.opsForList()[List（列表）]

 stringRedisTemplate.opsForSet()[Set（集合）]

 stringRedisTemplate.opsForHash()[Hash（散列）]

 stringRedisTemplate.opsForZSet()[ZSet（有序集合）]</code></pre>
<p>当<strong>Redis</strong>存储对象时，默认使用将对象以<strong>jdk序列化数据</strong>的方式存储在redis中，如果要以<strong>Json</strong>的方式来存储数据，可以自定义一个<code>RedisTemplate</code>，将<code>DefaultSerializer</code>设置为<strong>json</strong>格式的序列化器。但这样做有一个缺点就是你如果要对不同的类进行序列化你就要定义多个<code>RedisTemplate</code></p>
<pre><code class="java">//生成一个序列化器为json的redisTemp
@Bean(name = &quot;myRedisTemplate&quot;)
public RedisTemplate MyRedisTemplate(RedisConnectionFactory redisConnectionFactory) &#123;
    RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
    //设置序列化器，序列化对象为Object
    template.setDefaultSerializer(new Jackson2JsonRedisSerializer&lt;Account&gt;(Account.class));
    template.setConnectionFactory(redisConnectionFactory);
    return template;
&#125;</code></pre>
<h4 id="3-Redis缓存使用"><a href="#3-Redis缓存使用" class="headerlink" title="3. Redis缓存使用"></a>3. Redis缓存使用</h4><p>在导入<strong>redis</strong>依赖后<code>org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration</code>类就会自动生效，创建<code>RedisCacheManager</code>，<code>ConcurrentMapCacheManager</code>就不会创建。并使用RedisCache进行缓存数据，要缓存的对象的类要实现Serializable接口，默认情况下是以<strong>jdk序列化数据</strong>存在redis中（以String的形式)， 如下：</p>
<pre><code>k:&quot;emp::1&quot;
v:
\xAC\xED\x00\x05sr\x00$cn.edu.ustc.springboot.bean.Employeeuqf\x03p\x9A\xCF\xE0\x02\x00\x05L\x00\x03dIdt\x00\x13Ljava/lang/Integer;L\x00\x05emailt\x00\x12Ljava/lang/String;L\x00\x06genderq\x00~\x00\x01L\x00\x02idq\x00~\x00\x01L\x00\x08lastNameq\x00~\x00\x02xpsr\x00\x11java.lang.Integer\x12\xE2\xA0\xA4\xF7\x81\x878\x02\x00\x01I\x00\x05valuexr\x00\x10java.lang.Number\x86\xAC\x95\x1D\x0B\x94\xE0\x8B\x02\x00\x00xp\x00\x00\x00\x03t\x00\x07cch@aaasq\x00~\x00\x04\x00\x00\x00\x01q\x00~\x00\x08t\x00\x03cch</code></pre>
<p>要想让对象以<strong>json形式</strong>存储在redis中，需要定义一个<code>org.springframework.data.redis.cache.RedisCacheConfiguration</code>对象放进容器中，使用<code>GenericJackson2JsonRedisSerializer</code>类对<strong>value</strong>进行序列化，并且如果要使配置文件中的配置生效，还要在<code>RedisCacheConfiguration</code>设置各项参数。其实这配置是参考<code>org.springframework.boot.autoconfigure.cache.RedisCacheConfiguration</code>的<code>determineConfiguration()</code>方法来写的</p>
<pre><code class="java">//自定义一个Redis缓存配置，使用Json格式序列化器
@Bean
public RedisCacheConfiguration redisCacheConfiguration(CacheProperties cacheProperties) &#123;
    CacheProperties.Redis redisProperties = cacheProperties.getRedis();
    org.springframework.data.redis.cache.RedisCacheConfiguration config = org.springframework.data.redis.cache.RedisCacheConfiguration
            .defaultCacheConfig();
    config = config.serializeValuesWith(
            RedisSerializationContext.SerializationPair.fromSerializer(new GenericJackson2JsonRedisSerializer()));
    if (redisProperties.getTimeToLive() != null) &#123;
        config = config.entryTtl(redisProperties.getTimeToLive());
    &#125;
    if (redisProperties.getKeyPrefix() != null) &#123;
        config = config.prefixKeysWith(redisProperties.getKeyPrefix());
    &#125;
    if (!redisProperties.isCacheNullValues()) &#123;
        config = config.disableCachingNullValues();
    &#125;
    if (!redisProperties.isUseKeyPrefix()) &#123;
        config = config.disableKeyPrefix();
    &#125;
    return config;
&#125;</code></pre>
<p>序列化数据如下：</p>
<pre><code class="json">k:&quot;emp::1&quot;

v:
&#123;
  &quot;@class&quot;: &quot;com.soda.javabean.Account&quot;,
  &quot;id&quot;: 1,
  &quot;name&quot;: &quot;aaa&quot;,
  &quot;money&quot;: 200.0
&#125;</code></pre>
<p><strong>注意</strong>，这里必须用<code>GenericJackson2JsonRedisSerializer</code>进行value的序列化解析，如果使用<code>Jackson2JsonRedisSerializer</code>，则只能转换指定的一种类对象。</p>
<h4 id="4-Redis缓存原理"><a href="#4-Redis缓存原理" class="headerlink" title="4. Redis缓存原理"></a>4. Redis缓存原理</h4><p>配置类<code>RedisCacheConfiguration</code>向容器中导入了其定制的RedisCacheManager，在默认的RedisCacheManager的配置中，是使用jdk序列化value值</p>
<pre><code>@Configuration(proxyBeanMethods = false)
@ConditionalOnClass(RedisConnectionFactory.class)
@AutoConfigureAfter(RedisAutoConfiguration.class)
@ConditionalOnBean(RedisConnectionFactory.class)
@ConditionalOnMissingBean(CacheManager.class)
@Conditional(CacheCondition.class)
class RedisCacheConfiguration &#123;

    //向容器中导入RedisCacheManager
    @Bean
    RedisCacheManager cacheManager(CacheProperties cacheProperties, CacheManagerCustomizers cacheManagerCustomizers,
            ObjectProvider&lt;org.springframework.data.redis.cache.RedisCacheConfiguration&gt; redisCacheConfiguration,
            ObjectProvider&lt;RedisCacheManagerBuilderCustomizer&gt; redisCacheManagerBuilderCustomizers,
            RedisConnectionFactory redisConnectionFactory, ResourceLoader resourceLoader) &#123;
        //使用determineConfiguration()的返回值生成RedisCacheManagerBuilder
        //调用了RedisCacheManagerBuilder的cacheDefaults()方法(见下一代码块)
        RedisCacheManagerBuilder builder = RedisCacheManager.builder(redisConnectionFactory).cacheDefaults(
                determineConfiguration(cacheProperties, redisCacheConfiguration, resourceLoader.getClassLoader()));
        List&lt;String&gt; cacheNames = cacheProperties.getCacheNames();
        if (!cacheNames.isEmpty()) &#123;
            builder.initialCacheNames(new LinkedHashSet&lt;&gt;(cacheNames));
        &#125;
        redisCacheManagerBuilderCustomizers.orderedStream().forEach((customizer) -&gt; customizer.customize(builder));
        //使用RedisCacheManagerBuilder的build()方法创建RedisCacheManager并进行定制操作
        return cacheManagerCustomizers.customize(builder.build());
    &#125;


    private org.springframework.data.redis.cache.RedisCacheConfiguration determineConfiguration(
            CacheProperties cacheProperties,
            ObjectProvider&lt;org.springframework.data.redis.cache.RedisCacheConfiguration&gt; redisCacheConfiguration,
            ClassLoader classLoader) &#123;
        //如果容器中存在RedisCacheConfiguration就直接返回，否则调用RedisCacheConfiguration()创建
        return redisCacheConfiguration.getIfAvailable(() -&gt; createConfiguration(cacheProperties, classLoader));
    &#125;


    //createConfiguration()定义了其序列化value的规则
    private org.springframework.data.redis.cache.RedisCacheConfiguration createConfiguration(
            CacheProperties cacheProperties, ClassLoader classLoader) &#123;
        Redis redisProperties = cacheProperties.getRedis();
        org.springframework.data.redis.cache.RedisCacheConfiguration config = org.springframework.data.redis.cache.RedisCacheConfiguration
                .defaultCacheConfig();
        //使用jdk序列化器对value进行序列化
        config = config.serializeValuesWith(
                SerializationPair.fromSerializer(new JdkSerializationRedisSerializer(classLoader)));
        //设置properties文件中设置的各项属性
        if (redisProperties.getTimeToLive() != null) &#123;
            config = config.entryTtl(redisProperties.getTimeToLive());
        &#125;
        if (redisProperties.getKeyPrefix() != null) &#123;
            config = config.prefixKeysWith(redisProperties.getKeyPrefix());
        &#125;
        if (!redisProperties.isCacheNullValues()) &#123;
            config = config.disableCachingNullValues();
        &#125;
        if (!redisProperties.isUseKeyPrefix()) &#123;
            config = config.disableKeyPrefix();
        &#125;
        return config;
    &#125;

&#125;</code></pre>
<p>RedisCacheManager的直接构造类，该类保存了配置类RedisCacheConfiguration，该配置在会传递给RedisCacheManager</p>
<pre><code>public static class RedisCacheManagerBuilder &#123;

        private final RedisCacheWriter cacheWriter;
        //默认缓存配置使用RedisCacheConfiguration的默认配置
        //该默认配置缓存时默认将k按字符串存储，v按jdk序列化数据存储(见下一代码块)
        private RedisCacheConfiguration defaultCacheConfiguration = RedisCacheConfiguration.defaultCacheConfig();
        private final Map&lt;String, RedisCacheConfiguration&gt; initialCaches = new LinkedHashMap&lt;&gt;();
        private boolean enableTransactions;
        boolean allowInFlightCacheCreation = true;

        private RedisCacheManagerBuilder(RedisCacheWriter cacheWriter) &#123;
            this.cacheWriter = cacheWriter;
        &#125;


        //传入RedisCacheManagerBuilder使用的缓存配置规则RedisCacheConfiguration类
        public RedisCacheManagerBuilder cacheDefaults(RedisCacheConfiguration defaultCacheConfiguration) &#123;

            Assert.notNull(defaultCacheConfiguration, &quot;DefaultCacheConfiguration must not be null!&quot;);

            this.defaultCacheConfiguration = defaultCacheConfiguration;

            return this;
        &#125;


    //使用默认defaultCacheConfiguration创建RedisCacheManager
    public RedisCacheManager build() &#123;

            RedisCacheManager cm = new RedisCacheManager(cacheWriter, defaultCacheConfiguration, initialCaches,
                    allowInFlightCacheCreation);

            cm.setTransactionAware(enableTransactions);

            return cm;
        &#125;</code></pre>
<p>RedisCacheConfiguration保存了许多缓存规则，这些规则都保存在RedisCacheManagerBuilder的RedisCacheConfiguration defaultCacheConfiguration属性中，并且当RedisCacheManagerBuilder创建RedisCacheManager传递过去</p>
<pre><code>public class RedisCacheConfiguration &#123;

    private final Duration ttl;
    private final boolean cacheNullValues;
    private final CacheKeyPrefix keyPrefix;
    private final boolean usePrefix;

    private final SerializationPair&lt;String&gt; keySerializationPair;
    private final SerializationPair&lt;Object&gt; valueSerializationPair;

    private final ConversionService conversionService;

    //默认缓存配置
    public static RedisCacheConfiguration defaultCacheConfig(@Nullable ClassLoader classLoader) &#123;

            DefaultFormattingConversionService conversionService = new DefaultFormattingConversionService();

            registerDefaultConverters(conversionService);

            return new RedisCacheConfiguration(Duration.ZERO, true, true, CacheKeyPrefix.simple(),
                                     SerializationPair.fromSerializer(RedisSerializer.string()),//key使用字符串
                                               SerializationPair.fromSerializer(RedisSerializer.java(classLoader)), conversionService);
        //value按jdk序列化存储
    &#125;</code></pre>
<p>RedisCacheManager在创建RedisCache时将RedisCacheConfiguration传递过去，并在创建RedisCache时通过createRedisCache()起作用</p>
<pre><code>public class RedisCacheManager extends AbstractTransactionSupportingCacheManager &#123;

    private final RedisCacheWriter cacheWriter;
    private final RedisCacheConfiguration defaultCacheConfig;
    private final Map&lt;String, RedisCacheConfiguration&gt; initialCacheConfiguration;
    private final boolean allowInFlightCacheCreation;

        protected RedisCache createRedisCache(String name, @Nullable RedisCacheConfiguration cacheConfig) &#123;
        //如果调用该方法时RedisCacheConfiguration有值则使用定制的，否则则使用默认的RedisCacheConfiguration defaultCacheConfig，即RedisCacheManagerBuilder传递过来的配置
        return new RedisCache(name, cacheWriter, cacheConfig != null ? cacheConfig : defaultCacheConfig);
    &#125;</code></pre>
<p>RedisCache，Redis缓存，具体负责将缓存数据序列化的地方，将RedisCacheConfiguration的序列化对SerializationPair提取出来并使用其定义的序列化方式分别对k和v进行序列化操作</p>
<pre><code>public class RedisCache extends AbstractValueAdaptingCache &#123;

    private static final byte[] BINARY_NULL_VALUE = RedisSerializer.java().serialize(NullValue.INSTANCE);

    private final String name;
    private final RedisCacheWriter cacheWriter;
    private final RedisCacheConfiguration cacheConfig;
    private final ConversionService conversionService;

    public void put(Object key, @Nullable Object value) &#123;

        Object cacheValue = preProcessCacheValue(value);

        if (!isAllowNullValues() &amp;&amp; cacheValue == null) &#123;

            throw new IllegalArgumentException(String.format(
                    &quot;Cache &#39;%s&#39; does not allow &#39;null&#39; values. Avoid storing null via &#39;@Cacheable(unless=\&quot;#result == null\&quot;)&#39; or configure RedisCache to allow &#39;null&#39; via RedisCacheConfiguration.&quot;,
                    name));
        &#125;

        //在put k-v时使用cacheConfig中的k-v序列化器分别对k-v进行序列化
        cacheWriter.put(name, createAndConvertCacheKey(key), serializeCacheValue(cacheValue), cacheConfig.getTtl());
    &#125;

    //从cacheConfig(即RedisCacheConfiguration)中获取KeySerializationPair并写入key值
    protected byte[] serializeCacheKey(String cacheKey) &#123;
        return ByteUtils.getBytes(cacheConfig.getKeySerializationPair().write(cacheKey));
    &#125;


    //从cacheConfig(即RedisCacheConfiguration)中获取ValueSerializationPair并写入key值
    protected byte[] serializeCacheValue(Object value) &#123;

        if (isAllowNullValues() &amp;&amp; value instanceof NullValue) &#123;
            return BINARY_NULL_VALUE;
        &#125;

        return ByteUtils.getBytes(cacheConfig.getValueSerializationPair().write(value));
    &#125;</code></pre>
<p>分析到这也就不难理解，要使用json保存序列化数据时，需要自定义RedisCacheConfiguration，在RedisCacheConfiguration中定义序列化转化规则，并向RedisCacheManager传入我们自己定制的RedisCacheConfiguration了，我定制的序列化规则会跟随RedisCacheConfiguration一直传递到RedisCache，并在序列化时发挥作用。</p>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot数据访问</title>
    <url>/2020/11/04/spring/spring-boot/2020-11-4-spring-boot%E6%95%B0%E6%8D%AE%E8%AE%BF%E9%97%AE/</url>
    <content><![CDATA[<h2 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h2><pre><code class="xml">        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-jdbc&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;</code></pre>
<pre><code class="yaml">spring:
  datasource:
    username: root
    password: 123456
    url: jdbc:mysql://192.168.15.22:3306/database?serverTimezone=Asia/Shanghai #要加上时区,不然会报错
    driver-class-name: com.mysql.jdbc.Driver</code></pre>
<p>效果：</p>
<p>​    默认是用org.apache.tomcat.jdbc.pool.DataSource作为数据源；</p>
<p>​    数据源的相关配置都在DataSourceProperties里面；</p>
<p>自动配置原理：</p>
<p>org.springframework.boot.autoconfigure.jdbc：</p>
<p>1、参考DataSourceConfiguration，根据配置创建数据源，默认使用Tomcat连接池；可以使用spring.datasource.type指定自定义的数据源类型；</p>
<p>2、SpringBoot默认可以支持；</p>
<pre><code>org.apache.tomcat.jdbc.pool.DataSource、HikariDataSource、BasicDataSource、</code></pre>
<p>3、自定义数据源类型</p>
<pre><code class="java">/**
 * Generic DataSource configuration.
 */
@ConditionalOnMissingBean(DataSource.class)
@ConditionalOnProperty(name = &quot;spring.datasource.type&quot;)
static class Generic &#123;

   @Bean
   public DataSource dataSource(DataSourceProperties properties) &#123;
       //使用DataSourceBuilder创建数据源，利用反射创建响应type的数据源，并且绑定相关属性
      return properties.initializeDataSourceBuilder().build();
   &#125;

&#125;</code></pre>
<p>4、<strong>DataSourceInitializer：ApplicationListener</strong>；</p>
<p>​    作用：</p>
<p>​        1）、runSchemaScripts();运行建表语句；</p>
<p>​        2）、runDataScripts();运行插入数据的sql语句；</p>
<p>默认只需要将文件命名为：</p>
<pre><code class="properties">schema-*.sql、data-*.sql
默认规则：schema.sql，schema-all.sql；
可以使用   
    schema:
      - classpath:department.sql
      指定位置</code></pre>
<p>5、操作数据库：自动配置了JdbcTemplate操作数据库</p>
<h2 id="整合Druid数据源"><a href="#整合Druid数据源" class="headerlink" title="整合Druid数据源"></a>整合Druid数据源</h2><pre><code class="java">导入druid数据源
@Configuration
public class DruidConfig &#123;

    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)
    @Bean
    public DataSource druid()&#123;
       return  new DruidDataSource();
    &#125;

    //配置Druid的监控
    //1、配置一个管理后台的Servlet
    @Bean
    public ServletRegistrationBean statViewServlet()&#123;
        ServletRegistrationBean bean = new ServletRegistrationBean(new StatViewServlet(), &quot;/druid/*&quot;);
        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();

        initParams.put(&quot;loginUsername&quot;,&quot;admin&quot;);
        initParams.put(&quot;loginPassword&quot;,&quot;123456&quot;);
        initParams.put(&quot;allow&quot;,&quot;&quot;);//默认就是允许所有访问
        initParams.put(&quot;deny&quot;,&quot;192.168.15.21&quot;);

        bean.setInitParameters(initParams);
        return bean;
    &#125;


    //2、配置一个web监控的filter
    @Bean
    public FilterRegistrationBean webStatFilter()&#123;
        FilterRegistrationBean bean = new FilterRegistrationBean();
        bean.setFilter(new WebStatFilter());

        Map&lt;String,String&gt; initParams = new HashMap&lt;&gt;();
        initParams.put(&quot;exclusions&quot;,&quot;*.js,*.css,/druid/*&quot;);

        bean.setInitParameters(initParams);

        bean.setUrlPatterns(Arrays.asList(&quot;/*&quot;));

        return  bean;
    &#125;
&#125;
</code></pre>
<h2 id="整合MyBatis"><a href="#整合MyBatis" class="headerlink" title="整合MyBatis"></a>整合MyBatis</h2><pre><code class="xml">         &lt;dependency&gt;
            &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;
            &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;
            &lt;version&gt;2.1.3&lt;/version&gt;
        &lt;/dependency&gt;</code></pre>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180305194443.png" loading="lazy"></p>
<p>步骤：</p>
<p>​    1）、配置数据源相关属性（见上一节Druid）</p>
<p>​    2）、给数据库建表</p>
<p>​    3）、创建JavaBean</p>
<h3 id="注解版"><a href="#注解版" class="headerlink" title="注解版"></a>注解版</h3><pre><code class="java">//指定这是一个操作数据库的mapper
@Mapper
public interface DepartmentMapper &#123;

    @Select(&quot;select * from department where id=#&#123;id&#125;&quot;)
    public Department getDeptById(Integer id);

    @Delete(&quot;delete from department where id=#&#123;id&#125;&quot;)
    public int deleteDeptById(Integer id);

    @Options(useGeneratedKeys = true,keyProperty = &quot;id&quot;)
    @Insert(&quot;insert into department(departmentName) values(#&#123;departmentName&#125;)&quot;)
    public int insertDept(Department department);

    @Update(&quot;update department set departmentName=#&#123;departmentName&#125; where id=#&#123;id&#125;&quot;)
    public int updateDept(Department department);
&#125;</code></pre>
<p>问题：</p>
<p>自定义MyBatis的配置规则；给容器中添加一个ConfigurationCustomizer；</p>
<pre><code class="java">@org.springframework.context.annotation.Configuration
public class MyBatisConfig &#123;

    @Bean
    public ConfigurationCustomizer configurationCustomizer()&#123;
        return new ConfigurationCustomizer()&#123;

            @Override
            public void customize(Configuration configuration) &#123;
                configuration.setMapUnderscoreToCamelCase(true);
            &#125;
        &#125;;
    &#125;
&#125;</code></pre>
<pre><code class="java">使用MapperScan批量扫描所有的Mapper接口；
@MapperScan(value = &quot;com.atguigu.springboot.mapper&quot;)
@SpringBootApplication
public class SpringBoot06DataMybatisApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(SpringBoot06DataMybatisApplication.class, args);
    &#125;
&#125;</code></pre>
<h3 id="配置文件版"><a href="#配置文件版" class="headerlink" title="配置文件版"></a>配置文件版</h3><pre><code class="yaml">mybatis:
  config-location: classpath:mybatis/mybatis-config.xml #指定全局配置文件的位置 可以不用,主配置文件中就可以进行配置
  mapper-locations: classpath:mapper/*.xml  #指定sql映射文件的位置
  type-aliases-package: com.soda.javabean #别名包</code></pre>
<p>更多使用参照</p>
<p><a href="http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/">http://www.mybatis.org/spring-boot-starter/mybatis-spring-boot-autoconfigure/</a></p>
<p>主程序</p>
<pre><code class="java">@SpringBootApplication
@MapperScan(value = &quot;com.soda.mapper&quot;)
public class MybatisDemoApplication &#123;

    public static void main(String[] args) &#123;
        SpringApplication.run(MybatisDemoApplication.class, args);
    &#125;

&#125;</code></pre>
<p>mapper.xml</p>
<pre><code class="xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE mapper
        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;
        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;com.soda.mapper.AccountMapper&quot;&gt;

    &lt;select id=&quot;findById&quot; resultType=&quot;Account&quot; &gt;
      select * from account where id = #&#123;id&#125;
    &lt;/select&gt;

    &lt;select id=&quot;findAll&quot; resultType=&quot;List&quot;&gt;
        select * from account
    &lt;/select&gt;
    &lt;!--useGeneratedKeys:插入成功后获取主键
        keyProperty: 设置主键--&gt;
    &lt;insert id=&quot;insertAccount&quot; useGeneratedKeys=&quot;true&quot; keyProperty=&quot;id&quot;&gt;
        insert into account (id, name, money) values (null, #&#123;name&#125;, #&#123;money&#125;);
    &lt;/insert&gt;
&lt;/mapper&gt;</code></pre>
<h2 id="整合SpringData-JPA"><a href="#整合SpringData-JPA" class="headerlink" title="整合SpringData JPA"></a>整合SpringData JPA</h2><h3 id="SpringData简介"><a href="#SpringData简介" class="headerlink" title="SpringData简介"></a>SpringData简介</h3><p><img src="https://raw.githubusercontent.com/soda1/img/main/%E6%90%9C%E7%8B%97%E6%88%AA%E5%9B%BE20180306105412.png" loading="lazy"></p>
<h3 id="整合SpringData-JPA-1"><a href="#整合SpringData-JPA-1" class="headerlink" title="整合SpringData JPA"></a>整合SpringData JPA</h3><p>JPA:ORM（Object Relational Mapping）；</p>
<p>1）、编写一个实体类（bean）和数据表进行映射，并且配置好映射关系；</p>
<pre><code class="java">//使用JPA注解配置映射关系
@Entity //告诉JPA这是一个实体类（和数据表映射的类）
@Table(name = &quot;tbl_user&quot;) //@Table来指定和哪个数据表对应;如果省略默认表名就是user；
public class User &#123;

    @Id //这是一个主键
    @GeneratedValue(strategy = GenerationType.IDENTITY)//自增主键
    private Integer id;

    @Column(name = &quot;last_name&quot;,length = 50) //这是和数据表对应的一个列
    private String lastName;
    @Column //省略默认列名就是属性名
    private String email;</code></pre>
<p>2）、编写一个Dao接口来操作实体类对应的数据表（Repository）</p>
<pre><code class="java">//继承JpaRepository来完成对数据库的操作
public interface UserRepository extends JpaRepository&lt;User,Integer&gt; &#123;
&#125;
</code></pre>
<p>3）、基本的配置JpaProperties</p>
<pre><code class="yaml">spring:  
 jpa:
    hibernate:
#     更新或者创建数据表结构
      ddl-auto: update
#    控制台显示SQL
    show-sql: true</code></pre>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot消息整合</title>
    <url>/2020/11/05/spring/spring-boot/2020-11-5-spring-boot%E4%B8%8E%E6%B6%88%E6%81%AF/</url>
    <content><![CDATA[<h3 id="一、消息简介"><a href="#一、消息简介" class="headerlink" title="一、消息简介"></a>一、消息简介</h3><h4 id="消息代理规范"><a href="#消息代理规范" class="headerlink" title="消息代理规范"></a>消息代理规范</h4><ul>
<li>JMS（Java Message Service）JAVA消息服务<ul>
<li>基于JVM消息代理的规范。ActiveMQ、HornetMQ是JMS实现</li>
</ul>
</li>
<li>AMQP（Advanced Message Queuing Protocol）<ul>
<li>高级消息队列协议，也是一个消息代理的规范，兼容JMS</li>
<li>RabbitMQ是AMQP的实现</li>
</ul>
</li>
</ul>
<h4 id="JMS与AMQP对比"><a href="#JMS与AMQP对比" class="headerlink" title="JMS与AMQP对比"></a>JMS与AMQP对比</h4><table>
<thead>
<tr>
<th></th>
<th>JMS</th>
<th>AMQP</th>
</tr>
</thead>
<tbody><tr>
<td>定义</td>
<td>Java  api</td>
<td>网络线级协议</td>
</tr>
<tr>
<td>跨语言</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>跨平台</td>
<td>否</td>
<td>是</td>
</tr>
<tr>
<td>Model</td>
<td>提供两种消息模型：  （1）、Peer-2-Peer  （2）、Pub/sub</td>
<td>提供了五种消息模型：  （1）、direct  exchange  （2）、fanout  exchange  （3）、topic  change  （4）、headers  exchange  （5）、system  exchange  本质来讲，后四种和JMS的pub/sub模型没有太大差别，仅是在路由机制上做了更详细的划分；</td>
</tr>
<tr>
<td>支持消息类型</td>
<td>多种消息类型：  TextMessage  MapMessage  BytesMessage  StreamMessage  ObjectMessage  Message  （只有消息头和属性）</td>
<td>byte[]  当实际应用时，有复杂的消息，可以将消息序列化后发送。</td>
</tr>
<tr>
<td>综合评价</td>
<td>JMS  定义了JAVA  API层面的标准；在java体系中，多个client均可以通过JMS进行交互，不需要应用修改代码，但是其对跨平台的支持较差；</td>
<td>AMQP定义了wire-level层的协议标准；天然具有跨平台、跨语言特性。</td>
</tr>
</tbody></table>
<h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a><strong>作用</strong></h4><p>通过消息服务中间件来提升系统异步通信、扩展解耦能力</p>
<p>当消息发送者发送消息以后，将由消息代理接管，消息代理保证消息传递到指定目的地</p>
<h4 id="消息队列的形式"><a href="#消息队列的形式" class="headerlink" title="消息队列的形式"></a>消息队列的形式</h4><p>消息队列主要有两种形式的目的地</p>
<ol>
<li><p>队列（queue）：点对点消息通信（point-to-point）</p>
<p>消息发送者发送消息，消息代理将其放入一个队列中，消息接收者从队列中获取消息内容，消息读取后被移出队列。消息只有唯一的发送者和接受者，但并不是说只能有一个接收者</p>
</li>
<li><p>主题（topic）：发布（publish）/订阅（subscribe）消息通信</p>
<p>发送者（发布者）发送消息到主题，多个接收者（订阅者）监听（订阅）这个主题，那么就会在消息到达时同时收到消息</p>
</li>
</ol>
<h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a><strong>应用场景</strong></h4><ol>
<li><p>异步处理</p>
<p> 用户注册操作和消息处理并行，提高响应速度</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31302f30332f6e624a4e34357a36443375457339372e706e67" alt="img" loading="lazy"></p>
</li>
</ol>
<ol start="2">
<li><p>应用解耦</p>
<p>在下单时库存系统不能正常使用。也不影响正常下单，因为下单后，订单系统写入消息队列就不再关心其他的后续操作了。实现订单系统与库存系统的应用解耦</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31302f30332f484d6b346f4b664243736a6d3263592e706e67" alt="img" loading="lazy"></p>
</li>
<li><p>流量削峰</p>
<p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面</p>
<p>秒杀业务根据消息队列中的请求信息，再做后续处理</p>
</li>
</ol>
<h2 id="二、RabbitMQ"><a href="#二、RabbitMQ" class="headerlink" title="二、RabbitMQ"></a>二、RabbitMQ</h2><p>RabbitMQ是一个由erlang开发的AMQP(Advanved Message Queue Protocol)的开源实现。</p>
<h3 id="1-核心概念"><a href="#1-核心概念" class="headerlink" title="1. 核心概念"></a>1. 核心概念</h3><ul>
<li><strong>Message</strong><ul>
<li>消息，消息是不具名的，它由消息头和消息体组成</li>
<li>消息头，包括routing-key（路由键）、priority（相对于其他消息的优先权）、delivery-mode（指出该消息可能需要持久性存储）等</li>
</ul>
</li>
<li><strong>Publisher</strong><ul>
<li>消息的生产者，也是一个向交换器发布消息的客户端应用程序</li>
</ul>
</li>
<li><strong>Exchange</strong><ul>
<li>交换器，将生产者消息路由给服务器中的队列</li>
<li>类型有direct(默认)，fanout, topic, 和headers，具有不同转发策略</li>
</ul>
</li>
<li><strong>Queue</strong><ul>
<li>消息队列，保存消息直到发送给消费者</li>
</ul>
</li>
<li><strong>Binding</strong><ul>
<li>绑定，用于消息队列和交换器之间的关联</li>
</ul>
</li>
<li><strong>Connection</strong><ul>
<li>网络连接，比如一个TCP连接</li>
</ul>
</li>
<li><strong>Consumer</strong><ul>
<li>消息的消费者，表示一个从消息队列中取得消息的客户端应用程序</li>
</ul>
</li>
<li><strong>Virtual Host</strong><ul>
<li>虚拟主机，表示一批交换器、消息队列和相关对象。</li>
<li>vhost 是 AMQP 概念的基础，必须在连接时指定</li>
<li>RabbitMQ 默认的 vhost 是 /</li>
</ul>
</li>
<li><strong>Broker</strong><ul>
<li>消息队列服务器实体</li>
</ul>
</li>
</ul>
<h3 id="2-运行机制"><a href="#2-运行机制" class="headerlink" title="2. 运行机制"></a>2. 运行机制</h3><p><strong>消息路由</strong></p>
<p>AMQP 中增加了Exchange 和 Binding 的角色， Binding 决定交换器的消息应该发送到那个队列</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/image-20201105180407445.png" alt="image-20201105180407445" loading="lazy"></p>
<p><strong>Exchange 类型</strong></p>
<ol>
<li><p><strong>direct</strong></p>
<p>点对点模式，消息中的路由键（routing key）如果和 Binding 中的 binding key 一致， 交换器就将消息发到对应的队列中。</p>
</li>
<li><p><strong>fanout</strong></p>
<p>广播模式，每个发到 fanout 类型交换器的消息都会分到所有绑定的队列上去</p>
</li>
<li><p><strong>topic</strong></p>
<p>将路由键和某个模式进行匹配，此时队列需要绑定到一个模式上。它将路由键和绑定键的字符串切分成单词，这些单词之间用点隔开。 识别通配符： # 匹配 0 个或多个单词， *匹配一个单词</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/68747470733a2f2f692e6c6f6c692e6e65742f323032302f31302f30332f715754516f35617a637869684156552e706e67" alt="img" loading="lazy"></p>
</li>
</ol>
<h2 id="三、-Springboot中的RabbitMQ"><a href="#三、-Springboot中的RabbitMQ" class="headerlink" title="三、 Springboot中的RabbitMQ"></a>三、 Springboot中的RabbitMQ</h2><h3 id="1-环境准备"><a href="#1-环境准备" class="headerlink" title="1. 环境准备"></a>1. 环境准备</h3><p>在docker中安装rabbitmq并运行</p>
<pre><code># 5672为服务端口，15672为web控制台端口
docker run -d -p 5672:5672 -p 15672:15672 38e57f281891</code></pre>
<p>如果要修改账号密码</p>
<pre><code>1、进入docker 的 RabbitMQ 容器中
docker exec -it rabbitmq01 bash

2、查看用户
rabbitmqctl list_users

3、修改密码
rabbitmqctl change_password userName newPassword

4、如果不想要guest的账号也可以新增账号
 rabbitmqctl add_user userName newPassword

5、看guest不爽，你还可以delete它
rabbitmqctl delete_user guest

6、最后别忘了给自己添加的账号增加超级管理员权限
rabbitmqctl set_user_tags userName administrator</code></pre>
<p>导入依赖</p>
<pre><code class="xml">    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-amqp&lt;/artifactId&gt;
    &lt;/dependency&gt;
    &lt;!--自定义消息转化器Jackson2JsonMessageConverter所需依赖--&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;
        &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;
    &lt;/dependency&gt;</code></pre>
<p>配置文件</p>
<pre><code class="yml">spring:
  rabbitmq:
    host: localhost # 指定rebbitmq服务器主机
    username: guest #默认值为guest
    password: guest #默认值为guest
    port: 5672      #默认值为5672</code></pre>
<h3 id="2-RabbitMQ客户端API"><a href="#2-RabbitMQ客户端API" class="headerlink" title="2. RabbitMQ客户端API"></a>2. RabbitMQ客户端API</h3><p><code>RabbitAutoConfiguration</code>中有内部类<code>RabbitTemplateConfiguration</code>,在该类中向容器中分别导入了<code>RabbitTemplate</code>和<code>AmqpAdmin</code></p>
<p>在测试类中分别注入</p>
<pre><code>    @Autowired
    private RabbitTemplate rabbitTemplate;

    @Autowired
    private AmqpAdmin amqpAdmin;</code></pre>
<ul>
<li><p><strong>RabbitTemplate消息发送处理组件</strong></p>
<p> 可用来发送和接收消息</p>
<pre><code class="java">        //发送消息
        rabbitTemplate.convertAndSend(&quot;amq.direct&quot;,&quot;ustc&quot;,&quot;aaaa&quot;);
        Book book = new Book();
        book.setName(&quot;西游记&quot;);
        book.setPrice(23.2f);
        //Book要实现Serializable接口
        //exchage:amq.direct key:ustc message:book
        rabbitTemplate.convertAndSend(&quot;amq.direct&quot;,&quot;ustc&quot;,book);

        //接收消息
        //queue:amp.queue
        Object o = rabbitTemplate.receiveAndConvert(&quot;amp.queue&quot;);
        System.out.println(o.getClass());  //class cn.edu.ustc.springboot.bean.Book
        System.out.println(o);            //Book&#123;name=&#39;西游记&#39;, price=23.2&#125;</code></pre>
<p>默认的消息转化器是<code>SimpleMessageConverter</code>，对于对象以<strong>jdk</strong>序列化方式存储，若要以<strong>Json</strong>方式存储对象，就要自定义消息转换器</p>
<pre><code class="java">@Configuration
public class AmqpConfig &#123;
    @Bean
    public MessageConverter messageConverter() &#123;
        //在容器中导入Json的消息转换器
        return new Jackson2JsonMessageConverter();
    &#125;
&#125;</code></pre>
</li>
<li><p><strong>AmqpAdmin管理组件</strong></p>
<p> 用于创建和删除<strong>exchange</strong>、<strong>binding</strong>和<strong>queue</strong></p>
<pre><code class="java">//创建Direct类型的Exchange
amqpAdmin.declareExchange(new DirectExchange(&quot;admin.direct&quot;));
//创建Queue
amqpAdmin.declareQueue(new Queue(&quot;admin.test&quot;));
//将创建的队列与Exchange绑定
amqpAdmin.declareBinding(new Binding(&quot;admin.test&quot;, Binding.DestinationType.QUEUE,&quot;admin.direct&quot;,&quot;admin.test&quot;,null));</code></pre>
<p>也可以自定义组件</p>
<pre><code class="java">//定义一个queue
@Bean(&quot;consumerQueue&quot;)
public Queue getQueue() &#123;
 return new Queue(&quot;soda.queue&quot;, true);
&#125;

//定义一个exchange
@Bean(&quot;consumerExchange&quot;)
public Exchange getChange() &#123;
    return new DirectExchange(&quot;soda.exchange&quot;, true, false);
&#125;
//queue与exchange进行绑定，route key 为：soda.test
@Bean
public Binding binding(@Qualifier(&quot;consumerQueue&quot;) Queue queue, @Qualifier(&quot;consumerExchange&quot;) Exchange exchange) &#123;
    return BindingBuilder.bind(queue).to(exchange).with(&quot;soda.test&quot;).noargs();
&#125;</code></pre>
</li>
</ul>
<h3 id="3-消息的监听"><a href="#3-消息的监听" class="headerlink" title="3.消息的监听"></a>3.消息的监听</h3><ul>
<li><p>在回调方法上标注<code>@RabbitListener</code>注解，并设置其属性<strong>queues</strong>，注册监听队列，当该队列收到消息时，标注方法遍会调用</p>
</li>
<li><p>可分别使用<strong>Message</strong>和保存消息所属对象进行消息接收，若使用<strong>Object</strong>对象进行消息接收，实际上接收到的也是<strong>Message</strong></p>
</li>
<li><p>如果知道接收的消息是何种类型的对象，可在方法参数中直接加上该类型参数，也可接收到</p>
<pre><code class="java">import org.springframework.amqp.rabbit.annotation.RabbitListener;
import org.springframework.context.annotation.Configuration;

@Configuration
public class myListener &#123;

    @RabbitListener(queues = &#123;&quot;soda.queue&quot;&#125;)
    public void receive1(Object object, Message message)&#123;

        System.out.println(message == object); //true
    &#125;

    @RabbitListener(queues = &#123;&quot;soda.queue&quot;&#125;)
    public void receive3( String string)&#123;
        System.out.println(&quot;收到消息: &quot; + string);

    &#125;
&#125;</code></pre>
</li>
<li><p>若消息中含有不同的对象，可以使用<code>@RabbitHandler</code>进行分别接收</p>
<pre><code class="java">@RabbitListener(queues = &#123;&quot;admin.test&quot;&#125;)
@Service
public class BookService &#123;

    @RabbitHandler
    public void receive4(Book book)&#123;
        System.out.println(&quot;4收到消息：book:&quot; + book);
    &#125;

    @RabbitHandler
    public void receive5(Student student)&#123;
        System.out.println(&quot;5收到消息：student:&quot; + student);
    &#125;</code></pre>
</li>
</ul>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot事务</title>
    <url>/2020/12/01/spring/spring-boot/2020-12-01-spring%E4%BA%8B%E5%8A%A1/</url>
    <content><![CDATA[<h2 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h2><h3 id="一、Spring事务特点"><a href="#一、Spring事务特点" class="headerlink" title="一、Spring事务特点"></a>一、Spring事务特点</h3><ol>
<li><p>跨不同事务API的统一的编程模型，无论你使用的是jdbc、jta、jpa、hibernate。</p>
</li>
<li><p>支持声明式事务</p>
</li>
<li><p>简单的事务管理API</p>
</li>
<li><p>能与spring的数据访问抽象层完美集成</p>
</li>
</ol>
<p>spring事务是由AOP实现的</p>
<h3 id="二、配置"><a href="#二、配置" class="headerlink" title="二、配置"></a>二、配置</h3><h4 id="1、使用xml配置"><a href="#1、使用xml配置" class="headerlink" title="1、使用xml配置"></a>1、使用xml配置</h4><p>使用spring boot就不写了</p>
<h4 id="2、使用注解"><a href="#2、使用注解" class="headerlink" title="2、使用注解"></a>2、使用注解</h4><h5 id="Transaction注解"><a href="#Transaction注解" class="headerlink" title="@Transaction注解"></a>@Transaction注解</h5><table>
<thead>
<tr>
<th align="left">属性名</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">name</td>
<td align="left">当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。</td>
</tr>
<tr>
<td align="left">propagation</td>
<td align="left">事务的传播行为，默认值为 REQUIRED。</td>
</tr>
<tr>
<td align="left">isolation</td>
<td align="left">事务的隔离度，默认值采用 DEFAULT。</td>
</tr>
<tr>
<td align="left">timeout</td>
<td align="left">事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。</td>
</tr>
<tr>
<td align="left">read-only</td>
<td align="left">指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。</td>
</tr>
<tr>
<td align="left">rollback-for</td>
<td align="left">用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。</td>
</tr>
<tr>
<td align="left">no-rollback- for</td>
<td align="left">抛出 no-rollback-for 指定的异常类型，不回滚事务。</td>
</tr>
</tbody></table>
<p>@Transaction注解可以添加方法及类上，添加在类上表示所有的公共方法具有相同的事务事务属性</p>
<h5 id="事务传播属性"><a href="#事务传播属性" class="headerlink" title="事务传播属性"></a>事务传播属性</h5><ul>
<li><p><strong>REQUIRED</strong></p>
<p>这是默认的传播属性，如果外部调用方有事务，将会加入到事务，没有的话新建一个。</p>
</li>
<li><p><strong>PROPAGATION_SUPPORTS</strong></p>
<p>如果当前存在事务，则加入到该事务；如果当前没有事务，则以非事务的方式继续运行。</p>
</li>
<li><p><strong>PROPAGATION_NOT_SUPPORTED</strong></p>
<p>以非事务方式运行，如果当前存在事务，则把当前事务挂起。</p>
</li>
<li><p><strong>PROPAGATION_NEVER</strong></p>
<p>以非事务方式运行，如果当前存在事务，则抛出异常。</p>
</li>
</ul>
<h3 id="三、Spring-的注解方式的事务实现机制"><a href="#三、Spring-的注解方式的事务实现机制" class="headerlink" title="三、Spring 的注解方式的事务实现机制"></a>三、Spring 的注解方式的事务实现机制</h3><p><strong>这一章节抄至网络</strong></p>
<p>在应用系统调用声明@Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据@Transactional 的属性配置信息，这个代理对象决定该声明@Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截，在 TransactionInterceptor 拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器(图 2 有相关介绍)AbstractPlatformTransactionManager 操作数据源 DataSource 提交或回滚事务,</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201201215011.png" loading="lazy"></p>
<p>Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种，图 1 是以 CglibAopProxy 为例，对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。对于 JdkDynamicAopProxy，需要调用其 invoke 方法。</p>
<p>正如上文提到的，事务管理的框架是由抽象事务管理器 AbstractPlatformTransactionManager 来提供的，而具体的底层事务处理实现，由 PlatformTransactionManager 的具体实现类来实现，如事务管理器 DataSourceTransactionManager。不同的事务管理器管理不同的数据资源 DataSource，比如 DataSourceTransactionManager 管理 JDBC 的 Connection。</p>
<p>PlatformTransactionManager，AbstractPlatformTransactionManager 及具体实现类关系如图 2 所示。</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20201201215222.png" loading="lazy"></p>
<h3 id="四、事务的一些结论"><a href="#四、事务的一些结论" class="headerlink" title="四、事务的一些结论"></a>四、事务的一些结论</h3><ol>
<li><p>在一个类中使用非事务方法来调用事务方法，事务无法起作用</p>
<p>在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有@Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略，不会发生回滚。</p>
</li>
<li><p>@Transactional 只能应用到 public 方法才有效</p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot自定义拦截器</title>
    <url>/2021/03/12/spring/spring-boot/2021_03_12-%E6%8B%A6%E6%88%AA%E5%99%A8/</url>
    <content><![CDATA[<h4 id="多个拦截器执行顺序"><a href="#多个拦截器执行顺序" class="headerlink" title="多个拦截器执行顺序"></a>多个拦截器执行顺序</h4><ol>
<li><p>定义2个拦截器</p>
<pre><code class="java">public class Interceptor1 implements HandlerInterceptor &#123;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        System.out.println(&quot;执行拦截器1前置方法&quot;);
        return true;
    &#125;

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;执行拦截器1post方法&quot;);
    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

        System.out.println(&quot;执行拦截器1 completion 方法&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="java">public class Interceptor2 implements HandlerInterceptor &#123;
    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123;

        System.out.println(&quot;执行拦截器2前置方法&quot;);
        return true;
    &#125;

    @Override
    public void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView) throws Exception &#123;
        System.out.println(&quot;执行拦截器2post方法&quot;);
    &#125;

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception &#123;

        System.out.println(&quot;执行拦截器2 completion 方法&quot;);
    &#125;
&#125;</code></pre>
</li>
<li><p>配置WebConfig</p>
<pre><code class="java">@Configuration
public class WebMVCConfig implements WebMvcConfigurer &#123;

    @Override
    public void addInterceptors(InterceptorRegistry registry) &#123;
        registry.addInterceptor(new Interceptor1()).order(1).addPathPatterns(&quot;/**&quot;);
        registry.addInterceptor(new Interceptor2()).order(2).addPathPatterns(&quot;/**&quot;);

    &#125;
&#125;</code></pre>
</li>
<li><p>执行结果</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210312200802.png" alt="image-20210312200802140" loading="lazy"></p>
</li>
</ol>
<p>   执行顺序按配置的order参数决定，数字越小执行越靠前</p>
<p>   如果不设置order参数，那么将由代码顺序来决定谁先执行</p>
<ol start="4">
<li><p>多拦截器执行模型</p>
<ul>
<li>前置方法，靠前的拦截器先执行</li>
<li>Post、Completion方法，靠后的拦截器先执行</li>
</ul>
</li>
<li><p>拦截器返回false</p>
<p>设置拦截器1前置方法返回false</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210312201907.png" alt="image-20210312201907538" loading="lazy"></p>
<p>结果只执行了拦截器一的前置方法就不再执行下去了。前端也无法返回任何信息</p>
</li>
</ol>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot redis配置</title>
    <url>/2021/02/22/spring/spring-boot/2021_03_30-redis%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="配置RedisConnectionFactory"><a href="#配置RedisConnectionFactory" class="headerlink" title="配置RedisConnectionFactory"></a>配置RedisConnectionFactory</h4><p>redis有两个开源的客户端连接，分别为jedis（非线程安全）及lettuce（线程安全）,spring 2.0之后采用的默认客户端是lettuce，下面是LettuceConnectionFactory的简单配置</p>
<pre><code class="java">@Bean
public LettuceConnectionFactory myLettuce() &#123;
    LettuceConnectionFactory lettuceConnectionFactory = new LettuceConnectionFactory();
    //设置数据库
    lettuceConnectionFactory.setDatabase(1);
    return lettuceConnectionFactory;
&#125;</code></pre>
<h4 id="配置RedisTemplate"><a href="#配置RedisTemplate" class="headerlink" title="配置RedisTemplate"></a>配置RedisTemplate</h4><p><code>RedisTemplate</code>是redis的操作api</p>
<pre><code>@Bean(&quot;redisTemplate&quot;)
public RedisTemplate getRedis(LettuceConnectionFactory lettuceConnectionFactory) &#123;
    RedisTemplate redisTemplate = new RedisTemplate();
    //构造器参数：反序列化时的对象信息
    Jackson2JsonRedisSerializer jackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer(User.class);
    redisTemplate.setKeySerializer(new Jackson2JsonRedisSerializer(String.class));
    redisTemplate.setValueSerializer(jackson2JsonRedisSerializer);
    //设置hash类型键值对序列化器
    redisTemplate.setHashKeySerializer(new Jackson2JsonRedisSerializer&lt;&gt;(String.class));
    redisTemplate.setHashValueSerializer(new Jackson2JsonRedisSerializer&lt;&gt;(User.class));
       //配置redis连接
       redisTemplate.setConnectionFactory(lettuceConnectionFactory);

    return redisTemplate;
&#125;</code></pre>
<ul>
<li><p>bean的取名为<code>redisTemplate</code>是因为redis自动配置时会去检查有没有这个名字的bean，如果没有就会再创建一个<code>RedisTemplate</code>对象到容器中，这样就只能使用<code>@Resource</code>来指定要获取的对象</p>
<pre><code class="java">@Bean
@ConditionalOnMissingBean(name = &quot;redisTemplate&quot;)
public RedisTemplate&lt;Object, Object&gt; redisTemplate(RedisConnectionFactory redisConnectionFactory)
      throws UnknownHostException &#123;
   RedisTemplate&lt;Object, Object&gt; template = new RedisTemplate&lt;&gt;();
   template.setConnectionFactory(redisConnectionFactory);
   return template;
&#125;</code></pre>
</li>
<li><p>redis支持多种序列化器，<code>org.springframework.data.redis.serializer</code>包下有源数据及用户自定义的序列化器</p>
<p><img src="https://raw.githubusercontent.com/soda1/img/main/20210331170332.png" alt="image-20210331170331834" loading="lazy"></p>
</li>
</ul>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
  <entry>
    <title>spring boot rabbitmq配置</title>
    <url>/2021/04/04/spring/spring-boot/2021_04_04-spring-boot-rabbitmq%E9%85%8D%E7%BD%AE/</url>
    <content><![CDATA[<h4 id="注册配置"><a href="#注册配置" class="headerlink" title="注册配置"></a>注册配置</h4><pre><code class="yml">spring:
  rabbitmq:
    host: localhost 
    username: guest 
    password: guest 
    port: 5672</code></pre>
<h4 id="Listener配置"><a href="#Listener配置" class="headerlink" title="Listener配置"></a>Listener配置</h4><p>listener有两个容器，分别是direct和simple，springboot默认使用simple容器，选用另外一个配置如下</p>
<pre><code class="yml">spring:
  rabbitmq:
    listener:
      type: direct</code></pre>
<p>下列所有配置以simple容器为例</p>
<h5 id="listener重试配置"><a href="#listener重试配置" class="headerlink" title="listener重试配置"></a>listener重试配置</h5><pre><code class="yml">spring:
  rabbitmq:
    listener:
      simple:
        acknowledge-mode: auto #手动确认消息
        retry: #重试机制
          enabled: true #开启
          initial-interval: 5000ms #重试间隔
          max-attempts: 3 #最大重试数
          max-interval: 10000ms #最大重试间隔</code></pre>
<p>注意：</p>
<ul>
<li>重试机制下<strong>acknowledge-mode</strong>属性必须为auto，开启手动确认就不会触发重试机制。</li>
<li>listener必须<strong>抛出错误</strong>才能触发重试。</li>
</ul>
]]></content>
      <categories>
        <category>spring boot</category>
      </categories>
  </entry>
</search>
