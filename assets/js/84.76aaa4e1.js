(window.webpackJsonp=window.webpackJsonp||[]).push([[84],{403:function(t,v,a){"use strict";a.r(v);var _=a(7),s=Object(_.a)({},(function(){var t=this,v=t._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h4",{attrs:{id:"重构规模"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#重构规模"}},[t._v("#")]),t._v(" 重构规模")]),t._v(" "),v("h5",{attrs:{id:"大规模重构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#大规模重构"}},[t._v("#")]),t._v(" 大规模重构")]),t._v(" "),v("ul",[v("li",[t._v("重构手段有：分层、模块化、解耦、抽象可复用组件")]),t._v(" "),v("li",[t._v("改动大，易引入bug，重构时需要有完善的计划")])]),t._v(" "),v("h5",{attrs:{id:"小规模重构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#小规模重构"}},[t._v("#")]),t._v(" 小规模重构")]),t._v(" "),v("ul",[v("li",[t._v("主要指代码细节的重构，针对类，函数，变量的代码级别重构。一般根据编程规范作为指导即可")]),t._v(" "),v("li",[t._v("改动小且比较集中，风险小。如果觉得需要重构就可以直接着手")])]),t._v(" "),v("h4",{attrs:{id:"单元测试"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#单元测试"}},[t._v("#")]),t._v(" 单元测试")]),t._v(" "),v("ol",[v("li",[t._v("它是保证代码重构时不出错的有效保证")]),t._v(" "),v("li",[t._v("编写单元测试能帮你发现设计上的问题，如果一段代码很难去编写单元测试，往往会意味着代码的设计不够合理，比如说使用了静态方法、没有依赖注入等等，进而促使你去重构代码")]),t._v(" "),v("li",[t._v("单元测试可以帮助你快速熟悉代码")]),t._v(" "),v("li",[t._v("单元测试是TDD可落地执行的改进方案")])]),t._v(" "),v("h5",{attrs:{id:"常见的anti-patterns"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#常见的anti-patterns"}},[t._v("#")]),t._v(" 常见的anti-patterns")]),t._v(" "),v("ol",[v("li",[t._v("未决行为（代码输出具有随机性）")]),t._v(" "),v("li",[t._v("全局变量（滥用全局变量会使测试变得困难，每个测试用例可能都要重置全局变量）")]),t._v(" "),v("li",[t._v("静态方法（静态方法比较难mock，比如依赖外部资源的静态函数）")]),t._v(" "),v("li",[t._v("复杂继承（如果一个父类需要mock某个依赖对象才能进行单元测试，那么所有子类在编写单元测试的时候都要去mock这个对象）")]),t._v(" "),v("li",[t._v("高耦合代码（一个类依赖很多外部对象，可能也需要mock这些外部对象，这本身设计不合理）")])]),t._v(" "),v("h4",{attrs:{id:"解耦技巧"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#解耦技巧"}},[t._v("#")]),t._v(" 解耦技巧")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("封装与抽象")]),t._v(" "),v("p",[t._v("当功能改动时，上层依赖不需要改动")])]),t._v(" "),v("li",[v("p",[t._v("引用中间层")]),t._v(" "),v("p",[t._v("通过中间层来简化依赖关系")]),t._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20221211234625.png",alt:"image-20221211234618738"}})])]),t._v(" "),v("li",[v("p",[t._v("模块化")]),t._v(" "),v("p",[t._v("构建复杂系统的主要手段，相关人员只要专注于自己负责的模块即可")])]),t._v(" "),v("li",[v("p",[t._v("利用设计思想和原则")]),t._v(" "),v("ul",[v("li",[t._v("单一职责原则")]),t._v(" "),v("li",[t._v("基于接口而非实现编程")]),t._v(" "),v("li",[t._v("依赖注入")]),t._v(" "),v("li",[t._v("多用组合少用继承")]),t._v(" "),v("li",[t._v("迪米特法则")])])])]),t._v(" "),v("h4",{attrs:{id:"编程规范"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#编程规范"}},[t._v("#")]),t._v(" 编程规范")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("命名")]),t._v(" "),v("ul",[v("li",[t._v("命名的关键是能准确达意。对于不同作用域的命名，我们可以适当地选择不同的长度。作用域小的变量（比如临时变量），可以适当地选择短一些的命名方式。除此之外，命名中也可以使用一些耳熟能详的缩写。")]),t._v(" "),v("li",[t._v("我们可以借助类的信息来简化属性、函数的命名，利用函数的信息来简化函数参数的命名。")]),t._v(" "),v("li",[t._v("命名要可读、可搜索。不要使用生僻的、不好读的英文单词来命名。除此之外，命名要符合项目的统一规范，不要用些反直觉的命名。")]),t._v(" "),v("li",[t._v("接口有两种命名方式：一种是在接口中带前缀“I”；另一种是在接口的实现类中带后缀“Impl”。对于抽象类的命名，也有两种方式，一种是带上前缀“Abstract”，一种是不带前缀。这两种命名方式都可以，关键是要在项目中统一。")])])]),t._v(" "),v("li",[v("p",[t._v("注释")]),t._v(" "),v("ul",[v("li",[t._v("注释的目的就是让代码更容易看懂。只要符合这个要求的内容，你就可以将它写到注释里。总结一下，注释的内容主要包含这样三个方面：做什么、为什么、怎么做。对于一些复杂的类和接口，我们可能还需要写明“如何用”。")]),t._v(" "),v("li",[t._v("注释本身有一定的维护成本，所以并非越多越好。类和函数一定要写注释，而且要写得尽可能全面、详细，而函数内部的注释要相对少一些，一般都是靠好的命名、提炼函数、解释性变量、总结性注释来提高代码可读性。")])])]),t._v(" "),v("li",[v("p",[t._v("函数的代码不要超过一屏幕大小，类比较难确定")])]),t._v(" "),v("li",[v("p",[t._v("一行代码不要超过IDE显示宽度")])]),t._v(" "),v("li",[v("p",[t._v("善用空行分割单元块")])]),t._v(" "),v("li",[v("p",[t._v("把代码分割成更小的单元块")])]),t._v(" "),v("li",[v("p",[t._v("函数参数不要过多，大于五个就有点多")]),t._v(" "),v("ul",[v("li",[t._v("考虑函数职责是否单一，能否拆成多个函数的方式来减少参数")]),t._v(" "),v("li",[t._v("封装成对象")])])]),t._v(" "),v("li",[v("p",[t._v("勿用函数参数来控制逻辑，尽量拆成多个函数")])]),t._v(" "),v("li",[v("p",[t._v("函数设计要职责单一")])]),t._v(" "),v("li",[v("p",[t._v("移除过深嵌套层次")]),t._v(" "),v("ul",[v("li",[t._v("去掉多余if/else语句")]),t._v(" "),v("li",[t._v("使用关键字continue，break，return提前退出嵌套")]),t._v(" "),v("li",[t._v("调整执行顺序，判断逻辑（如判空）放在前面")]),t._v(" "),v("li",[t._v("将部分嵌套逻辑封装成函数")])])]),t._v(" "),v("li",[v("p",[t._v("学会使用解释性变量")]),t._v(" "),v("ul",[v("li",[v("p",[t._v("常量代替魔法数字")])]),t._v(" "),v("li",[v("p",[t._v("使用解释性变量来解释负责表达式")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("boolean")]),t._v(" isSummer "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" date"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("after")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SUMMER_START")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v("date"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("before")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token constant"}},[t._v("SUMMER_END")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])])])])])])])}),[],!1,null,null,null);v.default=s.exports}}]);