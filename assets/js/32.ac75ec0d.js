(window.webpackJsonp=window.webpackJsonp||[]).push([[32],{351:function(e,t,a){"use strict";a.r(t);var r=a(7),o=Object(r.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h4",{attrs:{id:"结构图"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#结构图"}},[e._v("#")]),e._v(" 结构图")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20230310143101.png",alt:""}})]),e._v(" "),t("p",[e._v("JVM架构如图所示，主要分为ClassLoader Subsystem， Runtime Data Area，Execution Engine")]),e._v(" "),t("h4",{attrs:{id:"classloader-subsystem"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#classloader-subsystem"}},[e._v("#")]),e._v(" ClassLoader Subsystem")]),e._v(" "),t("p",[e._v("它的职能主要是动态加载创建类对象，类在第一次被引用时就需要创建类对象，一个类对象被创建包含Loading、Linking、initialization三个阶段。")]),e._v(" "),t("h5",{attrs:{id:"loading"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#loading"}},[e._v("#")]),e._v(" Loading")]),e._v(" "),t("p",[e._v("在Loading阶段有3个类加载器用来加载Class文件")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("BootStrap ClassLoader（启动类加载器）")]),e._v(" "),t("p",[e._v("加载"),t("code",[e._v("$JAVA_HOME/jre/lib")]),e._v("路径的核心类（rt.jar etc)，它是所有加载器的顶级父类")])]),e._v(" "),t("li",[t("p",[e._v("Extension ClassLoader（扩展类加载器）")]),e._v(" "),t("p",[e._v("加载"),t("code",[e._v("$JAVA_HOME/jre/lib/ext")]),e._v("路径下的类或在系统属性"),t("code",[e._v("java.ext.dirs")]),e._v("列出的目录，它的上层父类是BootStrap ClassLoader")])]),e._v(" "),t("li",[t("p",[e._v("Application ClassLoader（应用程序类加载器）")]),e._v(" "),t("p",[e._v("现在叫做System ClassLoader，用于加载应用路径下的类，它的上层父类是Extension ClassLoader")])])]),e._v(" "),t("h5",{attrs:{id:"delegation-hierarchy-algorithm"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#delegation-hierarchy-algorithm"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Delegation Hierarchy Algorithm")])]),e._v(" "),t("p",[e._v("中文习惯叫双亲委派机制，哪个家伙起的名，真的谢谢。"),t("strong",[e._v("主要思想就是在需要加载一个类的时候优先由其父类加载器进行尝试加载，如果父类加载器不能加载才有当前类路径下的加载器进行加载")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20230310173929.jpg",alt:""}})]),e._v(" "),t("p",[e._v("目的：避免同一个类被多次加载，保证Java稳定允许")]),e._v(" "),t("h5",{attrs:{id:"linking"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#linking"}},[e._v("#")]),e._v(" Linking")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("Verify")]),e._v(" "),t("p",[e._v("验证class文件中的字节流是否符合虚拟机的要求，包括有"),t("strong",[e._v("文件格式的验证，元数据的验证，字节码验证，符号引用验证")])])]),e._v(" "),t("li",[t("p",[e._v("Prepare")]),e._v(" "),t("p",[e._v("对静态变量进行内存分配，并赋予初始值")])]),e._v(" "),t("li",[t("p",[e._v("Resolve")]),e._v(" "),t("p",[e._v("将方法区对象内的运行时常量池中的符号引用解析成直接引用")]),e._v(" "),t("blockquote",[t("p",[e._v("When a Java class is compiled, all references to variables and methods are stored in the class's constant pool as a symbolic reference. A symbolic reference is a logical reference not a reference that actually points to a physical memory location. The JVM implementation can choose when to resolve symbolic references, this can happen when the class file is verified, after being loaded, called eager or static resolution, instead this can happen when the symbolic reference is used for the first time called lazy or late resolution. However the JVM has to behave as if the resolution occurred when each reference is first used and throw any resolution errors at this point. Binding is the process of the field, method or class identified by the symbolic reference being replaced by a direct reference, this only happens once because the symbolic reference is completely replaced. If the symbolic reference refers to a class that has not yet been resolved then this class will be loaded. Each direct reference is stored as an offset against the storage structure associated with the runtime location of the variable or method.")])])])]),e._v(" "),t("h5",{attrs:{id:"initialization"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#initialization"}},[e._v("#")]),e._v(" Initialization")]),e._v(" "),t("p",[e._v("所有静态变量都会被赋予初始值，静态代码块将会被执行")]),e._v(" "),t("h4",{attrs:{id:"runtime-data-area"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#runtime-data-area"}},[e._v("#")]),e._v(" Runtime Data Area")]),e._v(" "),t("p",[e._v("这个是Java内存管理区域，以下图分析会比较清晰")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20230311015106.png",alt:""}})]),e._v(" "),t("p",[t("strong",[e._v("Non Heap")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("method area")]),e._v(" "),t("p",[e._v("方法区用于存储每个Class对象的信息：")]),e._v(" "),t("ul",[t("li",[e._v("Classloader Reference")]),e._v(" "),t("li",[e._v("Field data")]),e._v(" "),t("li",[e._v("Run Time Constant Pool")]),e._v(" "),t("li",[e._v("Method data")]),e._v(" "),t("li",[e._v("Method code")])])]),e._v(" "),t("li",[t("p",[e._v("interned String 字符串常量池，在1.8版本它被移到Heap里面了")])])]),e._v(" "),t("p",[e._v("**Heap **")]),e._v(" "),t("p",[e._v("所有的对象实例都会存储在堆这里，为所有线程共享")]),e._v(" "),t("p",[e._v("generation及垃圾回收内容查看"),t("a",{attrs:{href:"#Garbage-Collector"}},[e._v("Garbage Collector")])]),e._v(" "),t("p",[t("strong",[e._v("Stack")])]),e._v(" "),t("p",[e._v("每个线程都有以下三个组件")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("Program Counter")]),e._v(" "),t("p",[e._v("PC用于存储当前指令运行位置的，如果当前调用的native方法，那么PC值为undefine，JVM用PC来跟踪其执行指令位置，方便在线程在获得cpu时间片后继续运行下去")])]),e._v(" "),t("li",[t("p",[e._v("Stack")]),e._v(" "),t("p",[e._v("按照先进后出规则执行，由存储调用方法的栈帧组成，每个栈帧包含如下信息：")]),e._v(" "),t("ul",[t("li",[e._v("本地变量数组（基本类型，对象引用）")]),e._v(" "),t("li",[e._v("返回值")]),e._v(" "),t("li",[e._v("操作数栈")]),e._v(" "),t("li",[e._v("执行方法地址")])])]),e._v(" "),t("li",[t("p",[e._v("Native Stack")]),e._v(" "),t("p",[e._v("类似于Stack")])])]),e._v(" "),t("h4",{attrs:{id:"execution-engine"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#execution-engine"}},[e._v("#")]),e._v(" Execution Engine")]),e._v(" "),t("h5",{attrs:{id:"interpreter"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#interpreter"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Interpreter")])]),e._v(" "),t("p",[e._v("用于解释字节码，将其转换成系统识别指令，使其能运行。缺点在于每次执行方法都要先解释一遍")]),e._v(" "),t("h5",{attrs:{id:"jit-compiler"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#jit-compiler"}},[e._v("#")]),e._v(" "),t("strong",[e._v("JIT Compiler")])]),e._v(" "),t("p",[e._v("用于改正解释器缺点，当代码第一次运行时会使用解释器来解释代码，后面如果发现有重复代码时，会使用JIT编译器，将代码编译成native code。native code将直接用于重复方法的调用，从而提高系统性能")]),e._v(" "),t("h5",{attrs:{id:"garbage-collector"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#garbage-collector"}},[e._v("#")]),e._v(" "),t("strong",[e._v("Garbage Collector")])]),e._v(" "),t("p",[e._v("垃圾回收器用于回收无用对象，从而释放内存，防止内存泄露。Java中的垃圾回收是自动的，也可以通过调用"),t("code",[e._v("System.gc()")]),e._v("来触发")]),e._v(" "),t("h6",{attrs:{id:"无用对象定义"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#无用对象定义"}},[e._v("#")]),e._v(" "),t("strong",[e._v("无用对象定义")])]),e._v(" "),t("p",[e._v("在Java中有一些对象被称为 "),t("strong",[e._v("Garbage Collection Roots")]),e._v("（GC Roots)，它们在垃圾回收中被作为Root对象来用于进行可达性分析。如下图所示，如果一个对象和任何GC Root间不存在"),t("strong",[e._v("引用链")]),e._v("，那么就说明该对象是无用对象")]),e._v(" "),t("blockquote",[t("p",[e._v("Every object tree must have one or more root objects. As long as the application can reach those roots, the whole tree is reachable.But when are those root objects considered reachable? Special objects called garbage-collection roots (GC roots; see Figure below) are always reachable and so is any object that has a garbage-collection root at its own root.")])]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20230311031540.jpg",alt:""}})]),e._v(" "),t("p",[e._v("有4种类型GC Roots")]),e._v(" "),t("ul",[t("li",[e._v("Local variables")]),e._v(" "),t("li",[e._v("Static variables")]),e._v(" "),t("li",[e._v("Active Java threads")]),e._v(" "),t("li",[e._v("JNI References")])]),e._v(" "),t("p",[t("strong",[e._v("回收器针对Java引用类型回收策略")])]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Strong Reference（强引用）")]),e._v(" "),t("p",[e._v("只要可达GC root就不会回收")])]),e._v(" "),t("li",[t("p",[e._v("Soft Reference（软引用）")]),e._v(" "),t("p",[e._v("内存空间不足的时候就会被回收")])]),e._v(" "),t("li",[t("p",[e._v("Weak Reference（弱应用）")]),e._v(" "),t("p",[e._v("只要被垃圾回收期扫描到就会回收")])]),e._v(" "),t("li",[t("p",[e._v("Phantom Reference（虚引用）")]),e._v(" "),t("p",[e._v("任何时候都会被回收")])])]),e._v(" "),t("h6",{attrs:{id:"垃圾回收算法"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[e._v("#")]),e._v(" 垃圾回收算法")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("标记 — 清除算法")]),e._v(" "),t("p",[e._v("将可回收对象先标记出来，然后再清除。这种算法会造成内存碎片，导致本来有足够的容量来分配给新的对象，但却无法分配")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20230311033334.png",alt:""}})])]),e._v(" "),t("li",[t("p",[e._v("复制算法")]),e._v(" "),t("p",[e._v("复制算法从标记-清除算法演进而来，解决了内存碎片化问题。将内存分为均等两块，每次只用一块，当一块内存用完时，就将存活的对象搬到另一块去，然后把直接清理内存空间。算法的弊端在于只能使用一半的内存")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20230311033405.png",alt:""}})])]),e._v(" "),t("li",[t("p",[e._v("标记整理算法")]),e._v(" "),t("p",[e._v("标记整理算法中标记过程和标记清除算法一致，然后整理时存活对象会向一端移动，最后清除存活对象边界以外的内存区域。由于内存的频繁移动，在效率上会比复制算法差")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20230311033431.png",alt:""}})])])]),e._v(" "),t("h6",{attrs:{id:"垃圾回收"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收"}},[e._v("#")]),e._v(" 垃圾回收")]),e._v(" "),t("p",[e._v("大多数对象的生命周期都是非常短的，只有少部分的对象会一直存在，因此JVM将Heap分成了几部分，如下面官方图所示")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20230311160312.png",alt:""}})]),e._v(" "),t("ul",[t("li",[t("p",[e._v("Young Generation")]),e._v(" "),t("p",[e._v("新创建对象会被分配在年轻代的Eden区里面，当Eden区满后会触发Minor GC，存活下来的对象会进入Survivor区且被标记年龄 = 1，而原先在Survivor区继续存活下来的对象则年龄+1，然后将Eden区清空")]),e._v(" "),t("p",[e._v("Survivor区又细分为S0和S1两个区，原因在于Survivor区的对象也会有被清理掉的可能性，这样会产生内存碎片，JVM采用了复制算法来整理内存")]),e._v(" "),t("p",[e._v("在经历多轮的GC后，Survivor中存活的对象一旦达到年轻代设置的年龄上限后会进入老年代，还有一些特殊的情况会直接进入老年区：")]),e._v(" "),t("ul",[t("li",[e._v("当对象无法放入Survivor区")]),e._v(" "),t("li",[e._v("当大对象无法放入清理后的Eden区")])]),e._v(" "),t("p",[e._v("年轻代Minor GC具体流程查看"),t("a",{attrs:{href:"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java Garbage Collection Basics"),t("OutboundLink")],1)])]),e._v(" "),t("li",[t("p",[e._v("Old Generation")]),e._v(" "),t("p",[e._v("老年代用于放置长期存活的对象，当老年代无法存放新的对象时会触发Major GC，对老年代进行垃圾回收，释放内存")])]),e._v(" "),t("li",[t("p",[e._v("Permanent generation")]),e._v(" "),t("p",[e._v("永久代存储的是Class对象及方法，对应JVM结构中的方法区，触发Full GC时会对永久代进行垃圾回收")]),e._v(" "),t("p",[e._v("永久代不属于Heap，上面的官方图是从generation的角度来解释其内存结构，下面图可以很好描述")]),e._v(" "),t("p",[t("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20230311171414.png",alt:""}})]),e._v(" "),t("p",[e._v("在1.8版本使用 Meta space来替代Permanent generation")])])]),e._v(" "),t("h6",{attrs:{id:"垃圾回收器"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收器"}},[e._v("#")]),e._v(" 垃圾回收器")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("The Serial GC")]),e._v(" "),t("p",[e._v("串行化收集器，Minor 和Major GC都是串行进行的，即单线程。使用标记整理算法，存在Stop The World问题")]),e._v(" "),t("p",[e._v("应用场景：适合客户端模式下的虚拟机（需要比较少的内存）")]),e._v(" "),t("p",[e._v("使用："),t("code",[e._v("-XX:+UseSerialGC")])])]),e._v(" "),t("li",[t("p",[e._v("The Parallel GC")]),e._v(" "),t("p",[e._v("并行收集器使用多线程来对年轻代进行垃圾回收，默认使用CPU个数的线程进程回收，存在Stop The World问题")]),e._v(" "),t("p",[e._v("应用场景：适用于追求高吞吐量，不需要太多交互")]),e._v(" "),t("p",[e._v("使用：")]),e._v(" "),t("ul",[t("li",[t("code",[e._v("-XX:+UseParallelGC")]),e._v("：年轻代回收使用多线程，老年代回收使用的单线程")]),e._v(" "),t("li",[t("code",[e._v("-XX:+UseParallelOldGC")]),e._v("：年轻代老年代都是用多线程")])]),e._v(" "),t("p",[e._v("老年代都使用标记-整理算法，年轻代用复制算法")])]),e._v(" "),t("li",[t("p",[e._v("The Concurrent Mark Sweep (CMS) Collector")]),e._v(" "),t("p",[e._v("CMS是一种以并发的方式进行垃圾回收，以最短回收卡顿时间为目标的收集器，主要用于老年代，采用标记-清除算法，会造成碎片化问题，引发Full GC，导致临时使用Serial GC进行老年代垃圾回收")]),e._v(" "),t("p",[e._v("CMS用于年轻代时和并行收集器采用同样算法")]),e._v(" "),t("p",[e._v("应用场景：重视服务器响应速度，要求系统停顿时间最短。")]),e._v(" "),t("p",[e._v("使用："),t("code",[e._v("-XX:+UseConcMarkSweepGC")])])]),e._v(" "),t("li",[t("p",[e._v("The G1 Garbage Collector")]),e._v(" "),t("p",[e._v("G1收集器设计用于取代CMS，具有并发、并行，低卡顿时间等特点。G1整体来看使用标记-整理算法，局部使用复制算法")]),e._v(" "),t("p",[e._v("应用场景：面向服务端应用")]),e._v(" "),t("p",[e._v("使用："),t("code",[e._v("-XX:+UseG1GC")])])])]),e._v(" "),t("p",[e._v("参考：")]),e._v(" "),t("p",[t("a",{attrs:{href:"https://dzone.com/articles/jvm-architecture-explained",title:"The JVM Architecture Explained",target:"_blank",rel:"noopener noreferrer"}},[e._v("The JVM Architecture Explained"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://blog.jamesdbloom.com/JVMInternals.html",title:"JVM Internals",target:"_blank",rel:"noopener noreferrer"}},[e._v("JVM Internals"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://dzone.com/articles/jvm-memory-architecture-and-gc",title:"JVM Memory Architecture and GC Algorithm Basics",target:"_blank",rel:"noopener noreferrer"}},[e._v("JVM Memory Architecture and GC Algorithm Basics"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://dzone.com/articles/java-memory-management",title:"Java Memory Management",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java Memory Management"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.w3resource.com/java-tutorial/garbage-collection-in-java.php",title:"Garbage Collection in Java",target:"_blank",rel:"noopener noreferrer"}},[e._v("Garbage Collection in Java"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html",title:"Java Garbage Collection Basics",target:"_blank",rel:"noopener noreferrer"}},[e._v("Java Garbage Collection Basics"),t("OutboundLink")],1)]),e._v(" "),t("p",[t("a",{attrs:{href:"https://blog.jamesdbloom.com/JVMInternals.html",title:"JVM Internals",target:"_blank",rel:"noopener noreferrer"}},[t("OutboundLink")],1)])])}),[],!1,null,null,null);t.default=o.exports}}]);