(window.webpackJsonp=window.webpackJsonp||[]).push([[55],{374:function(v,_,e){"use strict";e.r(_);var t=e(7),l=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h4",{attrs:{id:"缓存穿透"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存穿透"}},[v._v("#")]),v._v(" 缓存穿透")]),v._v(" "),_("p",[v._v("当大量的请求的key没有落在redis的缓存上时，从而直接请求数据库，导致数据库压力瞬间增大。")]),v._v(" "),_("p",[v._v("解决方法")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("缓存不存在的key，并设置过期时间。如果key是变化的，那么起到的作用是比较小的")])]),v._v(" "),_("li",[_("p",[v._v("布隆过滤器")]),v._v(" "),_("p",[v._v("具体做法就是将所有可能存在的key放在布隆过滤器中，当请求过滤时，现在布隆过滤器中查找请求的key是否存在，存在就走正常缓存查询流程，不存在就直接返回错误信息。")]),v._v(" "),_("p",[_("strong",[v._v("判断一个元素是否存在于布隆过滤器的时候，进行的操作：")])]),v._v(" "),_("ol",[_("li",[_("p",[v._v("对给定元素再次进行相同的哈希计算；")])]),v._v(" "),_("li",[_("p",[v._v("得到值之后判断位数组中的每个元素是否都为 1，如果值都为 1，那么说明这个值在布隆过滤器中，如果存在一个值不为 1，说明该元素不在布隆过滤器中。")])])]),v._v(" "),_("p",[v._v("从布隆过滤器判断元素是否存在的操作可以知道一定会有不同的key计算出来的hash是相同的，因此会出现误判的情况。")]),v._v(" "),_("p",[v._v("总结就是"),_("strong",[v._v("布隆过滤器会存在小概率误判的情况，如果判定key不存在那么它就一定是不存在的。")])])])]),v._v(" "),_("h4",{attrs:{id:"缓存雪崩"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存雪崩"}},[v._v("#")]),v._v(" 缓存雪崩")]),v._v(" "),_("p",[v._v("缓存雪崩描述的是"),_("strong",[v._v("缓存中大量数据同时失效，导致大量的请求直接请求数据库，让数据库短时间压力突然增大，从而可能引发宕机的情况")]),v._v("。")]),v._v(" "),_("p",[v._v("解决方法")]),v._v(" "),_("ol",[_("li",[v._v("采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。")]),v._v(" "),_("li",[v._v("限流，避免同时处理大量的请求。")])]),v._v(" "),_("h4",{attrs:{id:"缓存一致性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓存一致性"}},[v._v("#")]),v._v(" 缓存一致性")]),v._v(" "),_("p",[v._v("当数据发生改变时，为了让数据库和缓存中数据保持一致性，推荐的做法是采用"),_("strong",[v._v("Cache Aside Pattern")]),v._v("（旁路缓存模式）:")]),v._v(" "),_("p",[v._v("对于读请求：")]),v._v(" "),_("ul",[_("li",[v._v("读cache，cache hit，返回数据；cache miss，读db，set cache 再返回再读db")])]),v._v(" "),_("p",[v._v("对于写请求：")]),v._v(" "),_("ol",[_("li",[v._v("操作数据库")]),v._v(" "),_("li",[v._v("delete cache")])]),v._v(" "),_("p",[v._v("思考:")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("写请求为什么不是set缓存而是delete缓存")]),v._v(" "),_("p",[v._v("并发写情况下，无论是先操作数据库还是先set更新，都有可能出现缓存不一致的情况")]),v._v(" "),_("ol",[_("li",[v._v("请求1先操作数据库，请求2后操作数据库")]),v._v(" "),_("li",[v._v("请求2先更新缓存，请求1后更新缓存")])])]),v._v(" "),_("li",[_("p",[v._v("对于写请求为什么先操作数据库")]),v._v(" "),_("p",[v._v("并发读写情况下，如果先delete缓存，会出现缓存不一致的情况")]),v._v(" "),_("ol",[_("li",[v._v("写请求delete缓存")]),v._v(" "),_("li",[v._v("写请求操作数据库（主从同步没有完成）")]),v._v(" "),_("li",[v._v("读请求读cache（cache miss）")]),v._v(" "),_("li",[v._v("读请求读取从库（旧数据）")]),v._v(" "),_("li",[v._v("读请求set cache（旧数据）")]),v._v(" "),_("li",[v._v("主从同步完成")])])]),v._v(" "),_("li",[_("p",[v._v("对于写请求先操作数据库是否完美？")]),v._v(" "),_("p",[v._v("先操作数据库也会存在数据库操作成功，delete cache缓存失败的情况，常用的解决方法就是采用重试机制(比如rabbitmq的消息机制）来delete cache。")])])])])}),[],!1,null,null,null);_.default=l.exports}}]);