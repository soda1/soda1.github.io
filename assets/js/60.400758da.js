(window.webpackJsonp=window.webpackJsonp||[]).push([[60],{418:function(t,a,r){"use strict";r.r(a);var n=r(4),i=Object(n.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h2",{attrs:{id:"spring事务"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#spring事务"}},[t._v("#")]),t._v(" Spring事务")]),t._v(" "),a("h3",{attrs:{id:"一、spring事务特点"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#一、spring事务特点"}},[t._v("#")]),t._v(" 一、Spring事务特点")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("跨不同事务API的统一的编程模型，无论你使用的是jdbc、jta、jpa、hibernate。")])]),t._v(" "),a("li",[a("p",[t._v("支持声明式事务")])]),t._v(" "),a("li",[a("p",[t._v("简单的事务管理API")])]),t._v(" "),a("li",[a("p",[t._v("能与spring的数据访问抽象层完美集成")])])]),t._v(" "),a("p",[t._v("spring事务是由AOP实现的")]),t._v(" "),a("h3",{attrs:{id:"二、配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#二、配置"}},[t._v("#")]),t._v(" 二、配置")]),t._v(" "),a("h4",{attrs:{id:"_1、使用xml配置"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1、使用xml配置"}},[t._v("#")]),t._v(" 1、使用xml配置")]),t._v(" "),a("p",[t._v("使用spring boot就不写了")]),t._v(" "),a("h4",{attrs:{id:"_2、使用注解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2、使用注解"}},[t._v("#")]),t._v(" 2、使用注解")]),t._v(" "),a("h5",{attrs:{id:"transaction注解"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#transaction注解"}},[t._v("#")]),t._v(" @Transaction注解")]),t._v(" "),a("table",[a("thead",[a("tr",[a("th",{staticStyle:{"text-align":"left"}},[t._v("属性名")]),t._v(" "),a("th",{staticStyle:{"text-align":"left"}},[t._v("说明")])])]),t._v(" "),a("tbody",[a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("name")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("当在配置文件中有多个 TransactionManager , 可以用该属性指定选择哪个事务管理器。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("propagation")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("事务的传播行为，默认值为 REQUIRED。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("isolation")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("事务的隔离度，默认值采用 DEFAULT。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("timeout")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("事务的超时时间，默认值为-1。如果超过该时间限制但事务还没有完成，则自动回滚事务。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("read-only")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("指定事务是否为只读事务，默认值为 false；为了忽略那些不需要事务的方法，比如读取数据，可以设置 read-only 为 true。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("rollback-for")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("用于指定能够触发事务回滚的异常类型，如果有多个异常类型需要指定，各类型之间可以通过逗号分隔。")])]),t._v(" "),a("tr",[a("td",{staticStyle:{"text-align":"left"}},[t._v("no-rollback- for")]),t._v(" "),a("td",{staticStyle:{"text-align":"left"}},[t._v("抛出 no-rollback-for 指定的异常类型，不回滚事务。")])])])]),t._v(" "),a("p",[t._v("@Transaction注解可以添加方法及类上，添加在类上表示所有的公共方法具有相同的事务事务属性")]),t._v(" "),a("h5",{attrs:{id:"事务传播属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#事务传播属性"}},[t._v("#")]),t._v(" 事务传播属性")]),t._v(" "),a("ul",[a("li",[a("p",[a("strong",[t._v("REQUIRED")])]),t._v(" "),a("p",[t._v("这是默认的传播属性，如果外部调用方有事务，将会加入到事务，没有的话新建一个。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("PROPAGATION_SUPPORTS")])]),t._v(" "),a("p",[t._v("如果当前存在事务，则加入到该事务；如果当前没有事务，则以非事务的方式继续运行。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("PROPAGATION_NOT_SUPPORTED")])]),t._v(" "),a("p",[t._v("以非事务方式运行，如果当前存在事务，则把当前事务挂起。")])]),t._v(" "),a("li",[a("p",[a("strong",[t._v("PROPAGATION_NEVER")])]),t._v(" "),a("p",[t._v("以非事务方式运行，如果当前存在事务，则抛出异常。")])])]),t._v(" "),a("h3",{attrs:{id:"三、spring-的注解方式的事务实现机制"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#三、spring-的注解方式的事务实现机制"}},[t._v("#")]),t._v(" 三、Spring 的注解方式的事务实现机制")]),t._v(" "),a("p",[a("strong",[t._v("这一章节抄至网络")])]),t._v(" "),a("p",[t._v("在应用系统调用声明@Transactional 的目标方法时，Spring Framework 默认使用 AOP 代理，在代码运行时生成一个代理对象，根据@Transactional 的属性配置信息，这个代理对象决定该声明@Transactional 的目标方法是否由拦截器 TransactionInterceptor 来使用拦截，在 TransactionInterceptor 拦截时，会在在目标方法开始执行之前创建并加入事务，并执行目标方法的逻辑, 最后根据执行情况是否出现异常，利用抽象事务管理器(图 2 有相关介绍)AbstractPlatformTransactionManager 操作数据源 DataSource 提交或回滚事务,")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20201201215011.png",alt:""}})]),t._v(" "),a("p",[t._v("Spring AOP 代理有 CglibAopProxy 和 JdkDynamicAopProxy 两种，图 1 是以 CglibAopProxy 为例，对于 CglibAopProxy，需要调用其内部类的 DynamicAdvisedInterceptor 的 intercept 方法。对于 JdkDynamicAopProxy，需要调用其 invoke 方法。")]),t._v(" "),a("p",[t._v("正如上文提到的，事务管理的框架是由抽象事务管理器 AbstractPlatformTransactionManager 来提供的，而具体的底层事务处理实现，由 PlatformTransactionManager 的具体实现类来实现，如事务管理器 DataSourceTransactionManager。不同的事务管理器管理不同的数据资源 DataSource，比如 DataSourceTransactionManager 管理 JDBC 的 Connection。")]),t._v(" "),a("p",[t._v("PlatformTransactionManager，AbstractPlatformTransactionManager 及具体实现类关系如图 2 所示。")]),t._v(" "),a("p",[a("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20201201215222.png",alt:""}})]),t._v(" "),a("h3",{attrs:{id:"四、事务的一些结论"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#四、事务的一些结论"}},[t._v("#")]),t._v(" 四、事务的一些结论")]),t._v(" "),a("ol",[a("li",[a("p",[t._v("在一个类中使用非事务方法来调用事务方法，事务无法起作用")]),t._v(" "),a("p",[t._v("在 Spring 的 AOP 代理下，只有目标方法由外部调用，目标方法才由 Spring 生成的代理对象来管理，这会造成自调用问题。若同一类中的其他没有@Transactional 注解的方法内部调用有@Transactional 注解的方法，有@Transactional 注解的方法的事务被忽略，不会发生回滚。")])]),t._v(" "),a("li",[a("p",[t._v("@Transactional 只能应用到 public 方法才有效")])])])])}),[],!1,null,null,null);a.default=i.exports}}]);