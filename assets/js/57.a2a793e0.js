(window.webpackJsonp=window.webpackJsonp||[]).push([[57],{415:function(s,e,t){"use strict";t.r(e);var a=t(4),n=Object(a.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h4",{attrs:{id:"redis数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis数据结构"}},[s._v("#")]),s._v(" redis数据结构")]),s._v(" "),e("h5",{attrs:{id:"string"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#string"}},[s._v("#")]),s._v(" string")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("介绍")]),s._v(" ：string 数据结构是简单的 key-value 类型。虽然 Redis 是用 C 语言写的，但是 Redis 并没有使用 C 的字符串表示，而是自己构建了一种 "),e("strong",[s._v("简单动态字符串")]),s._v("（simple dynamic string，"),e("strong",[s._v("SDS")]),s._v("）。相比于 C 的原生字符串，Redis 的 SDS 不光可以保存文本数据还可以保存二进制数据，并且获取字符串长度复杂度为 O(1)（C 字符串为 O(N)）,除此之外,Redis 的 SDS API 是安全的，不会造成缓冲区溢出。")]),s._v(" "),e("li",[e("strong",[s._v("常用命令:")]),s._v(" "),e("code",[s._v("set,get,strlen,exists,dect,incr,setex")]),s._v(" 等等。")]),s._v(" "),e("li",[e("strong",[s._v("应用场景")]),s._v(" ：一般常用在需要计数的场景，比如用户的访问次数、热点文章的点赞转发数量等等。")])]),s._v(" "),e("h5",{attrs:{id:"list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#list"}},[s._v("#")]),s._v(" list")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("介绍")]),s._v(" ："),e("strong",[s._v("list")]),s._v(" 即是 "),e("strong",[s._v("链表")]),s._v("。链表是一种非常常见的数据结构，特点是易于数据元素的插入和删除并且且可以灵活调整链表长度，但是链表的随机访问困难。许多高级编程语言都内置了链表的实现比如 Java 中的 "),e("strong",[s._v("LinkedList")]),s._v("，但是 C 语言并没有实现链表，所以 Redis 实现了自己的链表数据结构。Redis 的 list 的实现为一个 "),e("strong",[s._v("双向链表")]),s._v("，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。")]),s._v(" "),e("li",[e("strong",[s._v("常用命令:")]),s._v(" "),e("code",[s._v("rpush,lpop,lpush,rpop,lrange、llen")]),s._v(" 等。")]),s._v(" "),e("li",[e("strong",[s._v("应用场景:")]),s._v(" 发布与订阅或者说消息队列、慢查询。")])]),s._v(" "),e("p",[e("strong",[s._v("通过 "),e("code",[s._v("rpush/lpop")]),s._v(" 实现队列：")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('127.0.0.1:6379> rpush myList value1 # 向 list 的头部（右边）添加元素\n(integer) 1\n127.0.0.1:6379> rpush myList value2 value3 # 向list的头部（最右边）添加多个元素\n(integer) 3\n127.0.0.1:6379> lpop myList # 将 list的尾部(最左边)元素取出\n"value1"\n127.0.0.1:6379> lrange myList 0 1 # 查看对应下标的list列表， 0 为 start,1为 end\n1) "value2"\n2) "value3"\n127.0.0.1:6379> lrange myList 0 -1 # 查看列表中的所有元素，-1表示倒数第一\n1) "value2"\n2) "value3"\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br")])]),e("p",[e("strong",[s._v("通过 "),e("code",[s._v("rpush/rpop")]),s._v(" 实现栈：")])]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('127.0.0.1:6379> rpush myList2 value1 value2 value3\n(integer) 3\n127.0.0.1:6379> rpop myList2 # 将 list的头部(最右边)元素取出\n"value3"\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br")])]),e("h5",{attrs:{id:"hash"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#hash"}},[s._v("#")]),s._v(" hash")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("介绍")]),s._v(" ：hash 类似于 JDK1.8 前的 HashMap，内部实现也差不多(数组 + 链表)。不过，Redis 的 hash 做了更多优化。另外，hash 是一个 string 类型的 field 和 value 的映射表，"),e("strong",[s._v("特别适合用于存储对象")]),s._v("，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。")]),s._v(" "),e("li",[e("strong",[s._v("常用命令：")]),s._v(" "),e("code",[s._v("hset,hmset,hexists,hget,hgetall,hkeys,hvals")]),s._v(" 等。")]),s._v(" "),e("li",[e("strong",[s._v("应用场景:")]),s._v(" 系统中对象数据的存储。")])]),s._v(" "),e("h5",{attrs:{id:"set"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#set"}},[s._v("#")]),s._v(" set")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("介绍 ：")]),s._v(" set 类似于 Java 中的 "),e("code",[s._v("HashSet")]),s._v(" 。Redis 中的 set 类型是一种无序集合，集合中的元素没有先后顺序。当你需要存储一个列表数据，又不希望出现重复数据时，set 是一个很好的选择，并且 set 提供了判断某个成员是否在一个 set 集合内的重要接口，这个也是 list 所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。比如：你可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis 可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。")]),s._v(" "),e("li",[e("strong",[s._v("常用命令：")]),s._v(" "),e("code",[s._v("sadd,spop,smembers,sismember,scard,sinterstore,sunion")]),s._v(" 等。")]),s._v(" "),e("li",[e("strong",[s._v("应用场景:")]),s._v(" 需要存放的数据不能重复以及需要获取多个数据源交集和并集等场景")])]),s._v(" "),e("h5",{attrs:{id:"sortset"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sortset"}},[s._v("#")]),s._v(" sortset")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("介绍：")]),s._v(" 和 set 相比，sorted set 增加了一个权重参数 score，使得集合中的元素能够按 score 进行有序排列，还可以通过 score 的范围来获取元素的列表。有点像是 Java 中 HashMap 和 TreeSet 的结合体。")]),s._v(" "),e("li",[e("strong",[s._v("常用命令：")]),s._v(" "),e("code",[s._v("zadd,zcard,zscore,zrange,zrevrange,zrem")]),s._v(" 等。")]),s._v(" "),e("li",[e("strong",[s._v("应用场景：")]),s._v(" 需要对数据根据某个权重进行排序的场景。比如在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息。")])]),s._v(" "),e("h5",{attrs:{id:"bitmap"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#bitmap"}},[s._v("#")]),s._v(" bitmap")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("介绍 ：")]),s._v(" bitmap 存储的是连续的二进制数字（0 和 1），也是key-value的形式存储，value的最大长度有2^32个bit位。")]),s._v(" "),e("li",[e("strong",[s._v("常用命令：")]),s._v(" "),e("code",[s._v("setbit")]),s._v(" 、"),e("code",[s._v("getbit")]),s._v(" 、"),e("code",[s._v("bitcount")]),s._v("、"),e("code",[s._v("bitop")])]),s._v(" "),e("li",[e("strong",[s._v("应用场景:")]),s._v(" 适合需要保存状态信息（比如是否签到、是否登录...）并需要进一步对这些信息进行分析的场景。比如用户签到情况、活跃用户情况、用户行为统计（比如是否点赞过某个视频）。")])]),s._v(" "),e("p",[s._v("实例：用户点赞视频")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v('public void test7() {\n\n    //随机用户点赞视频最大为1000次\n    //多次运行先前的设置的bit位也还是会存在的\n    for (int i = 0; i < 1000; i++) {\n\n        double d = Math.random() * 100000;\n        long loc = (long) d;\n        redisTemplate.opsForValue().setBit("videoLike", loc, true);\n    }\n\n    //获取视频点赞的用户数\n    System.out.println(redisTemplate.execute(new RedisCallback() {\n        @Override\n        public Object doInRedis(RedisConnection connection) throws DataAccessException {\n            //connection的bitcount方法参数直接接收bytes，需要先转换再传进去\n            Jackson2JsonRedisSerializer<String> stringJackson2JsonRedisSerializer = new Jackson2JsonRedisSerializer<>(String.class);\n            byte[] videoLikes = stringJackson2JsonRedisSerializer.serialize("videoLike");\n            return connection.bitCount(videoLikes);\n        }\n    }));\n}\n')])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br"),e("span",{staticClass:"line-number"},[s._v("8")]),e("br"),e("span",{staticClass:"line-number"},[s._v("9")]),e("br"),e("span",{staticClass:"line-number"},[s._v("10")]),e("br"),e("span",{staticClass:"line-number"},[s._v("11")]),e("br"),e("span",{staticClass:"line-number"},[s._v("12")]),e("br"),e("span",{staticClass:"line-number"},[s._v("13")]),e("br"),e("span",{staticClass:"line-number"},[s._v("14")]),e("br"),e("span",{staticClass:"line-number"},[s._v("15")]),e("br"),e("span",{staticClass:"line-number"},[s._v("16")]),e("br"),e("span",{staticClass:"line-number"},[s._v("17")]),e("br"),e("span",{staticClass:"line-number"},[s._v("18")]),e("br"),e("span",{staticClass:"line-number"},[s._v("19")]),e("br"),e("span",{staticClass:"line-number"},[s._v("20")]),e("br"),e("span",{staticClass:"line-number"},[s._v("21")]),e("br"),e("span",{staticClass:"line-number"},[s._v("22")]),e("br")])]),e("h4",{attrs:{id:"redis过期时间"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis过期时间"}},[s._v("#")]),s._v(" redis过期时间")]),s._v(" "),e("p",[s._v("redis通过过期字典来保存数据的过期时间，字典的键保存的是数据的key地址，value是一个long long类型，保存的是指向的数据的过期时间")]),s._v(" "),e("p",[e("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/20210401182302.png",alt:"redis过期时间"}})]),s._v(" "),e("h4",{attrs:{id:"redis的过期删除策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis的过期删除策略"}},[s._v("#")]),s._v(" redis的过期删除策略")]),s._v(" "),e("p",[s._v("redis有两种过期删除策略")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("惰性删除策略")]),s._v(" "),e("p",[s._v("只有当取出key的时候才会对数据进行过期检查，对cpu比较友好")])]),s._v(" "),e("li",[e("p",[s._v("定时删除策略")]),s._v(" "),e("p",[s._v("每隔一段时间抽取一批key来执行删除操作，对内存友好")])])]),s._v(" "),e("p",[s._v("redis采用惰性+定时的删除策略来管理设定了过期的数据")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("缺点")]),s._v(" "),e("p",[s._v("即使采用惰性+定时的删除策略也会有过期的数据没有被找到，导致有大量的过期的key存在于内存中，从而发生OOM")])])]),s._v(" "),e("h4",{attrs:{id:"redis内存淘汰策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis内存淘汰策略"}},[s._v("#")]),s._v(" redis内存淘汰策略")]),s._v(" "),e("p",[s._v("redis加入内存淘汰策略来应对内存溢出的情况，有以下6种")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("volatile-lru（least recently used）")]),s._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰")]),s._v(" "),e("li",[e("strong",[s._v("volatile-ttl")]),s._v("：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰")]),s._v(" "),e("li",[e("strong",[s._v("volatile-random")]),s._v("：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰")]),s._v(" "),e("li",[e("strong",[s._v("allkeys-lru（least recently used）")]),s._v("：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）")]),s._v(" "),e("li",[e("strong",[s._v("allkeys-random")]),s._v("：从数据集（server.db[i].dict）中任意选择数据淘汰")]),s._v(" "),e("li",[e("strong",[s._v("no-eviction")]),s._v("：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！")])]),s._v(" "),e("p",[s._v("4.0 版本后增加以下两种：")]),s._v(" "),e("ol",[e("li",[e("strong",[s._v("volatile-lfu（least frequently used）")]),s._v("：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰")]),s._v(" "),e("li",[e("strong",[s._v("allkeys-lfu（least frequently used）")]),s._v("：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key")])]),s._v(" "),e("h4",{attrs:{id:"redis持久化机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis持久化机制"}},[s._v("#")]),s._v(" redis持久化机制")]),s._v(" "),e("p",[s._v("redis有两种持久化机制，分别是RDB(快照）和AOF（追加写入)")]),s._v(" "),e("ul",[e("li",[e("p",[s._v("RDB")]),s._v(" "),e("p",[s._v("redis通过创建快照的方式来获得某一时刻内存中的数据作为副本，用于还原数据或者拷贝到其他服务器中（主从结构）")]),s._v(" "),e("p",[s._v("快照持久化是 Redis 默认采用的持久化方式，在 Redis.conf 配置文件中默认有此下配置：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n\nsave 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br")])])]),s._v(" "),e("li",[e("p",[s._v("AOF")]),s._v(" "),e("p",[s._v("AOF比RDB的实时性更好，每次修改数据都会写入到硬盘中，目前已经是主流的配置方法。")]),s._v(" "),e("p",[s._v("在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：")]),s._v(" "),e("div",{staticClass:"language- line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[s._v("appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度\nappendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘\nappendfsync no        #让操作系统决定何时进行同步\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br")])]),e("p",[s._v("一般为了兼顾性能，采用"),e("code",[s._v("appendfsync everysec")]),s._v(",这样即使出现故障了，最多也就丢失了一秒的数据。")])])]),s._v(" "),e("h4",{attrs:{id:"redis事务"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redis事务"}},[s._v("#")]),s._v(" redis事务")]),s._v(" "),e("p",[s._v("redis事务就是将多条命令打包然后按顺序执行。")]),s._v(" "),e("p",[s._v("redis没有回滚功能，也就是不支持原子性。redis团队认为命令执行错误（redis认为只有程序执行错误才会导致执行命令失败）应该发生在开发过程，而不是在生产过程因此不支持回滚。")])])}),[],!1,null,null,null);e.default=n.exports}}]);