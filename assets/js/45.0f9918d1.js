(window.webpackJsonp=window.webpackJsonp||[]).push([[45],{403:function(_,v,l){"use strict";l.r(v);var s=l(4),a=Object(s.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h3",{attrs:{id:"_1、mysql架构"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1、mysql架构"}},[_._v("#")]),_._v(" 1、MySQL架构")]),_._v(" "),v("p",[_._v("MySQL是一个典型的C/S架构程序，MySQL Server提供数据库服务，完成客户端的请求和操作，Client负责连接到Server。MySQL和其他关系型数据库不一样的地方在于它的弹性以及可以通过插件形式提供不同种类的存储引擎，MySQL请求处理过程会根据不同的存储引擎发生变化，比如事务性的InnoDB和非事务性的MyISAM，数据的存储和SQL的执行会产生很大的差异。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/v2-4ce9c07e160c6c3e48387bc98d5295e1_r.jpg",alt:"preview"}})]),_._v(" "),v("h4",{attrs:{id:"_1-连接层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-连接层"}},[_._v("#")]),_._v(" 1.连接层")]),_._v(" "),v("p",[_._v("最上层是一些客户端和连接服务，包含本地sock通信和大多数基于客户端/服务端工具实现的类似于tcp/ip的通信。主要完成一些类似于连接处理、授权认证、及相关的安全方案。在该层上引入了线程池的概念，为通过认证安全接入的客户端提供线程。同样在该层上可以实现基于SSL的安全链接。服务器也会为安全接入的每个客户端验证它所具有的操作权限。")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("连接处理")]),_._v(" "),v("p",[_._v("当一个客户端向服务端发送连接请求后，MySQL server会从线程池中分配一个线程来和客户端进行连接，以后该客户端的请求都会被分配到该线程上。MySQL Server为了提高性能，提供了线程池，减少了创建线程和释放线程所花费的时间。")])]),_._v(" "),v("li",[v("p",[_._v("用户鉴权")]),_._v(" "),v("p",[_._v("当客户端向MySQL服务端发起连接请求后，MySQL server会对发起连接的用户进行鉴权处理，MySQL鉴权依据是: 用户名，客户端主机地址和用户密码")])]),_._v(" "),v("li",[v("p",[_._v("安全管理")]),_._v(" "),v("p",[_._v("当客户连接到MySQL server后，MySQL server会根据用户的权限来判断用户具体可执行哪些操作")])])]),_._v(" "),v("h4",{attrs:{id:"_2-服务层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-服务层"}},[_._v("#")]),_._v(" 2.服务层")]),_._v(" "),v("ul",[v("li",[v("p",[_._v("Management Serveices & Utilities： 系统管理和控制工具")])]),_._v(" "),v("li",[v("p",[_._v("SQL Interface: SQL接口")]),_._v(" "),v("p",[_._v("接受用户的SQL命令，并且返回用户需要查询的结果。")]),_._v(" "),v("ul",[v("li",[_._v("Data Manipulation Language (DML).")]),_._v(" "),v("li",[_._v("Data Definition Language (DDL).")]),_._v(" "),v("li",[_._v("存储过程")]),_._v(" "),v("li",[_._v("视图")]),_._v(" "),v("li",[_._v("触发器")])])]),_._v(" "),v("li",[v("p",[_._v("Parser: 解析器")]),_._v(" "),v("p",[_._v("SQL命令传递到解析器的时候会被解析器验证和解析。")])]),_._v(" "),v("li",[v("p",[_._v("Optimizer: 查询优化器。")]),_._v(" "),v("p",[_._v("SQL语句在查询之前会使用查询优化器对查询进行优化。")]),_._v(" "),v("p",[_._v("用一个例子就可以理解： select uid,name from user where gender= 1;")]),_._v(" "),v("p",[_._v("优化器来决定先投影还是先过滤。")])]),_._v(" "),v("li",[v("p",[_._v("Cache和Buffer： 查询缓存。")]),_._v(" "),v("p",[_._v("如果查询缓存有命中的查询结果，查询语句就可以直接去查询缓存中取数据。")]),_._v(" "),v("p",[_._v("这个缓存机制是由一系列小缓存组成的。比如表缓存，记录缓存，key缓存，权限缓存等")])])]),_._v(" "),v("h4",{attrs:{id:"_3-引擎层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-引擎层"}},[_._v("#")]),_._v(" 3.引擎层")]),_._v(" "),v("p",[_._v("存储引擎层，存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API与存储引擎进行通信。不同的存储引擎具有的功能不同，这样我们可以根据自己的实际需要进行选取。后面介绍MyISAM和InnoDB")]),_._v(" "),v("h4",{attrs:{id:"_4-存储层"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-存储层"}},[_._v("#")]),_._v(" 4.存储层")]),_._v(" "),v("p",[_._v("数据存储层，主要是将数据存储在运行于裸设备的文件系统之上，并完成与存储引擎的交互。")]),_._v(" "),v("h3",{attrs:{id:"_2、mysql查询流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2、mysql查询流程"}},[_._v("#")]),_._v(" 2、MySQL查询流程")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/163a814e084bdc22",alt:"查询具体过程"}})]),_._v(" "),v("h4",{attrs:{id:"查询流程总结"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#查询流程总结"}},[_._v("#")]),_._v(" 查询流程总结")]),_._v(" "),v("ol",[v("li",[_._v("mysql客户端通过协议与mysql服务器建连接，发送查询语句")]),_._v(" "),v("li",[_._v("服务器先检查查询缓存，如果命中了缓存，则立即返回存储在缓存中的结果。否则进入下一阶段；")]),_._v(" "),v("li",[_._v("服务器端进行sql解析、预处理，再由优化器生成对应的认为最好的执行计划；")]),_._v(" "),v("li",[_._v("mysql根据优化器生成的执行计划，调用存储引擎的api来执行查询；")]),_._v(" "),v("li",[_._v("将结果返回给客户端；")])]),_._v(" "),v("p",[_._v("mysql默认使用的BTREE索引，并且一个大致方向是:无论怎么折腾sql，至少在目前来说，mysql最多只用到表中的一个索引。")]),_._v(" "),v("h4",{attrs:{id:"_2查询缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2查询缓存"}},[_._v("#")]),_._v(" ②查询缓存")]),_._v(" "),v("ol",[v("li",[_._v("查询缓存保存查询返回的完整结构；")]),_._v(" "),v("li",[_._v("命中查询缓存时，mysql会立即返回结果，跳过解析、优化和执行阶段；")]),_._v(" "),v("li",[_._v("查询缓存系统会跟踪查询中设计的每个表，如果这些表发生变化，和这个表相关的所有缓存数据都将失效；")]),_._v(" "),v("li",[_._v("判断缓存是否命中时，不会进行解析查询语句，直接使用sql语句和客户端发送过来的其他原始信息，任何字符上的不同，例如空格、注解等，都会导致缓存不命中；")]),_._v(" "),v("li",[_._v("当查询语句有一些不确定的数据时，则不会被缓存；")]),_._v(" "),v("li",[_._v("查询缓存配置参数：\n"),v("ul",[v("li",[_._v("query_cache_type：是否打开缓存。OFF、ON和DEMAND。DEMAND表示只有在查询语句中明确写明SQL_CACHE的语句才会放入查询缓存。eg：select sql_cache * from table_name;")]),_._v(" "),v("li",[_._v("query_cache_size：缓存使用的总内存空间大小，单位是字节")]),_._v(" "),v("li",[_._v("query_cache_min_res_unit：分配内存块时的最小单位，较小的该值可以减少碎片导致的内存空间浪费，但会导致更频繁的内存块操作；")]),_._v(" "),v("li",[_._v("query_cache_limit：mysql能够缓存的最大查询结果，如果查询结果大于这个值，则不会被缓存；由于查询缓存在数据生成的时候就开始尝试缓存数据，所以当结果全部返回后，mysql才知道查询结果是否超出限制。超出之后，才会将结果从查询缓存中删除；")]),_._v(" "),v("li",[_._v("query_cache_wlock_invalidate：如果某个数据表被其他连接锁住，是否仍然从查询缓存中返回结果，默认OFF，表示仍然可以返回；")])])])]),_._v(" "),v("h4",{attrs:{id:"_3语法解析器和预处理器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3语法解析器和预处理器"}},[_._v("#")]),_._v(" ③语法解析器和预处理器")]),_._v(" "),v("ol",[v("li",[_._v("mysql解析器通过关键字将sql语句进行解析，并生成对应的解析树；")]),_._v(" "),v("li",[_._v("mysql解析器将使用mysql语法规则验证和解析查询，eg：验证是否使用错误的关键字、使用关键字的顺序是否正确、验证引号是否前后匹配等；")]),_._v(" "),v("li",[_._v("预处理器根据一些mysql规则进行进一步检查解析树是否合法，eg：检查数据表和数据列是否存在，解析名字和别名是否有歧义；")]),_._v(" "),v("li",[_._v("下一步预处理器验证用户权限，查看用户是否有操作权限，通常很快；")])]),_._v(" "),v("h4",{attrs:{id:"_4查询优化器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4查询优化器"}},[_._v("#")]),_._v(" ④查询优化器")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("优化器的作用就是找到最好的执行计划；")])]),_._v(" "),v("li",[v("p",[_._v("语法树被认为是合法后，优化器将sql语句转换为执行计划，一条查询可以有多种执行方式，最后都返回相同的结果；")])]),_._v(" "),v("li",[v("p",[_._v("生成执行计划过程")])]),_._v(" "),v("li",[v("ol",[v("li",[_._v("耗时较多，特别是存在许多可选的执行计划时；")]),_._v(" "),v("li",[_._v("在一条sql语句执行过程中将该语句对应的最终执行计划进行缓存，下一次就可以直接使用已缓存的执行计划，从而提高sql语句的执行速度；")])])]),_._v(" "),v("li",[v("p",[_._v("mysql使用"),v("strong",[_._v("基于成本的优化器")]),_._v("（CBO cost-based optimizer），会预测一个查询使用某种执行计划的成本，选择其中成本最小的一个；")])]),_._v(" "),v("li",[v("ol",[v("li",[_._v("优化器会根据优化规则对关系表达式进行转换，经过优化规则后会生成另一个关系表达式，原有表达式也会保留；")]),_._v(" "),v("li",[_._v("经过一系列转换后会生成多个执行计划，然后CBO会根据统计信息和代价模型（cost model）计算每个执行计划的cost，从中挑选cost最小的执行计划；")])])]),_._v(" "),v("li",[v("p",[_._v("导致mysql优化器选择非最优执行计划的原因")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("mysql是根据成本计算得出的最优计划，可能执行时间并不是最短的；")])]),_._v(" "),v("li",[v("p",[_._v("有时候可能无法估算所有可能的执行计划，导致可能错过最优的执行计划；")])]),_._v(" "),v("li",[v("p",[_._v("执行计划成本估算不等同于实际执行的成本，mysql层面无法知道哪些页面在内存中，哪些在磁盘上，实际执行过程中需要多少次物理IO无法得知；")])]),_._v(" "),v("li",[v("p",[_._v("mysql不会考虑不受其控制的操作成本，eg：执行用户自定义函数的成本；")])]),_._v(" "),v("li",[v("p",[_._v("统计信息不准确，mysql依赖存储引擎提供的统计信息（每个表有多少页面、数据行和索引的长度、索引的分布等）来估计成本，InnoDB因为MVCC的架构，并不能维护一个数据表行数的精确统计信息；")])])])]),_._v(" "),v("li",[v("p",[_._v("mysql可以处理的优化类型")]),_._v(" "),v("ol",[v("li",[v("p",[_._v("重新定义关联表的顺序；")])]),_._v(" "),v("li",[v("p",[_._v("使用等价转换原则，eg：移除一些恒成立或恒不成立的判断；")])]),_._v(" "),v("li",[v("p",[_._v("可能的表达式转换为常数表达式；")])]),_._v(" "),v("li",[v("p",[_._v("提前终止查询，使用limit；")])])])])]),_._v(" "),v("h4",{attrs:{id:"_5查询执行引擎"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5查询执行引擎"}},[_._v("#")]),_._v(" ⑤查询执行引擎")]),_._v(" "),v("ol",[v("li",[_._v("查询执行引擎根据执行计划来完成整个查询；")]),_._v(" "),v("li",[_._v("执行计划是一个数据结构（指令树），不是和其他关系型数据库那样生成对应的字节码；")]),_._v(" "),v("li",[_._v("mysql根据执行计划给出的指令逐步执行，在执行过程中，有大量的操作需要调用存储引擎实现的接口来完成，这些接口即为“handler API”；")]),_._v(" "),v("li",[_._v("查询中每一个表由一个handler的实例表示。在优化阶段mysql就为每一个表创建了一个handler实例，优化器可以根据这些实例的接口获取表的相关信息，eg：列名、索引、统计信息等；")])]),_._v(" "),v("h4",{attrs:{id:"_6返回客户端结果"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6返回客户端结果"}},[_._v("#")]),_._v(" ⑥返回客户端结果")]),_._v(" "),v("ol",[v("li",[_._v("如果查询可以被缓存，mysql会在这个阶段将结果存放到查询缓存中；")]),_._v(" "),v("li",[_._v("mysql将结果集返回给客户端是一个增量逐步返回的过程，在查询生成第一条结果时，mysql就可以开始向客户端逐步返回结果了；")]),_._v(" "),v("li",[_._v("增量逐步返回的好处：服务端无须存储太多的结果，不会因为返回太多的结果而消耗太多内存；同时让客户端第一时间获得返回结果；")]),_._v(" "),v("li",[_._v("结果集中的每一行都会以一个满足mysql客户端/服务端通信协议的包发送，再通过tcp协议进行传输，传输过程中，可能对mysql的包进行缓存然后批量传输；")])])])}),[],!1,null,null,null);v.default=a.exports}}]);