(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{419:function(t,s,a){"use strict";a.r(s);var n=a(4),e=Object(n.a)({},(function(){var t=this,s=t._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[s("ul",[s("li",[s("h4",{attrs:{id:"join"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#join"}},[t._v("#")]),t._v(" JOIN")]),t._v(" "),s("p",[t._v("MySQL对于任何的关联都是执行嵌套循环关联操作，伪代码如下")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/202402161937491.jpg",alt:""}})]),t._v(" "),s("ol",[s("li",[s("p",[t._v("保证被驱动表的join字段已经被索引")])]),t._v(" "),s("li",[s("p",[t._v("left join 时，默认选择左表作为驱动表（right join相反），因此选择小表作为驱动表，大表作为被驱动表。")])]),t._v(" "),s("li",[s("p",[t._v("inner join 时，MySQL会自己帮你把小结果集的表选为驱动表。")])]),t._v(" "),s("li",[s("p",[t._v("子查询尽量不要放在被驱动表，有可能使用不到索引。")])])]),t._v(" "),s("h4",{attrs:{id:"in-and-exists"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#in-and-exists"}},[t._v("#")]),t._v(" IN and EXISTS")]),t._v(" "),s("p",[t._v("IN的查询过程类似于下面")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("$result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n$users "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SELECT * FROM `user`"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n$orders "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SELECT user_id FROM `order`"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 临时表")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("$i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("$i "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" $users"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("$i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("$j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("$j "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v(" $orders"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("$j"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 此过程为内存操作，不涉及数据库查询。")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("$users"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("$i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("==")]),t._v(" $orders"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("$j"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("user_id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n            $result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("current"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" $users"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("$i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("break")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br"),s("span",{staticClass:"line-number"},[t._v("8")]),s("br"),s("span",{staticClass:"line-number"},[t._v("9")]),s("br"),s("span",{staticClass:"line-number"},[t._v("10")]),s("br"),s("span",{staticClass:"line-number"},[t._v("11")]),s("br"),s("span",{staticClass:"line-number"},[t._v("12")]),s("br")])]),s("p",[t._v("如果IN里面的表越大就不建议用in，耗内存且MySQL会执行全表扫描")]),t._v(" "),s("p",[t._v("EXISTS的查询过程类似于下面")]),t._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[t._v("$result "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n$users "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v('"SELECT * FROM `user`"')]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("for")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("$i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token number"}},[t._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("$i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<")]),t._v("$users"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("length"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("$i"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("if")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("exists")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("$users"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("$i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("id"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 执行SELECT * FROM `order` WHERE user.id = order.user_id")]),t._v("\n        $result"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" $users"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("$i"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br"),s("span",{staticClass:"line-number"},[t._v("6")]),s("br"),s("span",{staticClass:"line-number"},[t._v("7")]),s("br")])]),s("p",[t._v("当order表比user表大很多的时候，使用EXISTS是再恰当不过了，它没有那么多遍历操作,只需要再执行一次查询就行，"),s("strong",[t._v("当然EXISTS每次都会去查询数据库")])]),t._v(" "),s("p",[s("strong",[t._v("关于使用子查询和INNER JOIN那个更快，只能根据实际情况来测试看哪个快了")])]),t._v(" "),s("h4",{attrs:{id:"order-by"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#order-by"}},[t._v("#")]),t._v(" ORDER BY")]),t._v(" "),s("p",[t._v("MySQL支持二种方式的排序，FileSort和Index，Index效率高.它指MySQL扫描索引本身完成排序。FileSort方式效率较低。")]),t._v(" "),s("h5",{attrs:{id:"使用index排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用index排序"}},[t._v("#")]),t._v(" 使用Index排序:")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("ORDER BY 语句使用索引最左前列")])]),t._v(" "),s("li",[s("p",[t._v("使用Where子句与Order BY子句条件列组合满足索引最左前列，where子句中如果出现索引的范围查询(即explain中出现range)会导致order by 索引失效。")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/10EA75EA-0277-4DAF-AFEF-441F2B07EAA1.png",alt:"img"}})]),t._v(" "),s("p",[t._v("第二种中，where a = const and b > const order by b , c 不会出现 using filesort b , c 两个衔接上了。但是：where a = const and b > const order by c 将会出现 using filesort 。因为 b 用了范围索引，断了。而上一个 order by 后的b 用到了索引，所以能衔接上 c")])])]),t._v(" "),s("h5",{attrs:{id:"使用filesort排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#使用filesort排序"}},[t._v("#")]),t._v(" 使用FileSort排序")]),t._v(" "),s("p",[t._v("如果不在索引列上，FileSort有两种算法：MySQL就要启动双路排序和单路排序")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("双路排序")]),t._v(" "),s("p",[t._v("MySQL 4.1之前是使用双路排序,字面意思就是两次扫描磁盘，最终得到数据")]),t._v(" "),s("p",[t._v("读取行指针和order by列，对他们进行排序，然后扫描已经排序好的列表，按照列表中的值重新从列表中读取对应的数据输出---两次IO 从磁盘取排序字段，在buffer进行排序，再从磁盘取其他字段。")])]),t._v(" "),s("li",[s("p",[t._v("单路排序")]),t._v(" "),s("p",[t._v("从磁盘读取查询需要的所有列，按照order by列在buffer对它们进行排序，然后扫描排序后的列表进行输出，它的效率更快一些，避免了第二次读取数据。并且把随机IO变成了顺序IO,但是它会使用更多的空间，因为它把每一行都保存在内存中了。")])]),t._v(" "),s("li",[s("p",[t._v("结论及引申出的问题")]),t._v(" "),s("ul",[s("li",[s("p",[t._v("由于单路是后出的，总体而言好过双路")])]),t._v(" "),s("li",[s("p",[t._v("在sort_buffer中，单路排序比双路排序要多占用很多空间，因为单路排序是把所有字段都取出, 所以有可能取出的数据的总大小"),s("strong",[t._v("超出了sort_buffer的容量")]),t._v("，导致每次只能取sort_buffer容量大小的数据，进行排序（创建tmp文件，多路合并），排完再取取sort_buffer容量大小，再排……从而多次I/O。")])])])]),t._v(" "),s("li",[s("p",[t._v("优化策略")]),t._v(" "),s("ul",[s("li",[t._v("增大sort_buffer_size参数的设置")]),t._v(" "),s("li",[t._v("增大max_length_for_sort_data参数的设置")]),t._v(" "),s("li",[t._v("去掉select 后面不需要的字段")])])])]),t._v(" "),s("h4",{attrs:{id:"group-by"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#group-by"}},[t._v("#")]),t._v(" GROUP BY")]),t._v(" "),s("p",[t._v("一般group by时通用做法都是会创建一张临时表，把符合条件的所有记录都放入临时表后，再分组/执行聚合函数（max, min等)，为了避免创建临时表就需要用到索引了")]),t._v(" "),s("h5",{attrs:{id:"loose-index-scan"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#loose-index-scan"}},[t._v("#")]),t._v(" loose index scan")]),t._v(" "),s("p",[t._v("假设你建立了一张t1(c1,c2,c3,c4)，索引为idx(c1,c2,c3)，在执行group by的时候只用到了一部分key（遵循leftmost prefix），那么就叫loose index scan，比如下面这些例子")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c2 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("DISTINCT")]),t._v(" c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c2 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" t1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[t._v("MIN")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("c2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c2 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" c3 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" const "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#这个语句我是感觉不算loose index scan的，毕竟索引都用到了，可能leftmost prefix是一个更重要的判断规则吧，who knows？")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("满足loose index scan的条件如下：")]),t._v(" "),s("blockquote",[s("ul",[s("li",[t._v("The query is over a single table.")]),t._v(" "),s("li",[t._v("The "),s("code",[t._v("GROUP BY")]),t._v(" names only columns that form a leftmost prefix of the index and no other columns. (If, instead of "),s("code",[t._v("GROUP BY")]),t._v(", the query has a "),s("code",[t._v("DISTINCT")]),t._v(" clause, all distinct attributes refer to columns that form a leftmost prefix of the index.) For example, if a table "),s("code",[t._v("t1")]),t._v(" has an index on "),s("code",[t._v("(c1,c2,c3)")]),t._v(", Loose Index Scan is applicable if the query has "),s("code",[t._v("GROUP BY c1, c2")]),t._v(". It is not applicable if the query has "),s("code",[t._v("GROUP BY c2, c3")]),t._v(" (the columns are not a leftmost prefix) or "),s("code",[t._v("GROUP BY c1, c2, c4")]),t._v(" ("),s("code",[t._v("c4")]),t._v(" is not in the index).")]),t._v(" "),s("li",[t._v("The only aggregate functions used in the select list (if any) are "),s("a",{attrs:{href:"https://dev.MySQL.com/doc/refman/8.2/en/aggregate-functions.html#function_min",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("MIN()")]),s("OutboundLink")],1),t._v(" and "),s("a",{attrs:{href:"https://dev.MySQL.com/doc/refman/8.2/en/aggregate-functions.html#function_max",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("MAX()")]),s("OutboundLink")],1),t._v(", and all of them refer to the same column. The column must be in the index and must immediately follow the columns in the "),s("code",[t._v("GROUP BY")]),t._v(".")]),t._v(" "),s("li",[t._v("Any other parts of the index than those from the "),s("code",[t._v("GROUP BY")]),t._v(" referenced in the query must be constants (that is, they must be referenced in equalities with constants), except for the argument of "),s("a",{attrs:{href:"https://dev.MySQL.com/doc/refman/8.2/en/aggregate-functions.html#function_min",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("MIN()")]),s("OutboundLink")],1),t._v(" or "),s("a",{attrs:{href:"https://dev.MySQL.com/doc/refman/8.2/en/aggregate-functions.html#function_max",target:"_blank",rel:"noopener noreferrer"}},[s("code",[t._v("MAX()")]),s("OutboundLink")],1),t._v(" functions.")]),t._v(" "),s("li",[t._v("For columns in the index, full column values must be indexed, not just a prefix. For example, with "),s("code",[t._v("c1 VARCHAR(20), INDEX (c1(10))")]),t._v(", the index uses only a prefix of "),s("code",[t._v("c1")]),t._v(" values and cannot be used for Loose Index Scan.")])])]),t._v(" "),s("p",[t._v("如果是loose index scan，执行计划extra会显示Using index for group-by")]),t._v(" "),s("h5",{attrs:{id:"tight-index-scan"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#tight-index-scan"}},[t._v("#")]),t._v(" tight index scan")]),t._v(" "),s("p",[t._v("这个看文档感觉也不是很清晰，这个概念貌似是MySQL独有的，大概是如果查询SQL不能执行loose index scan，但是如果key能通过一些等值条件来满足leftmost prefix，也不会创建临时表，这种叫tight index scan")]),t._v(" "),s("p",[t._v("比如以下SQL")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("#假设t1表（c1，c2，c3，c4）有索引（c1，c2，c3）")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 通过c2的等值来fill the gap of leftmost prefix")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c3 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" c2 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c3"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[t._v("# 通过c1的等值来fill the gap of leftmost prefix")]),t._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" c1"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c3 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" t1 "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" c1 "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'a'")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("GROUP")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("BY")]),t._v(" c2"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(",")]),t._v(" c3"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br"),s("span",{staticClass:"line-number"},[t._v("5")]),s("br")])]),s("h5",{attrs:{id:"优化建议"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化建议"}},[t._v("#")]),t._v(" 优化建议")]),t._v(" "),s("ul",[s("li",[t._v("group by实质是先排序后进行分组，遵照索引建的最佳左前缀")]),t._v(" "),s("li",[t._v("当无法使用索引列，增大max_length_for_sort_data参数的设置+增大sort_buffer_size参数的设置")]),t._v(" "),s("li",[t._v("where高于having，能写在where限定的条件就不要去having限定了。")]),t._v(" "),s("li",[t._v("尽量不要使用 distinct 关键字去重")]),t._v(" "),s("li",[t._v("group by会按照分组字段进行排序，如果不关心结果集排序，可以使用order by null让MySQL不进行文件排序")])]),t._v(" "),s("h4",{attrs:{id:"index-condition-pushdown-索引下推"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#index-condition-pushdown-索引下推"}},[t._v("#")]),t._v(" Index Condition Pushdown（索引下推）")]),t._v(" "),s("p",[t._v("ICP是在MySQL5.6推出的索引优化，减少回表的次。如果where的条件都在索引中，那么MySQL引擎会遍历索引去查找符合where条件行返回，而不是将符合索引的数据回表后返回给MySQL service。比如下面的例子：")]),t._v(" "),s("p",[t._v("假设people表的索引有（zipcode,lastname,address)")]),t._v(" "),s("div",{staticClass:"language-sql line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-sql"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("SELECT")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("*")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("FROM")]),t._v(" people\n  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("WHERE")]),t._v(" zipcode"),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'95054'")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" lastname "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("LIKE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'%etrunia%'")]),t._v("\n  "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("AND")]),t._v(" address "),s("span",{pre:!0,attrs:{class:"token operator"}},[t._v("LIKE")]),t._v(" "),s("span",{pre:!0,attrs:{class:"token string"}},[t._v("'%Main Street%'")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[t._v("1")]),s("br"),s("span",{staticClass:"line-number"},[t._v("2")]),s("br"),s("span",{staticClass:"line-number"},[t._v("3")]),s("br"),s("span",{staticClass:"line-number"},[t._v("4")]),s("br")])]),s("p",[t._v("MySQL先会在索引中找到符合where条件的数据后再回表查询数据行返回给service")]),t._v(" "),s("h4",{attrs:{id:"union"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#union"}},[t._v("#")]),t._v(" UNION")]),t._v(" "),s("ol",[s("li",[t._v("如果是UNION合并之后再根据limit返回部分结果集，那么可以在每个子句上先使用limit来限制子句的结果集的返回，这样就可以减少临时表数据。如果还有排序也是如此。一般是分页场景下使用，如果需要返回精确的行记录总数，这个就没啥太好的办法了。")]),t._v(" "),s("li",[t._v("尽量使用UNION ALL， UNION去重会消耗CPU")])]),t._v(" "),s("h4",{attrs:{id:"通过in来让查询能够使用上索引"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#通过in来让查询能够使用上索引"}},[t._v("#")]),t._v(" 通过IN来让查询能够使用上索引")]),t._v(" "),s("p",[t._v("假设有tb1有索引(a,b)，而查询只使用到b列，这时候MySQL是只能全表扫描，可以加上a IN（val1, val2,val3)来让查询走索引，不用再新建单列b索引。"),s("strong",[t._v("此方法只使用a列中不同的值比较少的情况")])]),t._v(" "),s("h4",{attrs:{id:"查询优化器提示"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#查询优化器提示"}},[t._v("#")]),t._v(" 查询优化器提示")]),t._v(" "),s("p",[t._v("如果对优化器的执行计划不满意，可以使用优化器提供的hint来控制最终的执行计划，作为一个开发人员，尽量不用这些小聪明")]),t._v(" "),s("p",[t._v("https://dev.mysql.com/doc/refman/8.0/en/optimizer-hints.html#optimizer-hints-query-block-naming")]),t._v(" "),s("h4",{attrs:{id:"优化count-查询"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化count-查询"}},[t._v("#")]),t._v(" 优化COUNT()查询")]),t._v(" "),s("p",[t._v("COUNT()有两个作用：统计某列值（不会统计NULL）的数量及统计结果集行数")]),t._v(" "),s("p",[t._v("COUNT(*)会忽略所有的列，直接统计行数，如果我们想统计行数最好用COUNT(*)，意义比较清晰。COUNT(1)也行")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("使用近似值")]),t._v(" "),s("p",[t._v("如果业务场景中不要求完全精确的近似值，可以使用explain返回的估算行数")])]),t._v(" "),s("li",[s("p",[t._v("增加汇总表/缓存")]),t._v(" "),s("p",[t._v("实现不简单")])])]),t._v(" "),s("h4",{attrs:{id:"优化limit分页"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#优化limit分页"}},[t._v("#")]),t._v(" 优化LIMIT分页")]),t._v(" "),s("p",[t._v("LIMIT在偏移量特别大的时候，代价会特别高")]),t._v(" "),s("ol",[s("li",[s("p",[t._v("使用覆盖索引扫描")]),t._v(" "),s("p",[t._v("可以通过延迟关联的方式来让MySQL扫描尽可能少的页")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/202402172235528.png",alt:""}})])]),t._v(" "),s("li",[s("p",[t._v("转换成已知的位置查询")]),t._v(" "),s("p",[t._v("如果能预先计算出边界值，就可以转成已知位置的查询")]),t._v(" "),s("p",[s("img",{attrs:{src:"https://raw.githubusercontent.com/soda1/img/main/202402172241015.png",alt:""}})])]),t._v(" "),s("li",[s("p",[t._v("通过主键做游标查询")]),t._v(" "),s("p",[t._v("一般主键都是有序的，如果我们知道上一页的最后主键值，那么下一页查询就可以从上一页的主键值开始了。实际业务中应该很难可以应用到吧")])])])])])])}),[],!1,null,null,null);s.default=e.exports}}]);