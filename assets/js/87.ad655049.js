(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{447:function(e,t,o){"use strict";o.r(t);var n=o(4),i=Object(n.a)({},(function(){var e=this,t=e._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h4",{attrs:{id:"solid原则"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#solid原则"}},[e._v("#")]),e._v(" SOLID原则")]),e._v(" "),t("p",[e._v("SOLID原则是由5个原则的首字母组成的原则，由Robert C.Martin提出来的五大原则。 "),t("strong",[e._v("SOLID")]),e._v(" is a "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Mnemonic",target:"_blank",rel:"noopener noreferrer"}},[e._v("mnemonic"),t("OutboundLink")],1),e._v(" "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Acronym",target:"_blank",rel:"noopener noreferrer"}},[e._v("acronym"),t("OutboundLink")],1),e._v(" for five design principles intended to make "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Object-oriented",target:"_blank",rel:"noopener noreferrer"}},[e._v("object-oriented"),t("OutboundLink")],1),e._v(" designs more understandable, flexible, and "),t("a",{attrs:{href:"https://en.wikipedia.org/wiki/Software_maintenance",target:"_blank",rel:"noopener noreferrer"}},[e._v("maintainable"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("ol",[t("li",[t("p",[e._v("The "),t("strong",[e._v("S")]),e._v("ingle Responsibility Principle  SRP单一职责原则")]),e._v(" "),t("blockquote",[t("p",[e._v("A module should be responsible to one, and only one, actor")])]),e._v(" "),t("p",[e._v("一个类只负责完成一个职责或者功能。不要设计大而全的类，要设计粒度小、功能单一的 类。单一职责原则是为了实现代码高内聚、低耦合，提高代码的复用性、可读性、可维护 性。")]),e._v(" "),t("p",[e._v("一个类是否单一要看具体的业务需求，随着业务的发展当类变得臃肿的就要考虑进行拆分，设计更小粒度的类。")]),e._v(" "),t("p",[e._v("下列情况可能会说明类职责不够单一")]),e._v(" "),t("ul",[t("li",[e._v("类中的代码行数、函数或者属性过多；")]),e._v(" "),t("li",[e._v("类依赖的其他类过多，或者依赖类的其他类过多；")]),e._v(" "),t("li",[e._v("私有方法过多； 比较难给类起一个合适的名字；")]),e._v(" "),t("li",[e._v("类中大量的方法都是集中操作类中的某几个属性。")])])]),e._v(" "),t("li",[t("p",[e._v("The "),t("strong",[e._v("O")]),e._v("pen-Closed Principle  OCP开闭原则")]),e._v(" "),t("blockquote",[t("p",[e._v("Software entities ... should be open for extension, but closed for modification")])]),e._v(" "),t("blockquote",[t("p",[e._v("A module will be said to be open if it is still available for extension. For example, it should be possible to add fields to the data structures it contains, or new elements to the set of functions it performs.")]),e._v(" "),t("p",[e._v("A module will be said to be closed if [it] is available for use by other modules. This assumes that the module has been given a well-defined, stable description (the interface in the sense of information hiding).")])]),e._v(" "),t("p",[e._v("只要新增的功能涉及修改的地方没有破坏原有的代码的功能运行、功能测试，那它就是符合OCP的")]),e._v(" "),t("blockquote",[t("p",[e._v("对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是 为了让系统更有弹性！")])])]),e._v(" "),t("li",[t("p",[e._v("The "),t("strong",[e._v("L")]),e._v("iskov Substitution Principle LSP里氏替换原则")]),e._v(" "),t("blockquote",[t("p",[e._v("Functions that use pointers or references to base classes must be able to use objects of derived classes without knowing it.")])]),e._v(" "),t("p",[e._v("LSP和多态有点像，但侧重点不一样。多态着重的是父类引用可以使用子类对象，LSP也是通过多态这一特性来使用子对象。但它强调的是功能上的一致，比如父类的function中没有定义要抛出的异常，子类实现此function时如果抛出了未定义的异常，那就是违背LSP")]),e._v(" "),t("p",[e._v("违背LSP的一些例子")]),e._v(" "),t("ul",[t("li",[e._v("子类违背父类声明要实现的功能")]),e._v(" "),t("li",[e._v("子类违背父类对输入、输出、异常的约定")]),e._v(" "),t("li",[e._v("子类违背父类注释中所罗列的任何特殊说明")])])]),e._v(" "),t("li",[t("p",[e._v("The "),t("strong",[e._v("I")]),e._v("nterface Segregation Principle ISP接口隔离原则")]),e._v(" "),t("blockquote",[t("p",[e._v("Clients should not be forced to depend upon interfaces that they do not use.")])]),e._v(" "),t("blockquote",[t("p",[e._v("ISP can be seen as similar to SRP for interfaces; but it is more than that. ISP generalizes into: “Don’t depend on more than you need.” SRP generalizes to “Gather together things that change for the same reasons and at the same times.”")]),e._v(" "),t("p",[e._v("Imagine a stack class with both push and pop. Imagine a client that only pushes. If that client depends upon the stack interface, it depends upon pop, which it does not need. SRP would not separate push from pop; ISP would.")])]),e._v(" "),t("p",[e._v("ISP和RSP有点像，SRP侧重于module，职责是否保持单一化。ISP侧重调用者是否需要接口所有功能。SRP可以说是ISP的冗余。")])]),e._v(" "),t("li",[t("p",[e._v("The "),t("strong",[e._v("D")]),e._v("ependency Inversion Principle  DIP依赖倒置原则")]),e._v(" "),t("blockquote",[t("ol",[t("li",[e._v("High-level modules should not import anything from low-level modules. Both should depend on abstractions (e.g., interfaces).")]),e._v(" "),t("li",[e._v("Abstractions should not depend on details. Details (concrete implementations) should depend on abstractions.")])])]),e._v(" "),t("p",[e._v("上层服务应该依赖于底层接口，且底层接口不应该依赖于具体的实现（即通过构造器之类的方式注入到上层服务中）")])])]),e._v(" "),t("h4",{attrs:{id:"kiss"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#kiss"}},[e._v("#")]),e._v(" KISS")]),e._v(" "),t("blockquote",[t("p",[e._v("keep it simple and stupid")])]),e._v(" "),t("p",[e._v("写的功能代码尽可能的简单，不要用一些增加理解困难度的trick")]),e._v(" "),t("ul",[t("li",[e._v("不要使用同事可能不懂的技术来实现代码。比如前面例子中的正则表达式，还有一些编程语言中过于高级的语法等。")]),e._v(" "),t("li",[e._v("不要重复造轮子，要善于使用已经有的工具类库。经验证明，自己去实现这些类库，出 bug 的概率会更高，维护的成本也比较高。")]),e._v(" "),t("li",[e._v("不要过度优化。不要过度使用一些奇技淫巧（比如，位运算代替算术运算、复杂的条件语句代替 if-else、使用一些过于底层的函数等）来优化代码，牺牲代码的可读性。")])]),e._v(" "),t("h4",{attrs:{id:"yagni"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#yagni"}},[e._v("#")]),e._v(" YAGNI")]),e._v(" "),t("blockquote",[t("p",[e._v("You aren't gonna need it")])]),e._v(" "),t("p",[e._v("不要过度设计，当然接口扩展这些是可以做的")]),e._v(" "),t("h4",{attrs:{id:"dry"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dry"}},[e._v("#")]),e._v(" DRY")]),e._v(" "),t("blockquote",[t("p",[e._v("Don't repeat yourself")])]),e._v(" "),t("p",[e._v("不要写重复代码")]),e._v(" "),t("p",[e._v("有三种典型情况")]),e._v(" "),t("ul",[t("li",[t("p",[e._v("逻辑重复")]),e._v(" "),t("p",[e._v("若语义不重复不违反DRY")])]),e._v(" "),t("li",[t("p",[e._v("功能语义重复")]),e._v(" "),t("p",[e._v("违反DRY")])]),e._v(" "),t("li",[t("p",[e._v("代码执行重复")]),e._v(" "),t("p",[e._v("在执行中多次执行相同代码（函数）违反DRY")])])]),e._v(" "),t("p",[e._v("是否违法DRY，主要看语义")]),e._v(" "),t("h4",{attrs:{id:"lod"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#lod"}},[e._v("#")]),e._v(" LOD")]),e._v(" "),t("blockquote",[t("p",[t("strong",[e._v("Law of Demeter")]),e._v(" or "),t("strong",[e._v("principle of least knowledge")])]),e._v(" "),t("ul",[t("li",[e._v('Each unit should have only limited knowledge about other units: only units "closely" related to the current unit.')]),e._v(" "),t("li",[e._v("Each unit should only talk to its friends; don't talk to strangers.")]),e._v(" "),t("li",[e._v("Only talk to your immediate friends.")])])]),e._v(" "),t("p",[e._v("不该有直接依赖关系的类之间，不要有依赖；有依赖关系的类之间，尽量只依赖必要的接口。迪米特法则是希望减少类之间的耦合，让类越独立越好。每个类都应该少了解系统的其他部分。一旦发生变化，需要了解这一变化的类就会比较少。")])])}),[],!1,null,null,null);t.default=i.exports}}]);